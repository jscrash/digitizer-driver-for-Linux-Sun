/* DEC/CMS REPLACEMENT HISTORY, Element VI_MAIN4.PC */
/* *4    16-AUG-1991 17:21:50 JESSIE "(SPR 0) for BHP's modification" */
/* *3     2-JUL-1991 10:18:04 DOUG "(SPR 0) (jtm) changed gin and srch size, and row/col handling, for Don." */
/* *2    14-JUN-1991 17:59:39 DOUG "(SPR 0) Initial checkin in correct library." */
/* *1    14-JUN-1991 17:55:27 DOUG "Back interpolate velocity grids to seismic lines." */
/* DEC/CMS REPLACEMENT HISTORY, Element VI_MAIN4.PC */
/******************************************************************************
                                                                           
                Copyright Finder Graphics Systems, Inc. 1991
                    Unpublished -- All rights reserved

THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Exploration Systems, Inc.  AND MAY
CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE
DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE
MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF

                            Finder Graphics Systems
                            201 Tamal Vista Blvd.
                            Corte Madera, CA  94925
                            (415) 927-0100

(The above notice does not constitute an admission of publication or
unrestricted dissemination of the work)

******************************************************************************/

/* Function Description -------------------------------------------------------
Description:
    Back interpolate from velocity grids to lines.
    VERSION 2.0

Prototype:
    vi_main4 -oid aaa -proj bbb -line ccc -gin ddd -hor eee -srch yyy -vtyp fff
             -sample ggg -ref hhh -depth

Parameters:
    -oid aaa                    Oracle ID/Password, e.g. EUREKA/EUREKA
    -proj bbb                   Project name
    -line ccc                   Seismic line select list name
    -gin ddd                    Prefix to be used for input grids
    -hor  eee                   Seismic horizon names
    -srch yyy                   Owner of horizons.
    -vtyp fff                   Type of input velocity data, legal
                                values are 'AVG' or 'STK'
    -sample ggg                 Output sample interval
                                = 1, Use every sample
                                = 5, Use every 5th sample, etc.
                                default value is '1'
    -ref hhh                    Optional reference velocity function, input
                                is assumed to be in increasing time order
                                and arranged as t1 v1 t2 v2 ... tn vn
    -depth                      If present, produce depth horizons
                 
Limitations/Assumptions:
 
-----------------------------------------------------------------------------*/

#include "esi_c_lib.h"            /* for strings */
#ifndef ESI_FM_H
#include "esi_fm.h"
#endif
#include "esi_se.h"            /* for se typedefs and prototypes */

#ifndef ESI_NL_H
#include "esi_nl.h"            /* for shot nlist */
#endif

#ifndef ESI_NL_ERR_H
#include "esi_nl_err.h"
#endif

#ifndef ESI_SE_ERR_H
#include "esi_se_err.h"
#endif

#ifndef ESI_VI_H
#include "esi_vi.h"
#endif

#ifndef ESI_QS_H
#include "esi_qs.h"            /* for project projection */
#endif

#ifndef ESI_OR_H
#include "esi_or.h"
#endif

#ifndef ESI_ORACLE_H
#include "esi_oracle.h"
#endif

#ifndef ESI_SL_METH_AH
#include "esi_sl_meth.ah"           
#endif

publicdef INT main (argc, argv)
INT argc;
CHAR *argv[];
    {
    PROJECT_NAME project;    
    INT status;
    INT i, j, k;
    INT num;
    BOOL go;
    CHAR vel[4];
    NLIST_ID lines;
    CHAR gin[81];
    CHAR *horz;
    INT numhorz;
    CHAR *c;
    INT isamp = 1;
    INT  nref;
    DOUBLE rt[30];
    DOUBLE rv[30];
    BOOL idep;
    CHAR srch[81];
    CHAR srcv[81];
   
    /* process command line arguments */
    /* ------------------------------ */
    go = TRUE;
    
    /* Get ORACLE id/password */
    /* ---------------------- */
    i = vi_args (argc, argv, "-oid", &num);
    if (i < 0)
        {
        fprintf (stderr, "No Oracle ID.\n");
        go = FALSE;
        }
    else
        {
        if ((status = or_login (argc, argv)) IS_NOT_EQUAL_TO SUCCESS)
            {
            fprintf (stderr,
                     "Unable to connect to Oracle using %s: Terminating.\n",
                     argv[i + 1]);
            exit (EXIT_FAILURE);
            }
        }
    /** Add one more argument to get owner of horizon data ** HH 05/1991 **/
    /* Get owner of horizon data to be used */
    /* ------------------------------------ */

    i = vi_args (argc, argv, "-srch", &num);
    if (i < 0 || num EQUALS 0)
        {
        fprintf (stderr, "No horizon source.\n");
        go = FALSE;
        }
    else
        {
        strcpy (srch, ts_sto_upper (argv[i + 1]));
        }
 
    /* Get project name */
    /* ---------------- */
    i = vi_args (argc, argv, "-proj", &num);
    if (i < 0)
        {
        fprintf (stderr, "No project.\n");
        go = FALSE;
        }
    else
        {
        qs_set_c (QS_PROJECT_NAME, ts_sto_upper (argv[i + 1]), 0);
        strcpy (project, argv[i + 1]);
        if ((status = finder_config_project (FALSE)) IS_NOT_EQUAL_TO SUCCESS)
            {
            fprintf (stderr, 
                     "Unable to connect to project %s: Terminating.\n",
                     argv[i + 1]);
            or_logout (FALSE);
            goto NO_PROCESS;
            }
        }

    /* Get grid velocity data type */
    /* --------------------------- */
    i = vi_args (argc, argv, "-vtyp", &num);
    if (i > 0)
        {
        ts_sto_upper (argv[i + 1]);
        if (strcmp (argv[i + 1], "AVG")     != 0 
            AND strcmp (argv[i + 1], "STK") != 0)
            {
            go = FALSE;
            fprintf (stderr, "-vtyp must have 'AVG' or 'STK' as argument\n");
            }
        else
            strcpy (vel, argv[i + 1]);
        }
    else
        {
        strcpy (vel, "AVG");        /* default */
        }

    /* Get output subsampling */
    /* ---------------------- */
    i = vi_args (argc, argv, "-sample", &num);
    if (i > 0 AND num > 0)
        {
        c = argv[i + 1];
        j = strlen (c);
        isamp = atoi(argv[i + 1]);
        }

    /* Get seismic line select list name */
    /* --------------------------------- */
    i = vi_args (argc, argv, "-line", &num);
    if (i > 0 AND num > 0)
        {
        strcpy (lines, argv[i + 1]);
        }
    else
        {
        fprintf (stderr, "No seismic select list.\n");
        go = FALSE;
        }

    /* Get input grid prefix */
    /* --------------------- */
    i = vi_args (argc, argv, "-gin", &num);
    if (i < 0 || num EQUALS 0)
        {
        fprintf (stderr, "No input grid prefix.\n");
        go = FALSE;
        }
    else
        {
        strcpy (gin, ts_sto_upper (argv[i + 1]));
        strcat (gin, "_");
        }

    /* Get list of horizon names */
    /* ------------------------- */
    i = vi_args (argc, argv, "-hor", &numhorz);
    if (i > 0 AND numhorz > 0 AND go == TRUE)
        {
        horz = (CHAR *) tc_alloc (30 * numhorz);
        for (j = 0; j < numhorz; j++)
            strcpy (&horz[30 * j], ts_sto_upper(argv[i + 1 + j]));
        }

    /* Get reference velocity function */
    /* ------------------------------- */
    i = vi_args(argc,argv,"-ref",&nref);
    if(i > 0)
        {
        if(nref EQUALS 0 || (nref%2) > 0)
            {
            go = FALSE;
            fprintf(stderr,"Reference velocity function must have\n");
            fprintf(stderr,"equal number of T-V pairs.\n");
            }
        else
            {
            nref /= 2;
            for(j = 0; j < nref; j++)
                {
                rt[j] = atof(argv[i + 1 + 2*j]);
                rv[j] = atof(argv[i + 2 + 2*j]);
                }
            }
        }

    /* Check presence of depth output flag */
    /* ----------------------------------- */
    i = vi_args(argc,argv,"-depth",&num);
    if(i > 0)
        {
        idep = TRUE;
        }
    else
        {
        idep = FALSE;
        }

    /* If main parameters were present, then can proceed. */
    /* -------------------------------------------------- */
    if (go EQUALS FALSE)
        {
        or_logout (TRUE);
        goto NO_PROCESS;
        }
        
    /* we're ready to process */
    /* ---------------------- */
    status = viz_main4 (project, lines, gin, numhorz, horz, srch, vel, isamp,
                        nref, rt, rv, idep);
    
    or_logout (TRUE);
    
    exit (EXIT_SUCCESS);
    
NO_PROCESS:
    fprintf (stderr,
             "Usage: vi_main4 -oid <oracle_login> -proj <project>\n");
    fprintf (stderr,
             "                -line <line list>\n");
    fprintf (stderr,
             "                -gin <grid name prefix>\n");
    fprintf (stderr, 
             "                -hor <Horizon list>\n");
    fprintf (stderr,
             "                -srch <Horizon owner>\n");
    fprintf (stderr,
             "                -vtyp <velocity type 'AVG|STK'>\n");
    fprintf (stderr,
             "                -sample <Sample interval>\n");
    fprintf(stderr,
             "                -ref T1 V1 T2 V2 .... TN VN\n");
    fprintf(stderr,
             "                -depth\n");
    exit (EXIT_FAILURE);
    
}

/* ========================================================================*/

/* Function Description -------------------------------------------------------
Description:
    Function to back interpolate velocities on lines from grids.

Prototype:
    privatedef INT viz_main4(PROJECT_NAME project, NLIST_ID line_list,
                             CHAR *gin, INT numhorz, CHAR *horz, CHAR *srch, 
                             CHAR *vel, INT isamp, INT nref, 
                             DOUBLE *rt, DOUBLE *rv, BOOL idep)
    
Parameters:
    (I) project     -(PROJECT_NAME) Name of project containing data.
    (I) line_list   -(NLIST_ID) Seismic select list name.
    (I) gin         -(CHAR *)   Input grid name prefix.
    (I) numhorz     -(INT)      Number of horizon names input.
    (I) horz        -(CHAR *)   Horizon name array.  Each horizon name
                                starts 30 characters from the start of
                                the previous horizon name.  
    (I) srch        -(CHAR *)   Horizon owner name.
    (I) vel         -(CHAR *)   Type of velocity grid to be processed,
                                legal values are: 'STK' or 'AVG'.
    (I) isamp       -(INT)      Output sample interval.
                                = 1, Use every sample
                                = 5, Use every 5th sample, etc.
                                default value is '1'
    (I) nref        -(INT)      Number of time,velocity pairs in 
                                reference velocity function; if > 0,
                                this velocity function will be subtracted
                                from each velocity function used in
                                processing so that velocity residuals or
                                'anomalies' will be processed.     
    (I) rt          -(DOUBLE *) Array of times for the velocity function.
    (I) rv          -(DOUBLE *) Array of velocities for velocity function.
    (I) idep        -(BOOL)     If 'TRUE', output depth horizons as well.

Return Value/Status:
    SUCCESS.
    FAIL.

Scope:
    PUBLIC

Limitations/Assumptions:

-----------------------------------------------------------------------------*/

#define BHP_FILE_ON_OFF 0   /* IF NON ZERO, CONVERTS PROGRAM TO   */
                            /* BHP HARD CODED MESSAGE FILE OUTPUT */
                            /* AND OUTPUTS VELOCITY HORIZONS WITH */
                            /* TIME INSTEAD OF VELOCITY TYPE CODE */
                            /* "0" IS CONSIDERED TO BE FGS VERSION*/

#ifdef PROTOTYPES
privatedef INT viz_main4(PROJECT_NAME project, NLIST_ID line_list,
                         CHAR *gin, INT numhorz, CHAR *horz, CHAR *srch, 
                         CHAR *vel, INT isamp, INT nref, 
                         DOUBLE *rt, DOUBLE *rv, BOOL idep)
#else
privatedef INT viz_main4(project, line_list, gin, numhorz, horz, srch,
                         vel, isamp, nref, rt, rv, idep)
PROJECT_NAME project;
NLIST_ID     line_list;
CHAR        *gin;
INT          numhorz;
CHAR        *horz;
CHAR        *srch;
CHAR        *vel;
INT          isamp;
INT          nref;
DOUBLE      *rt;
DOUBLE      *rv;
BOOL idep;
#endif
{
    SEIS_SURV survey;       /* seismic survey name                          */
    INT numlines;           /* no. lines to actually process                */
    INT *lines;             /* internal line_id's                           */
    INT status;             /* status flag for function calls               */
    INT stat_save;          /* error status save                            */
    INT stat_flag = 0;      /* error occurrance flag                        */
    INT i;                  /* loop index                                   */
    INT j;                  /* loop index                                   */
    INT k;                  /* loop index                                   */
    INT cur_line;           /* current line instance                        */
    UINT table_num;         /* nlist table number                           */
    UINT row_num;           /* nlist row number                             */
    UINT row_knt;           /* number rows in nlist                         */
    CHAR hor_name[31];      /* horizon name                                 */
    NLIST_HEADER hlist;     /* seis_surface nlist work space                */
    NLIST_HEADER alist;     /* seis_surface nlist work space - avg vel      */
    NLIST_HEADER dlist;     /* seis_surface nlist work space - depth        */
    FM_LONG nameg;          /* horizon grid file name                       */
    FULL_LINE_NAME fname;   /* working version                              */
    CHAR source[31];        /* source name array for se_get                 */
    INT version = 0;        /* version value for se_get                     */
    FLOAT upper_time;       /* 'upper' time returned from se_get            */
    FLOAT lower_time;       /* 'lower' time returned from se_get            */
    CDP_FLOAT first_cdp;    /* first cdp value returned by se_get           */
    CDP_FLOAT last_cdp;     /* last cdp value returned by se_get            */
    CDP_FLOAT cdp_dist;     /* cdp-to-cdp spacing                           */
    DOUBLE wx;              /* shot-point (cdp) x-coordinate                */
    DOUBLE wy;              /* shot-point (cdp) y-coordinate                */
    DOUBLE min_x;           /* min x-value for all cdp values               */
    DOUBLE max_x;           /* max x-value for all cdp values               */
    DOUBLE min_y;           /* min y-value for all cdp values               */
    DOUBLE max_y;           /* max y-value for all cdp values               */
    DOUBLE min_z;           /* minimum z-value for grid                     */
    DOUBLE max_z;           /* maximum z-value for grid                     */
    CDP_FLOAT fcdp;         /* cdp value returned from surface nlist        */
    DOUBLE ftime;           /* time value returned from surface nlist       */
    FLOAT *grida;           /* grid pointer for vel grid                    */
    INT grows;              /* number rows in grids                         */
    INT gcols;              /* number columns in grids                      */
    DOUBLE gint;            /* computed grid interval                       */
    DOUBLE znull;           /* null value for grid                          */
    DOUBLE fracx;           /* fraction of x-dist into cell                 */
    DOUBLE fracy;           /* fraction of y-dist into cell                 */
    INT irow;               /* row value for interpolation                  */
    INT icol;               /* column value for interpolation               */
    INT ndx;                /* grid array index corresponding to irow,icol  */
    DOUBLE avel;            /* interpolated avg-velocity                    */
    DOUBLE fdep;            /* depth = 0.5 * avel * ftime                   */
    UINT Col_List[2];       /* Column list for nlist access                 */
    VOIDPTR Var_List[2];    /* Address list for nlist access                */
    INT Units[2];           /* UOM codes                                    */
    size_t Data_Sizes[2];   /* Data width in bytes                          */
    INT Data_Types[2];      /* Data type codes                              */
    UINT nallocated;        /* no. input values allocated                   */
    UINT ncols;             /* no. columns in Col_List                      */
    UINT nrows;             /* no. rows actually returned                   */
    INT jj;                 /* working index                                */
    FLOAT *ga;              /* grid cell corner address                     */
    FLOAT *gb;              /* grid cell corner address                     */
    FLOAT *gc;              /* grid cell corner address                     */
    FLOAT *gd;              /* grid cell corner address                     */
    DOUBLE dga;             /* grid cell corner value                       */
    DOUBLE dgb;             /* grid cell corner value                       */
    DOUBLE dgc;             /* grid cell corner value                       */
    DOUBLE dgd;             /* grid cell corner value                       */
    DOUBLE min_vel;         /* minimum velocity value                       */
    DOUBLE max_vel;         /* maximum velocity value                       */
    UINT tbl_num;           /* nlist table number                           */
    CHAR      pid[60];      /* Projection system                            */
    CHAR      coord_sys[60];/* Grid coordinate system, eg, "XY"             */
    CHAR      flt_nam[60];  /* fault name                                   */
    CHAR      top_surf[60]; /* top surface name                             */
    CHAR      base_surf[60];/* base surface name                            */
#if BHP_FILE_ON_OFF         /* BHP private usage */
    FILE *fp;           /* report file                  */
    CHAR *repfile = "INTERVEL_FROM_GRID.DAT"; /* Data report file name      */
#endif

    EXEC SQL BEGIN DECLARE SECTION;
        long lineid;
        VARCHAR linename[20];
        VARCHAR survname[500];
        VARCHAR lnstmt[2000];
        VARCHAR select[2000];   /* Hung Hoang - update seis_hor_codes */ 
    EXEC SQL END DECLARE SECTION;

    /* Get line ids specified by select list now */
    /* ----------------------------------------- */
    status = vi_lines(project, line_list, &lines, &numlines);
    if(status != SUCCESS)
        {
        fprintf(stderr, "Could not get lineids from select list.\n");
        fprintf(stderr, "status = %d\n");
        return status;
        }
    
#if BHP_FILE_ON_OFF         /* BHP private usage */
/** Open report file        **/

    fp = fopen(repfile, "w");

    fprintf(fp,"\n\n    ***** INTERPOLATE VELOCITIES *****\n\n");
    fprintf(fp,"\nThe number of lines is = %d\n", numlines);
    fprintf(fp,"\nThe number of horizons is = %d\n", numhorz);
#endif

    /* Loop over horizons */
    /* ------------------ */
    
    for (i = 0; i < numhorz; i++)
        {
        strcpy (nameg, &horz[30 * i]);
        strcpy (hor_name, ts_sto_upper(&horz[30 * i]));

        /* Build grid file names  */
        /* ---------------------  */
        strcpy (nameg, gin);
        strcat (nameg, hor_name);
        
        /* Get grid from DB */
        /* ---------------- */
        status = nl_read_grid(nameg, &znull, &min_x, &max_x,
                              &min_y, &max_y, &min_z, &max_z,
                              &grows, &gcols, &grida, pid,
                              coord_sys, flt_nam, top_surf,
                              base_surf);
        if (status < SUCCESS)
            {
            fprintf (stderr, "Cound not read grid '%s'.\n", nameg);
            continue;
            }

        /* Grid interval */
        /* ------------- */
        gint = (max_y - min_y) / (DOUBLE)(grows - 1);
        
        /* Loop over lines - line data repeated for each CDP */
        /* ------------------------------------------------- */
        nallocated = 1;
        ncols = 2;
        Col_List[0] = 1;
        Col_List[1] = 2;
        Var_List[0] = (VOIDPTR)&fcdp;
        Var_List[1] = (VOIDPTR)&ftime;
        Units[0] = 0;
        Units[1] = 0;
        Data_Sizes[0] = sizeof(DOUBLE);
        Data_Sizes[1] = sizeof(DOUBLE);
        Data_Types[0] = FLOAT_TYPE;
        Data_Types[1] = FLOAT_TYPE;
        cur_line = 0;
        
        /* Loop over lines */
        /* --------------- */
        for (j = 0; j < numlines; j++)
            {
            cur_line = lines[j];

            /* Get line name */
            /* ------------- */
            lineid = cur_line;
            lnstmt.len = sprintf ((char *)lnstmt.arr, 
            "SELECT LINE_NAME, SURVEY \
            FROM %s.SEIS_LINE_HDR \
            WHERE LINE_ID = %d", project, lineid);
    
            /* Set error handling */
            /* ------------------ */
            EXEC SQL WHENEVER SQLERROR GOTO :serr;
            
            EXEC SQL PREPARE S11 FROM  :lnstmt;
            EXEC SQL DECLARE C11 CURSOR FOR S11;
            EXEC SQL OPEN C11;
            EXEC SQL FETCH C11 INTO :linename, :survname;
            EXEC SQL CLOSE C11;
    
            /* Turnoff error handling */
            /* ---------------------- */
            EXEC SQL WHENEVER SQLERROR CONTINUE;
            
            /** Hung Hoang - Initialize the nlist **/
            /* ----------------------------------- */
            status = se_init_hor_nlist(&hlist);
            status = se_init_hor_nlist(&alist); 
            if(idep)
                {
                status = se_init_hor_nlist(&dlist);
                }         

            /* Now get next line */
            /* ----------------- */

            V_SETZERO(survname);
            strcpy(survey, (CHAR *)survname.arr);
            fname.id = cur_line;
            strcpy(fname.survey, survey);
            V_FROMV(fname.line_name, linename);
            fname.id = cur_line;
            strcpy(source,srch);
            
            status = se_get (&hlist, hor_name, SE_HORIZ, SE_TIME,
                             &fname, source, SE_AT_NM, SE_FINDER, &version,
                             &upper_time, &lower_time, &first_cdp, &last_cdp);
            if (status < SUCCESS)
                {
#if BHP_FILE_ON_OFF         /* BHP private usage */
                fprintf(fp,
                       "\n\nThe horizon data %s on line %d not found\n",
                       hor_name,fname.id);          
#endif
                cur_line = 0;
                continue;
                }
                
            /** Inquire to get the number of tables in this n-list **/
            /** Hung Hoang - BHPP Melbourne - Mar/1991             **/
            /* ---------------------------------------------------- */
            nl_inq_nlist_int(hlist,NL_NLIST_NTABLES, (INT *)&table_num);
            status = table_num > 0 ? SUCCESS : FAIL;
            if (status != SUCCESS)
                {
                cur_line = 0;
                continue;
                }

            /* Init table for new nlist */
            /* ------------------------ */
            status = nl_start_table (alist, &tbl_num);
            if (status < SUCCESS)
                {
                fprintf (stderr, "Error return from 'nl_set_current_row' -\n");
                fprintf (stderr, "    Horizon name = %s\n", hor_name);
                fprintf (stderr, "    Line No = %d\n", cur_line);
                fprintf (stderr, "    Status = %d\n", status);
                stat_flag = 1;
                stat_save = status;
                goto CLEANUP;
                }
            if(idep)
                {
                status = nl_start_table (dlist, &tbl_num);
                if (status < SUCCESS)
                    {
                    fprintf (stderr, 
                             "Error return from 'nl_set_current_row' -\n");
                    fprintf (stderr, "    Horizon name = %s\n", hor_name);
                    fprintf (stderr, "    Line No = %d\n", cur_line);
                    fprintf (stderr, "    Status = %d\n", status);
                    stat_flag = 1;
                    stat_save = status;
                    goto CLEANUP;
                    }
                }

            /* Get row count for this nlist */
            /* ---------------------------- */
            status = nl_inq_table_int (hlist, table_num, NL_TABLE_NROWS,
                                       (INT *) &row_knt);
            if (status < SUCCESS)
                {
                fprintf (stderr, "Error return from 'nl_inq_table_int' -\n");
                fprintf (stderr, "    Horizon name = %s\n", hor_name);
                fprintf (stderr, "    Line No = %d\n", cur_line);

                fprintf (stderr, "    Status = %d\n", status);
                stat_flag = 1;
                stat_save = status;
                goto CLEANUP;
                }

            /* Init for min,max accumulation */
            /* ----------------------------- */
            min_vel = 1.e+30;
            max_vel = -min_vel;
            
            /* Loop thru nlist */
            /* --------------- */
            for (k = 0; k < row_knt; k++)
                {
                /* get next row from nlist */
                /* ----------------------- */
                Var_List[1] = (VOIDPTR)&ftime;
                status = nl_get_rows_convert (hlist, nallocated, ncols,
                                              Col_List, Var_List, Units, 
                                              Data_Sizes, Data_Types,
                                              &nrows);
                if (status < SUCCESS)
                    {
                    fprintf (stderr,
                             "Problem with 'nl_get_rows_convert':status = %d\n",
                             status);
                    fprintf (stderr, "    Horizon name = %s\n", hor_name);
                    fprintf (stderr, "    Line No = %d\n", cur_line);
                    fprintf (stderr, "    Status = %d\n", status);
                    stat_flag = 1;
                    stat_save = status;
                    goto CLEANUP;
                    }

                /* If not in output sample range - skip next row */
                /* --------------------------------------------- */
                if (k % isamp)
                    {
                    continue;
                    }

                /* Get x,y for CDP */
                /* --------------- */
                status = se_xy_from_cdp_float (&fname, fcdp, cdp_dist, 
                                               &wx, &wy);
                if (status != SUCCESS)
                   {
                   continue;
                   } 
                                  
                /* Now calculate velocities by grid interpolation */
                /* ---------------------------------------------- */
                fracx = (wx - min_x) / gint;
                fracy = (wy - min_y) / gint;            
                icol = (INT)fracx;
                irow = (INT)fracy;
                fracx = fracx - (DOUBLE)icol;
                fracy = fracy - (DOUBLE)irow;
                ndx = irow * gcols + icol;
                
                ga = grida + ndx;
                gb = ga + 1;
                gc = gb + gcols;
                gd = ga + gcols;
                dga = (DOUBLE)*ga;
                dgb = (DOUBLE)*gb;
                dgc = (DOUBLE)*gc;
                dgd = (DOUBLE)*gd;

                avel = vi_grid_interp (dga, dgb, dgc, dgd, fracx, fracy);

                /* If reference velocity function specified - restore now */
                /* ------------------------------------------------------ */
                if(nref > 0)
                    {
                    avel += vi_lin_intp(nref, rt, rv, ftime);
                    }
                
                /* If depth output - calc depth now */
                /* -------------------------------- */
                fdep = 0.0005 * avel * ftime;
                
                /* Accumulate min,max info */
                /* ----------------------- */
                min_vel = MIN (min_vel, avel);
                max_vel = MAX (max_vel, avel);
                
                /* Put value into nlist */
                /* -------------------- */                
                Var_List[1] = (VOIDPTR)&avel;
                status = nl_add_rows_convert (alist, nallocated, ncols, 
                                              Col_List, Var_List, Units,
                                              Data_Sizes, Data_Types);
                if (status < SUCCESS)
                    {
                    fprintf (stderr, "Problem with 'nl_add_rows':status = %d\n",
                             status);
                    fprintf (stderr, "    Horizon name = %s\n", hor_name);
                    fprintf (stderr, "    Line No = %d\n", cur_line);
                    fprintf (stderr, "    Status = %d\n", status);
                    stat_flag = 1;
                    stat_save = status;
                    goto CLEANUP;
                    }
                if(idep)
                    {
                    Var_List[1] = (VOIDPTR)&fdep;
                    status = nl_add_rows_convert (dlist, nallocated, ncols, 
                                                  Col_List, Var_List, Units,
                                                  Data_Sizes, Data_Types);
                    if (status < SUCCESS)
                        {
                        fprintf (stderr,
                             "Problem with 'nl_add_rows':status = %d\n",
                             status);
                        fprintf (stderr, "    Horizon name = %s\n", hor_name);
                        fprintf (stderr, "    Line No = %d\n", cur_line);
                        fprintf (stderr, "    Status = %d\n", status);
                        stat_flag = 1;
                        stat_save = status;
                        goto CLEANUP;
                        }
                    }
                } /* end of row loop */
            
            /* Output horizon nlist */
            /* -------------------- */
            version = 0;
#if (BHP_FILE_ON_OFF == 0)
            if (strcmp (vel, "STK") EQUALS 0)
                { 
                status = se_rep (alist, hor_name, SE_HORIZ, SE_VEL_STK,
                                 &fname, source, SE_AT_NM, SE_FINDER, 
                                 version);
                }
            else
                { 
                status = se_rep (alist, hor_name, SE_HORIZ, SE_VEL_AVG,
                                 &fname, source, SE_AT_NM, SE_FINDER, 
                                 version);
                if(idep)
                    {
                    status = se_put (dlist, hor_name, SE_HORIZ, SE_DEPTH,
                                     &fname, source, SE_AT_NM, SE_FINDER, 
                                     version);
                    }
                }
#endif
#if BHP_FILE_ON_OFF         /* BHP private usage */
/** Hung Hoang - BHPP Melbourne - Mar/1991 - Update the SEIS_HOR_CODES table **/

 
            status = se_rep (alist, hor_name, SE_HORIZ, SE_TIME, 
                             &fname, source, SE_AT_NM, SE_FINDER,
                             version);
            if(idep AND strcmp (vel, "AVG") EQUALS 0)
                {
                status = se_put (dlist, hor_name, SE_HORIZ, SE_DEPTH,
                                 &fname, source, SE_AT_NM, SE_FINDER, 
                                 version);
                }
#endif                
            if (status < SUCCESS)
                {
                fprintf (stderr, "Failed in call to se_put -\n");
                fprintf (stderr, "    Horizon name = %s\n", hor_name);
                fprintf (stderr, "    Line No = %d\n", cur_line);
                fprintf (stderr, "    Status = %d\n", status);
#if BHP_FILE_ON_OFF         /* BHP private usage */
                fprintf (fp, "\nFailed in call to se_put -\n");
                fprintf (fp, "    Horizon name = %s\n", hor_name);
                fprintf (fp, "    Line No = %d\n", cur_line);
                fprintf (fp, "    Status = %d\n", status);
#endif
                cur_line = 0;
                continue;
                }
            else
                {
#if BHP_FILE_ON_OFF         /* BHP private usage */
                fprintf (fp,
                    " Horizon name = %s for Line No = %d being proccessed \n", 
                     hor_name, cur_line);
#endif
                nl_free_nlist (hlist);
                nl_free_nlist (alist);
                if(idep)
                    {
                    nl_free_nlist (dlist);
                    }
                }
            } /* end of line loop */
                
        /* end of line loop  and update the seis_hor_codes */
        /* ----------------------------------------------- */
        select.len = sprintf((char *)select.arr,
        "INSERT INTO %s.SEIS_HOR_CODES \
        (HOR_CODE,DISPLAY_NAME) \
        VALUES ('%s','%s')", project, hor_name, hor_name);   
                      
        EXEC SQL EXECUTE IMMEDIATE :select;       
        EXEC SQL COMMIT WORK;        

#if BHP_FILE_ON_OFF         /* BHP private usage */
        fprintf(fp,
          "\n\nName of the horizon %s is being updated in SEIS_HOR_CODES\n\n",
          hor_name);
#endif

        /* Free space allocated for grid workspace */
        /* --------------------------------------- */
	if (grida != (FLOAT *) 0)
		tc_free (grida);
        
        } /* end of horizon loop */
       
#if BHP_FILE_ON_OFF         /* BHP private usage */
    fclose(fp); 
#endif

    /* All ok - clear status flag */
    /* -------------------------- */
    stat_flag = 0;
    
    /* Deallocate work space */
    /* --------------------- */
CLEANUP:
    nl_free_nlist (hlist);
    nl_free_nlist (alist);
    if(idep)
        {
        nl_free_nlist(dlist);
        }
    status = tc_free (grida);
    
    /* Clear out old pointer values */
    /* ---------------------------- */
    if (stat_flag)
        {
        status = stat_save;
        }
    else
        {
        status = SUCCESS;
        }
    return status;
    
nospace:
    fprintf (stderr, "Could not allocate space for one or more variables.\n");
    stat_save = -1;
    stat_flag = 1;
    goto CLEANUP;

serr:
    stat_save = OR_STATUS;
    stat_flag = 1;
    fprintf(stderr,"SQL error: %d occurred.\n%-70.70s\n",
        OR_STATUS,OR_MESSAGE);
    goto CLEANUP;
}
