/* DEC/CMS REPLACEMENT HISTORY, Element LGZ_DM_G_T_Q.PC */
/*  4    26-FEB-1992 16:36:43 JESSIE "(SPR 6180) add TVD display of traces and tops" */
/* *3    23-AUG-1990 17:38:39 JESSIE "(SPR 1) fix include files" */
/* *2    29-MAR-1990 17:05:23 MING "(SPR 5173) GULF bug fix" */
/* *1    29-MAR-1990 17:03:25 MING "get all log trace data including quality code check" */
/* DEC/CMS REPLACEMENT HISTORY, Element LGZ_DM_G_T_Q.PC */
/******************************************************************************

                Copyright Finder Graphics Systems, Inc. 1990
		   Unpublished -- All rights reserved

THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Finder Graphics Systems, Inc.  AND
MAY CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE
DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE
MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF

			Finder Graphics Systems, Inc.
			201 Tamal Vista Blvd
			Corte Madera, CA  USA 94925
			(415) 927-0100

(The above notice does not constitute an admission of publication or
unrestricted dissemination of the work)

******************************************************************************/

#include "esi_lg_ldefs.h"
#ifndef ESI_LG_ERR_H
#include "esi_lg_err.h"
#endif
#ifndef ESI_NL_H
#include "esi_nl.h"
#endif
#ifndef ESI_QS_H
#include "esi_qs.h"
#endif
#ifndef ESI_HO_FILES_H
#include "esi_ho_files.h"
#endif
#ifndef ESI_TS_H
#include "esi_ts.h"
#endif
#ifndef ESI_ORACLE_H
#include "esi_oracle.h"
#endif

/* **************************************************************************

    ROUTINE:  LGZ_GET_TRACE_ALL

    DESCRIPTION
	To retrieve all the data of the specified trace.

    ************************************************************************ */
publicdef INT lgz_get_tr_all_data_q( traceStruct )
    /* ********************************************************************* */
LOG_TRACE_STRUCT   *traceStruct;       /* pointer of given LOG_TRACE_STRUCT.*/
{
    INT status;
    PROJECT_NAME project_name;
    CHAR text[12];
    char	dtype;

EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR	select[1024];
    int         trace_id;
    VARCHAR	source[31];
    VARCHAR	service[13];
    int	version;
    VARCHAR	shared[3];
    VARCHAR	depth_type[3];
    VARCHAR	depth_uom[24];
    double	top;
    double	base;
    double	dinc;
    double	min;
    double	max;
    VARCHAR	trace_uom[24];
    VARCHAR	comments[80];
    VARCHAR     nlist_id[65];
    VARCHAR     filename[81];
EXEC SQL END DECLARE SECTION;  
/* ************************************************************************* */

				 /* construct the table name.               */
    qs_inq_c(QS_PROJECT_NAME, project_name, (INT *) 0);
    switch( traceStruct -> depth_type )
    {
	case DEPTH_IN_DISTANCE:
	case 0:
	    dtype = 'D';
	    break;
	case DEPTH_IN_TIME:
	    dtype = 'T';
	    break;
	default:
	    dtype = 'D';   /* Consider more later... ???? */
	    break;
    }
    
    EXEC SQL WHENEVER SQLERROR GOTO err;
    EXEC SQL WHENEVER NOT FOUND GOTO nfd;
	select.len = sprintf((char *)select.arr,
"SELECT TRACE_ID, SOURCE, SERVICE, VERSION, SHARED_TRACE, TOP, BASE,\
DEPTH_INC, DEPTH_UNIT, \
DEPTH_TYPE, TRACE_MIN, TRACE_MAX, TRACE_UNIT, TRACE_REMARKS,\
DIGITAL_REF, DIGITAL_REF_VOLUME \
FROM %s.WELL_LOG_CURVE_HDR \
WHERE UWI = '%s' AND TRACE_TYPE = '%s' \
AND NVL(DEPTH_TYPE,'D') = '%c' \
AND QUALITY_CODE LIKE '*%' \
ORDER BY VERSION DESC ", project_name,
traceStruct -> uwi,
traceStruct -> trace,
dtype);

   EXEC SQL PREPARE S1 FROM :select;
   EXEC SQL DECLARE C1 CURSOR FOR S1;         

   EXEC SQL OPEN C1;

   EXEC SQL FETCH C1 INTO :trace_id, :source, :service,:version,:shared, 
			  :top, 
			  :base, :dinc, :depth_uom, 
			  :depth_type, :min, :max, 
                          :trace_uom, :comments,
	                  :nlist_id, :filename;
    traceStruct -> trace_id = trace_id;
    traceStruct -> version = version;	
    V_FROMV(traceStruct -> source, source);
    V_FROMV(traceStruct -> service, service);
    V_FROMV(traceStruct -> nlist_id, nlist_id);
    V_FROMV(traceStruct -> filename, filename);

                                  /* if the value of TOP, BASE, or DINC is   */
                                  /* zero in the trace structure, copys the  */
                                  /* value from database.                    */

     traceStruct -> non_null_top = top;
     traceStruct -> non_null_base = base;
     if(  traceStruct -> top EQUALS 0.0 )
	{
          traceStruct -> top = top;
	}

     if(  traceStruct -> base EQUALS 0.0 )
	{
          traceStruct -> base = base;
	}
    traceStruct -> shared = shared.arr[0] EQUALS 'Y';

    V_FROMV( traceStruct -> depth_uom, depth_uom);
    if( depth_type.arr[0] EQUALS 'T')
    {
	strcpy(traceStruct -> depth_or_time, "TIME");
	traceStruct -> depth_type = DEPTH_IN_TIME;
    }
    else
    {
	strcpy(traceStruct -> depth_or_time, "DEPTH");
	traceStruct -> depth_type = DEPTH_IN_DISTANCE;
    }
    V_FROMV(traceStruct -> trace_uom, trace_uom );
    traceStruct -> dinc = dinc;
    traceStruct -> max = max;
    traceStruct -> min = min;
    V_FROMV(traceStruct -> comments, comments);
	status = SUCCESS;
    goto way_out;

err:
    status = OR_STATUS;
    goto way_out;
nfd:
    status = LG_TRACE_NOT_FOUND;
    goto way_out;
way_out:
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE C1;
	return status;
}
