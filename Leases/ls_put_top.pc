/* DEC/CMS REPLACEMENT HISTORY, Element LS_PUT_TOP.PC*/
/* *3    17-JAN-1990 22:04:31 GILLESPIE "(SPR 6001) Changes for new well struct stuff"*/
/* *2    14-SEP-1989 16:17:57 GORDON "(SPR 100) Gulf/Sun/Unix mods"*/
/* *1    19-JUN-1989 12:33:58 SYSTEM ""*/
/* DEC/CMS REPLACEMENT HISTORY, Element LS_PUT_TOP.PC*/

/******************************************************************************

		Copyright Exploration Systems, Inc. 1989
		   Unpublished -- All rights reserved

THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Exploration Systems, Inc.  AND MAY
CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE
DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE
MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF 

			Exploration Systems, Inc.
			579 Market Street
			San Francisco, CA  USA 94105
			(415) 974-1600

(The above notice does not constitute an admission of publication or
unrestricted dissemination of the work) 


******************************************************************************/

#include "esi_c_lib.h"
#include "esi_qs.h"
#include "esi_oracle.h"
#include "esi_we_wells.h"
#include "esi_ls_err.h"
#include "esi_ls_msg.h"

/* EXEC ORACLE OPTION (REBIND = YES); */
EXEC ORACLE OPTION (HOLD_CURSOR = YES);

/*  *************************************************************************

    ROUTINE:  LS_PUT_TOP

    DESCRIPTION
	This is the method of putting a top to the tops database tables
     	sccording to pre-defined search rules.
        
    STATUS CODES
        LS_PRIMARY_SOURCE_FOUND.
	LS_ALTERNATE_SOURCE_FOUND.
	LS_SOURCES_NOT_FOUND.
	LS_TOP_NOT_FOUND.
        SQL ERROR CODES.
	
    INPUT
	UWI   =(UWI ) Unique Well Identifier.
	TOP   =(CHAR *)The name of Top.

    OUTPUT
	PTOP  =(TOP_STRUCT *)A pointer points to TOP_STRUCT.
	STATUS CODES.

    Author: James Chang
    ********************************************************************** */
publicdef INT ls_put_top(uwi, top, ptop)
    /************************************************************************/
UWI uwi;
CHAR top[];
TOP_STRUCT *ptop;
{
    INT status = SUCCESS;         /*   result status.                      */
    PROJECT_NAME current_project;
    static BOOL first_time = TRUE;
  
EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR select1[512];
    VARCHAR select2[512];
   				  /*   WELL_TOPS table.                    */
    static char *uwi_column;
    static char *formcode_column;
    static double md_column;
    static VARCHAR best_pick_column[3];
 EXEC SQL END DECLARE SECTION;

/* ************************************************************************* */

	EXEC SQL WHENEVER SQLERROR GOTO errrpt;

	if (first_time)
	    {
					/* inquire the current project.	     */
	    qs_inq_c(QS_PROJECT_NAME, current_project, (INT *) 0);

	    select1.len = sprintf((char *)select1.arr, "INSERT INTO %s.WELL_TOPS \
(UWI, FORM_CODE, SOURCE, MD, PICK_REF, LAST_UPDATE) \
VALUES (:uwi_column, :formcode_column, user, :md_column, \
:best_pick_column, sysdate )", current_project);
	    EXEC SQL PREPARE S1 FROM :select1;

	    select2.len = sprintf((char *)select2.arr, "UPDATE %s.WELL_TOPS \
SET SOURCE=user, MD=:md_column, PICK_REF=:best_pick_column, \
LAST_UPDATE = sysdate WHERE UWI = :uwi_column AND \
FORM_CODE = :formcode_column AND SOURCE = user", current_project);
	    EXEC SQL PREPARE S2 FROM :select2;

	    first_time = FALSE;
	    }
					/* construct the select phrase.	     */
	uwi_column = uwi;
        formcode_column = top;
	md_column = ptop -> Depth.md;
	best_pick_column.len = sprintf((char *)best_pick_column.arr, "%c", 
					ptop -> Best_Pick);

					/* try updating.  the db will kick
                                           back if the row does not exist... */

        EXEC SQL WHENEVER SQLERROR GOTO insert;

	EXEC SQL EXECUTE S2 USING :md_column, :best_pick_column, 
					 :uwi_column, :formcode_column;

        if( OR_ROWCOUNT <= 0 ) goto insert;
	EXEC SQL WHENEVER SQLERROR continue;
	EXEC SQL COMMIT WORK;
	return status;

insert:
	EXEC SQL WHENEVER SQLERROR GOTO errrpt;
	EXEC SQL EXECUTE S1 USING :uwi_column, :formcode_column, 
					 :md_column, :best_pick_column;
	EXEC SQL WHENEVER SQLERROR continue;
	EXEC SQL COMMIT WORK;
	return status;

errrpt:
	status = OR_STATUS;
	EXEC SQL ROLLBACK WORK;
	return status;
}
