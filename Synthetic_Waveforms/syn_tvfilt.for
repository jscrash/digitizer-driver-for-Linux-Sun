C  DEC/CMS REPLACEMENT HISTORY, Element SYN_TVFILT.FOR
C  *3     1-MAR-1990 16:43:56 WALTERS "(SPR 0) Fix errors and warnings as flagged by SUN Fortran compiler"
C  *2    19-SEP-1989 10:18:06 GORDON "(PURNA) GULF MODS UNDER SPR 100"
C  *1    10-AUG-1989 18:53:09 VINCE "Fortran code after UNIX mods"
C  DEC/CMS REPLACEMENT HISTORY, Element SYN_TVFILT.FOR

      SUBROUTINE SYNTVFILT(NPTSR, ITIMES, NINDEX, ICANCEL)
C**********************************************************************
C
C     ROUTINE:   SYNTVFILT
C
C     FUNCTION:  THIS SUBROUTINE GENERATES THE TIME VARIANT FILTERS AND
C                CONVOLVES THEM WITH THE REFLECTION COEFFICIENTS.
C                THE USER SELECTS THE WAVELET TYPE, PHASE, ETC.  FROM
C                A DIALOG, THEN FOR EACH TYPE SELECTED ANOTHER DIALOG
C                APPEARS, WITH WAVELET SPECIFIC PARAMETERS.  CURRENTLY
C                4 TYPES OF FILTERS MAY BE SELECTED:  RICKER, ORMSBY,
C                BUTTERWORTH, OR A USER DEFINED POINT FILTER.  THE
C                FILTER MAY BE TIME VARIANT (UP TO 3 TIME GATES). THE
C                RESULTING WAVELETS MAY BE PHASE ROTATED AS NECCESSARY.
C                THE WAVELETS ARE THEN RAMPED(IF TIME VARIANT), THEN
C                CONVOLVED WITH THE REFLECTION COEFFICIENTS TO PRODUCE
C                THE SYNTHETIC TRACE.
C
C
C     PARAMETERS:
C
C            NPTSR  = NUMBER OF POINTS IN REFLECTION COEFFICIENT ARRAY
C            IFTYPE = FILTER TYPE (RICKER,ORMSBY,ETC)
C            IPHASE = PHASE ROTATION VALUE IN DEGREES
C            ITIMES = FIRST PASS FOR A GIVEN TVF SET OR MULTIPLE PASS
C                   = 1 ON FIRST PASS
C                   = 2 ON MULTIPLES PASS
C            NPASS  = NUMBER OF THIS FILTER GROUP
C            VALUE  = REFLECTION COEFFICIENT ARRAY
C            FA     = ARRAY CONTAINING FILTER
C            OUT    = OUTPUT SYNTHETIC TRACE
C
C            F1()   = CONTAINS LOW CUT FREQ FOR ORMSBY, SLOPE1 FOR BUTTWORTH
C            F2()   = CONTAINS LOW PASS FOR ORMSBY, BUTTWORTH
C            F3()   = CONTAINS HIGH PASS FOR ORMSBY, BUTTWORTH
C            F4()   = CONTAINS HIGH CUT FOR ORMSBY, SLOPE2 FOR BUTTWORTH
C            ITIME()= CONTAINS ENDING TIME OF EACH FILTER GATE
C            NFILT  = NUMBER OF FILTERS IN THIS TVF
C
C
C    ROUTINES: CORR      = PERFORMS THE CONVOLUTION
C              SIS_FILTER= COMPUTES THE COSINE WAVELET (NO LONGER USED)
C              SIS_RICKER= COMPUTES THE RICKER WAVELET (NO LONGER USED)
C              RICKER    = COMPUTES THE CGG RICKER WAVELET
C              BUTTWORTH = COMPUTES THE BUTTERWORTH WAVELET
C              ORMSBY    = COMPUTES THE BANDPASS FILTER WAVELET
C              MO_FPLOT  = DISPLAYS FILTER SPECTRUM OF WAVELET
C
C**********************************************************************

      INCLUDE 'sf_defs.i'
      INCLUDE 'esi_am.i'
      INCLUDE 'esi_syn_io.i'
      INCLUDE 'esi_syn.i'

C
C VALUE AND OUT IN COMMON AND SHARED BY SUBROUTINE TAPER
C

      REAL         VALUE(5000), FA(MAX_FILT_LENGTH), OUT(2500)
      INTEGER      ITIME(3)
      INTEGER      HPASSFR, HCUTFR, HFREQ, HROFF
      CHARACTER*4  STRING*201

      COMMON/FILTPARAM/ IFTYPE, IDISP, IPHASE, ISAMP, IETIME

      COMMON/FILTORMS/  LCUTFR(3), LPASSFR(3), HPASSFR(3), HCUTFR(3),
     X                  ITIME_ORMS(3), NFILT_ORMS, IBTYPE, ITAPER_ORMS,
     X                  LENGTH_ORMS

      COMMON/FILTBUTT / LROFF(3), LFREQ(3), HFREQ(3), HROFF(3),
     X                  ITIME_BUTT(3), NFILT_BUTT, ITAPER_BUTT,
     X                  LENGTH_BUTT

      COMMON/FILTRICK / IPREDF(3), ITIME_RICK(3), NFILT_RICK,
     X                  ITAPER_RICK, LENGTH_RICK


      COMMON/TVFXTA/VALUE, OUT



C
C THE TRACES TO BE MERGED ARE STORED IN TRACE
C
      COMMON/AGRIC/ TRACE(2500,3)

C
C SET MAX TIME, NORMALIZATION FLAG FOR FILTERS
C
      ITMAX     = 2 * NPTSR
      NORM_FLAG = 1

C
C IF SECOND PASS THROUGH (IE WE ARE GENERATING MULTIPLES) FILTER
C      CHOICES HAVE ALREADY BEEN ENTERED SO SKIP
C
      ICANCEL=0
      IF (ITIMES.EQ.2) GOTO 345

C
C GET FILTER PARAMETERS
C

1000  CALL SYN_WAVELET_DIALOG(ICANCEL)
      IF(ICANCEL.EQ.1)THEN
	    STATUS=1
	    CLOSE(IUNIT)
	    RETURN
      ENDIF



C
C  NOW WE BRANCH TO GET FILTER PARAMETERS FOR THE FILTER REQUESTED ABOVE
C

      IF (IFTYPE.EQ.RICKER_WAV) THEN

C
C  RICKER WAVELET (REPLACED WITH CGG VERSION)
C

	  CALL SYN_RICKER_DIALOG( ICANCEL)
	  IF(ICANCEL.EQ.1)THEN
	    STATUS =1
	    GOTO 1000
	  ENDIF

	  NFILT = NFILT_RICK
	  LENGTH = LENGTH_RICK
	  ITAPER = ITAPER_RICK

      ELSE IF (IFTYPE.EQ.BUTTERWORTH_WAV) THEN

C
C  BUTTERWORTH WAVELET
C
	  CALL SYN_BUTTWRTH_DIALOG( ICANCEL)
	  IF(ICANCEL.EQ.1)THEN
	    STATUS =1
	    GOTO 1000
	  ENDIF

	  NFILT = NFILT_BUTT
	  LENGTH = LENGTH_BUTT
	  ITAPER = ITAPER_BUTT

      ELSE IF (IFTYPE.EQ.ORMSBY_WAV) THEN

C
C  ORMSBY BANDPASS WAVELET
C
	  CALL SYN_ORMSBY_DIALOG( ICANCEL)
	  IF(ICANCEL.EQ.1)THEN
	    STATUS = 1
	    GOTO 1000
	  ENDIF

	  NFILT = NFILT_ORMS
	  LENGTH = LENGTH_ORMS
	  ITAPER = ITAPER_ORMS

      ELSE

C
C  USER DEFINED WAVELET (CANNOT BE TIME VARIANT)
C
	  CALL MO_USER_DEF_DIALOG( FA, LENGTH, ISAMP, ICANCEL)

	  IF(ICANCEL.EQ.1)THEN
	    STATUS =1
	    GOTO 1000
	  ENDIF

	  NFILT = 1

      ENDIF




C
C CONVERT ITAPER FROM 2 WAY TIME TO 1 WAY TIME, CALCULATE NUM SAMPLES
C
      ITAPER1 = ITAPER / 2
      NUM_SAMPLES = LENGTH / ( 2 * ISAMP)
      NUM_SAMPLES = NUM_SAMPLES * 2 + 1
      NUM_SAMP2 = NUM_SAMPLES / 2 + 1


345   CONTINUE

      IF (ITIMES.EQ.1) THEN
	WRITE (STRING, 348) NINDEX
348     FORMAT('Generating Synthetic Group No: ',I5)
      ELSE
	WRITE (STRING, 349) NINDEX
349     FORMAT('Generating Synthetic Group No: ',I5,'  With Multiples')
      ENDIF

      CALL AMG_MESSAGE(AM_DIALOG, STRING)

C
C MAKE SURE BOTTOM OF REFL COEF IS ALL 0
C

      DO 202 JK = NPTSR + 1,  NPTSR +  50
202   VALUE(JK) = 0.00

C
C SHIFT THE VALUE BUFFER BY HALF THE NUMBER OF SAMPLES IN THE FILTER
C WAVELET (TO CENTER PROPERLY FOR CORRELATION, MUST BE DONE EACH TIME
C SINCE THE FILTER WAVELET LENGTH CAN CHANGE
C

C      CALL SYNSHIFT( VALUE, NUM_SAMP2, NPTSR)
C
	CALL ARRAY_SHIFT ( VALUE, NUM_SAMP2, NPTSR, 2500, 0.0,
     X                    JK, ISTAT)

C
C IF FIRST PASS, WRITE FILTER DATA TO PLOT FILE
C

      IF (ITIMES.EQ.1) THEN
	 WRITE(I13) IFTYPE, NFILT, LENGTH, ISAMP, IPHASE

	 IF (IFTYPE.EQ.RICKER_WAV) THEN
	     WRITE(I13) IPREDF, ITIME_RICK, ITAPER_RICK

	 ELSE IF (IFTYPE.EQ.BUTTERWORTH_WAV) THEN
	     WRITE(I13) LPASSFR, LROFF, HPASSFR, HROFF,
     X                  ITIME_BUTT, ITAPER_BUTT

	 ELSE IF (IFTYPE.EQ.ORMSBY_WAV) THEN
	     WRITE(I13) LCUTFR, LPASSFR, HPASSFR, HCUTFR,
     X                  ITIME_ORMS, ITAPER_ORMS

	 ENDIF
      ENDIF


C
C LOOP ON THE NUMBER OF FILTERS (IF TIME VARIANT FILTERING-MAX. 3)
C
      DO 2000 I = 1, NFILT
C
C CALCULATE FILTER
C
      IF (IFTYPE.EQ.RICKER_WAV) THEN

	  CALL SF_RICKER( LENGTH, ISAMP, IPREDF(I), FA, IERR)
	  ITIME(I) = ITIME_RICK(I)

      ELSE IF (IFTYPE.EQ.BUTTERWORTH_WAV) THEN

	  CALL SF_BUTTWORTH( LENGTH, ISAMP, LFREQ(I), LROFF(I),
     X                       HFREQ(I), HROFF(I), NORM_FLAG, FA)
	  ITIME(I) = ITIME_BUTT(I)

      ELSE IF (IFTYPE.EQ.ORMSBY_WAV) THEN

	  CALL SF_ORMSBY( LENGTH, ISAMP, LCUTFR(I), LPASSFR(I),
     X                    HPASSFR(I), HCUTFR(I), IBTYPE, FA,
     X                    NORM_FLAG, IERR)

	  ITIME(I) = ITIME_ORMS(I)
      ENDIF

C
C  ROTATE THE WAVELET IF REQUIRED
C
      IF (IPHASE.NE.0) THEN
	 CALL SF_ROTATE_WAVELET(FA, ISAMP, NUM_SAMPLES, FLOAT(IPHASE))
      ENDIF

C
C  IF REQUESTED, DISPLAY THE WAVELET IN TIME AND FREQ. DOMAINS
C  NOTE THAT IF TIME VARIANT FILTER WE DISPLAY ONLY THE FIRST FILTER.
C  ALSO DISPLAY ONLY IF FIRST PASS IE DO NOT REDISPLAY IF GENERATING
C  MULTIPLES.
C

      IF(IDISP.EQ.1.AND.ITIMES.EQ.1.AND.I.EQ.1) THEN

	CALL AMG_MESSAGE(AM_DIALOG,
     x                   'Generating Wavelet and Spectrum Plot')

	IF (IFTYPE.EQ.ORMSBY_WAV) THEN
	  CALL SF_PLOT(IFTYPE, NUM_SAMPLES, FA, LCUTFR(I), LPASSFR(I),
     X                 HPASSFR(I), HCUTFR(I), IPHASE, IPREDF(I),
     X                 ITYPER, ISAMP)

	ELSE
	  CALL SF_PLOT(IFTYPE, NUM_SAMPLES, FA, LFREQ(I), LROFF(I),
     X                 HFREQ(I), HROFF(I), IPHASE, IPREDF(I),
     X                 ITYPER, ISAMP)
	ENDIF

      ENDIF


C
C FLIP THE FILTER BUFFER AND CONVOLVE WITH REFL COEF
C

      CALL SF_FLIP_BUFF(FA, NUM_SAMPLES)

2000  CALL CORR(FA, VALUE, TRACE(1,I), NUM_SAMPLES,
     X            NPTSR + NUM_SAMP2 + 50, L)



C
C IF JUST ONE FILTER, WE ARE DONE
C
      IF (NFILT.EQ.1) GOTO 1234

C
C CONVERT ITIME  TO 1 WAY TIME
C
	DO 101 I = 1, NFILT
  101   ITIME(I) = ITIME(I) / 2

      IF (NFILT.GT.1) CALL SYNTVFTAPER(NFILT,ITIME,ITAPER1)

1234  DO 301 J = 1, MIN0(NPTSR + NUM_SAMP2 + 50, 2500)
	OUT(J) = 0.0
	DO 301 I = 1, NFILT
301       OUT(J) = OUT(J) + TRACE(J,I)


      STRING=' '
      CALL SYN_STATUS_MESSAGE(STRING)
      CALL AMG_MESSAGE(AM_DIALOG, STRING)
      RETURN
      END











      SUBROUTINE SYNTVFTAPER(NFILT,ISTRT,ITAPER)
C***********************************************************************
C
C     ROUTINE:   SYNTVFTAPER
C
C     FUNCTION:  THIS PROGRAM WILL MERGE A GIVEN NUMBER OF SEPERATELY
C                CONVOLVED  RELECTION COEFFICIENT SERIES INTO A SINGLE
C                TRACE.  THEY ARE MERGED TOGETHER USING A RAMP FUNCTION
C                OF SPECIFIED LENGTH CENTERED AROUND A GIVEN SAMPLE.
C
C     NFILT  - NUMBER OF TRACES TO MERGE
C     ISTRT  - ARRAY CONTAINING ENDING SAMPLE NUMBER OF TRACES TO USE
C              IN MERGE
C     ITAPER - LENGTH OF TAPER RAMP FUNCTION
C**********************************************************************

C
C COMMON BLOCK CONTAINING THE NFILT TRACES
C
      COMMON/AGRIC /TRACE(2500,3)
C
C EACH ELEMENT IN ISTRT CORRESPONDS TO A TRACE IN TRACE
C
      INTEGER ISTRT(3)
C
C THIS COMMON BLOCK IS USED HERE TO SAVE STORAGE. VALUE IS REFLECTION COER.
C ARRAY AND IS NOT USED HERE. SCLTOP, SCLBOT AND DUMMY ARE IN THE SAME SPACE
C AS THE ULTIMATE OUTPUT TRACE.
C SCLTOP CONTAINS THE RAMP FUNCTION FOR THE TOP OF THE RAMP
C SCLBOT CONTAINS THE RAMP FUNCTION FOR THE BOTTOM OF THE RAMP
C
      COMMON/TVFXTA/VALUE(5000),SCLTOP(501),SCLBOT(501),DUMMY(1498)
C
C BUILD RAMP FUNCTIONS
C
      TOP=1.
      BOT=0.
      XNC=1.0
      IF(ITAPER.NE.0) XNC = 1.0 / ITAPER
      NTAP = ITAPER+1

      DO 110 I=1,NTAP
	 SCLTOP(I)=TOP
	 SCLBOT(I)=BOT
	 TOP=TOP-XNC
  110 BOT=BOT+XNC
C
C GET RID OF PARTS OF TRACES WE DO NOT WISH TO USE BY SETTING THAT PORTION
C TO ZERO.  SCALE WITH RAMP FUNCTION THE TOP AND BOTTOM OF APPROPRIATE PARTS
C OF TRACES.
C
      DO 1000 II=1,NFILT
C
C IF LAST FILTER, GO TO FINISH UP.
C
      IF(II.EQ.NFILT) GOTO 3
      GOTO (1,2,3),II
C
C FIRST PART OF TRACE, SO ZERO OUT ALL OF BOTTOM
C
    1 DO 10 I=ISTRT(II)+1,2500
   10 TRACE(I,II)=0.
      GOTO 1000
C
C MIDDLE OF TRACE SO ZERO OUT TOP AND BOTTOM
C
    2 DO 11 I=1,ISTRT(II-1)-ITAPER
   11 TRACE(I,II)=0.
      DO 12 I=ISTRT(II)+1,2500
   12 TRACE(I,II)=0.
      GOTO 1000
C
C LAST TRACE SO ZERO OUT TOP ONLY
C
    3 DO 13 I=1,ISTRT(II-1)-ITAPER
   13 TRACE(I,II)=0.
 1000 CONTINUE
C
C SCALE OUT PARTS THAT NEED IT
C
      DO 1001 II=1,NFILT
C
C IF LAST TRACE GO TO FINISH UP
C
      IF(II.EQ.NFILT) GOTO 102
      GOTO(100,101,101,101,102),II
C
C TOP OF TRACE, SO SCALE BOTTOM OF TRACE WITH TOP OF RAMP

  100 K=1
      DO 20 I=ISTRT(II)-ITAPER,ISTRT(II)
      TRACE(I,II)=TRACE(I,II)*SCLTOP(K)
   20 K=K+1
      GOTO 1001
C
C MIDDLE OF TRACE, SO SCALE TOP OF TRACE WITH BOTTOM RAMP AND BOTTOM OF TRACE
C WITH TOP OF RAMP.
  101 K=1
      DO 21 I=ISTRT(II-1)-ITAPER,ISTRT(II-1)
      TRACE(I,II)=TRACE(I,II)*SCLBOT(K)
   21 K=K+1
      K=1
      DO 22 I=ISTRT(II)-ITAPER,ISTRT(II)
      TRACE(I,II)=TRACE(I,II)*SCLTOP(K)
   22 K=K+1
      GOTO 1001
C
C LAST TRACE, SO SCALE TOP OF TRACE WITH BOTTOM OF RAMP
C
  102 K=1
      DO 23 I=ISTRT(II-1)-ITAPER,ISTRT(II-1)
      TRACE(I,II)=TRACE(I,II)*SCLBOT(K)
   23 K=K+1
 1001 CONTINUE
      RETURN
      END
















      SUBROUTINE SYNVACALC(NSAMP,VA,ISTART)
C***********************************************************************
C
C     ROUTINE:    SYNVACALC
C
C     FUNCTION:   THIS SUBROUTINE CALCULATES THE RELECTION
C                 COEFFECIENT ARRAY
C
C NSAMP  - NUMBER OF TIME SAMPLES IN VELOCITY AND DENSITY ARRAY
C VA     - REFLECTION COEFFECIENT ARRAY
C ISTART - STARTING POSITION OF VA ARRAY TO PUT VALUES. THIS SHIFT VALUE IS
C          EQUAL TO ONE HALF THE LENGTH OF THE FILTER USED IN CONVOLUTION.
C
C***********************************************************************
      COMMON /VELDEN/VEL(12000),DEN(12000),DEPTH(2500)
      DIMENSION VA(1)
C
C COMPUTE REFLEXION COEFFICIENTS
C
      DO 60 I=1,NSAMP
      VA(I)=((DEN(I+1)*VEL(I+1))-(DEN(I)*VEL(I)))/((DEN(I+1)*VEL(I+1))+
     1(DEN(I)*VEL(I)))
   60 CONTINUE
C
      CALL ARRAY_SHIFT ( VA, ISTART, NSAMP, 2500, 0.,
     X                    I,ISTAT)
C
      RETURN
      END







      SUBROUTINE SYNSHIFT(RCBUFF, FIRSTSAMP, NUMSAMPS)
C***********************************************************************
C
C     ROUTINE:    SYNSHIFT
C
C     FUNCTION:   THIS SUBROUTINE SHIFTS THE REFLECTION COEFFICIENT
C                 BUFFER TO FIRSTSAMP (USED FOR SHIFTING BY ONE-HALF
C                 THE NUMBER OF SAMPLES IN THE FILTER BUFFER BEFORE
C                 CONVOLUTION WITH THE FILTER BUFFER)
C
C     RCBUFF      - REFLECTION COEFF. ARRAY
C     FIRSTSAMP   - NEW INDEX TO SHIFT 1ST VALUE IN RCBUFF TO
C     NUMSAMPS    - NUMBER OF VALUES TO SHIFT
C
C***********************************************************************

      DIMENSION RCBUFF(1)
      INTEGER   FIRSTSAMP

C
C  SHIFT THE VALUES
C
      J = FIRSTSAMP + NUMSAMPS

      DO 1000 I = NUMSAMPS, 1, -1
	J = J - 1
1000  RCBUFF(J) = RCBUFF(I)

C
C  PAD FRONT OF BUFFER TO ZEROS
C
      DO 2000 I = 1, FIRSTSAMP - 1
2000  RCBUFF(I) = 0.0


      RETURN
      END

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE ARRAY_SHIFT ( ARRAY, NSHIFT, INPTS, NMAX, VAL,
     X     OUTPTS, STATUS)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C       THIS ROUTINE SHIFT THE ARRAY OF NSHIFT SAMPLES
C
C       INPUT :
C           ARRAY       ARRAY TYPE REAL
C           NSHIFT      SHIFT AMPLITUDE ( IN NB OF SAMPLES)
C           INPTS       NB OF SAMPLES INPUT
C           NMAX        MAX NUMBER PERMITTED OF SAMPLES.
C           VAL         CONSTANT VALUE FOR FRONT PADDING
C
C       OUTPUT :
C           OUTPTS      NEW NUMBER OF SAMPLES
C           STATUS      ....
C
C       IF NSHIFT IS >0 ADD SAMPLES REPEATING THE FIRST VALUE
C       IF NSHIFT IS <0 CANCEL THE FIRST NSHIFT VALUES
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      REAL ARRAY(1)
      REAL VAL
      INTEGER NSHIFT,INPTS,OUTPTS,NMAX,STATUS
      INTEGER SUCCESS, FAIL
      SUCCESS = 0
      FAIL = 1
C
      OUTPTS = INPTS + NSHIFT
C
C       IF NSHIFT = 0 DO NOTHING...GOOD JOB
C
      IF ( NSHIFT .EQ. 0) THEN
	STATUS = SUCCESS
	RETURN
      ENDIF
C
C       IF NSHIFT < 0  CANCEL POINTS
C
      IF ( NSHIFT .LT. 0 ) THEN
	IF ( OUTPTS .LE. 0 ) THEN
C
C       TOO_MUCH CANCELLED
C
	    OUTPTS = 0
	    STATUS = FAIL
	    RETURN
	ENDIF
	DO 10  I = 1, OUTPTS
10      ARRAY(I) = ARRAY ( I - NSHIFT )
	STATUS = SUCCESS
	RETURN
      ENDIF
C
C       IF NSHIFT >0 ADD POINTS BUT DO NOT GO TOO FAR
C
C       IF TOO MUCH FAIL
C
      IF ( NSHIFT .GE. (NMAX-1) ) THEN
	OUTPTS = 0
	STATUS = FAIL
	RETURN
      ENDIF
C
C       EVENTUALLY CLIP TO LENGTH NMAX
C
      IF (OUTPTS .GT. NMAX) OUTPTS = NMAX
C
C       NOW MOVE
C
      DO 20 I = OUTPTS, NSHIFT + 1, -1
20    ARRAY(I) = ARRAY( I- NSHIFT)
C
C       PAD FIRST VALUES WITH "VAL"
C
      DO 30 I = 1, NSHIFT
30    ARRAY(I) = VAL
      STATUS = SUCCESS
      RETURN
      END
                   
