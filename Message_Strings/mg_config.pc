/* DEC/CMS REPLACEMENT HISTORY, Element MG_CONFIG.PC */
/* *2    18-OCT-1991 18:16:15 VINCE "(SPR 1) Fixed precompile usage of #ifdef UNIX to #else of #ifdef vms" */
/* *1    13-NOV-1990 11:27:45 VINCE "initial release" */
/* DEC/CMS REPLACEMENT HISTORY, Element MG_CONFIG.PC */
/* DEC/CMS REPLACEMENT HISTORY, Element MG_CONFIG.PC */
/* *4    15-AUG-1990 12:33:37 VINCE "(SPR 1) added output file header and fixed error in #ifndef output" */
/* *3    10-AUG-1990 13:11:53 VINCE "(SPR 1) added OUTDIR option" */
/* *2     9-AUG-1990 16:39:53 VINCE "(SPR 1) added the -rebuild command line switch" */
/* *1     9-AUG-1990 11:20:18 VINCE "moved from MAIN" */
/* DEC/CMS REPLACEMENT HISTORY, Element MG_CONFIG.PC */
/* DEC/CMS REPLACEMENT HISTORY, Element MG_CONFIG.PC*/
/* *4    22-SEP-1989 15:24:58 GILLESPIE "(SPR 101) fix castings"*/
/* *3    19-SEP-1989 13:45:57 GILLESPIE "(SPR 100) GULF MODS"*/
/* *2     6-SEP-1989 08:36:30 GORDON "(SPR 200) Gulf changes (August trip)"*/
/* *1     1-JUL-1989 12:23:37 GILLESPIE ""*/
/* DEC/CMS REPLACEMENT HISTORY, Element MG_CONFIG.PC*/
/******************************************************************************

		Copyright Exploration Systems, Inc. 1989
		   Unpublished -- All rights reserved

THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Exploration Systems, Inc.  AND MAY
CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE
DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE
MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF 

			Exploration Systems, Inc.
			579 Market Street
			San Francisco, CA  USA 94105
			(415) 974-1600

(The above notice does not constitute an admission of publication or
unrestricted dissemination of the work) 


******************************************************************************/


#include "esi_gl_defs.h"

#ifndef ESI_ORACLE_H
#include "esi_oracle.h"
#endif

#ifndef ESI_C_LIB_H
#include "esi_c_lib.h"
#endif

#ifndef ESI_HO_FILES_H
#include "esi_ho_files.h"
#endif

#ifndef ESI_TS_H
#include "esi_ts.h"
#endif

/******************************************************************************/
/*                                                                            */
/*                        ESI/FINDER INCLUDE FILE GENERATOR                   */
/*                                                                            */
/******************************************************************************/

PROGNAME("MG_CONFIG");

main (argc,argv)

int argc;
char *argv[];
{
   FILE *dot_h_file;
   FILE *dot_i_file;
   FILENAME h_filename;
   FILENAME i_filename;
   FILENAME filename;
   FILENAME outdir;
   CHAR sym_name[31];
   INT n, count;
   CHAR line[80];
   CHAR account[25];
   CHAR lower_module[10];
   CHAR *genptr,*login_string;
   CHAR **tcp;
   BOOL rebuild;

   static CHAR *heading[] = {
   "/*----------------------------------------------------------------------*/",
   "/* Header file generated by MG_CONFIG.				    */",
   "/*									    */",
   "/* This file must not be edited directly, instead modify the MESSAGES   */",
   "/* table in the ESI Oracle account and run MG_CONFIG to regenerate this */",
   "/* file.								    */",
   "/*----------------------------------------------------------------------*/",
   "",
   (CHAR *)0 };

   EXEC SQL BEGIN DECLARE SECTION;
	VARCHAR symbol[75];
	VARCHAR id[75];
	VARCHAR module[10];
	VARCHAR last_module[10];
	VARCHAR login_id[47];
	VARCHAR login_pass[47];
	VARCHAR stmt[1024];
   EXEC SQL END DECLARE SECTION;

/************ START CODE *************/

    if(argc < 2)
	{
	printf ("\n\
Usage:  mg_config account/pass [-a=message_account] [-rebuild] [outputdir]\n\
\n\
Mg_config will generate message and error include files\n\
for any modules updated since the last time it ran.\n\
\n\
The -rebuild option will cause it to generate ALL include\n\
files regardless of their update condition.\n\
\n\
If outputdir is specified all files will be created in that directory.\n\
\n");
	exit(1);
	}

    account[0] = NUL;
    outdir[0]  = NUL;
    rebuild    = FALSE;

/* loop through the args setting modes */
    for (n=2; argv[n] != NULL; n++)
	{
	if (argv[n][0] != '-') {
	    strcpy (outdir, argv[n]);
	    continue;
	}

	switch(argv[n][1])
	    {
	    case 'a':
	    case 'A':
		if (NOT(genptr = strchr(argv[n], '=')))
		    break;

		if (*++genptr)
		    {
		    strcpy(account, ts_sto_upper(genptr));
		    strcat(account, ".");
		    }
		break;

	    case 'r':
	    case 'R':
		rebuild = TRUE;
		break;

	    /* someone is confused */
	    default:
		break;
	    }
	}

    strcpy((char *)login_id.arr, argv[1]);
    V_SETLEN(login_id);
    login_pass.len = 0;

    printf ("Compiling ERR and MSG include files for ");
    if (rebuild) printf ("ALL ");
    else printf ("modified ");
    printf ("modules to ");
    if (outdir[0] == NUL) printf ("local directory.\n");
    else printf ("%s.\n", outdir);

    if (genptr != NULL) {
	printf ("Using message tables in the %s Oracle account.\n", genptr);
    }

    /*------------------------------------------------------------*/
    /* If no ']' it could be a logical name, if also no ':' it is */
    /* an unterminated logical name.  So terminate it.		  */
    /*------------------------------------------------------------*/
#ifdef vms
    if ((outdir[0] != NUL)                &&
	(outdir[strlen(outdir)-1] != ']') &&
	(outdir[strlen(outdir)-1] != ':')  )  strcat (outdir, ":");
#else
    if ((outdir[0] != NUL)                &&
	(outdir[strlen(outdir)-1] != '/') ) strcat (outdir, "/");
#endif

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL WHENEVER SQLWARNING CONTINUE;
    EXEC SQL CONNECT :login_id IDENTIFIED BY :login_pass;

    if ( OR_STATUS != 0 )
	{
	printf("Problem logging in to SQL account , please try again...\n");
	exit(1);
	}

   last_module.len = 0;
   last_module.arr[0] = 0;

    if (rebuild) {
	stmt.len = sprintf((char *)stmt.arr,
	"SELECT SYMBOL, ID, A.MODULE \
	 FROM   %sFINDER_MESSAGES A, %sFINDER_MODULES B \
	 WHERE  A.MODULE = B.MODULE AND \
		TYPE IN ('ERROR', 'STATUS') \
	 ORDER BY A.MODULE, ABS(ID)",
	account, account);
    }
    else {
	stmt.len = sprintf((char *)stmt.arr,
	"SELECT SYMBOL, ID, A.MODULE \
	 FROM   %sFINDER_MESSAGES A, %sFINDER_MODULES B \
	 WHERE  A.MODULE = B.MODULE AND \
		UPDATED = 'Y'	    AND \
		TYPE IN ('ERROR', 'STATUS') \
	ORDER BY A.MODULE, ABS(ID)",
	account, account);
    }

   EXEC SQL WHENEVER SQLERROR GOTO SQL_ERROR_ERR;
   EXEC SQL PREPARE S1 FROM :stmt;
   EXEC SQL DECLARE ERR_CURS CURSOR FOR S1;

   EXEC SQL WHENEVER NOT FOUND GOTO END_ERR;

   EXEC SQL OPEN ERR_CURS;

   FOREVER
	{
	EXEC SQL FETCH ERR_CURS INTO :symbol, :id, :module;

	V_SETZERO(symbol);
	V_SETZERO(module);
	V_SETZERO(id);

	if (ARE_DIFFERENT((char *)module.arr, (char *)last_module.arr))
		{
		if (last_module.len)
			{
			fprintf(dot_h_file,"\n#endif\n");
			printf("%d symbols written.\n", count);
			fclose(dot_i_file);
			fclose(dot_h_file);
			}

		strcpy (lower_module, (char *)module.arr);
		ts_sto_lower (lower_module);

		sprintf (filename,"%sesi_%s_err", outdir, lower_module);
		sprintf (h_filename,"%s.h",filename);
		sprintf (i_filename,"%s.i",filename);
		sprintf (sym_name,"ESI_%s_ERR_H", (char *)module.arr);

		printf ("%s -- Processing errors for module %s: ",
			progname, (char *)module.arr);

		dot_h_file = fopen(h_filename,"w");
		dot_i_file = fopen(i_filename,"w");
		last_module.len = module.len;
		strcpy ((char *)last_module.arr, (char *)module.arr);

		count = 0;
		for (tcp=heading; *tcp; tcp++)
			fprintf(dot_h_file,"%s\n", *tcp);
		fprintf(dot_h_file,"#ifndef %s\n",sym_name);
		fprintf(dot_h_file,"#define %s 1\n\n",sym_name);

		fprintf(dot_h_file,"#ifndef ESI_GL_DEFS_H\n");
		fprintf(dot_h_file,"#include \"esi_gl_defs.h\"\n");
		fprintf(dot_h_file,"#endif\n\n");
		}

	fprintf(dot_h_file, "#define %s_%s\t(INT)%s\n",
		    (char *)module.arr, (char *)symbol.arr, (char *)id.arr);

	fprintf(dot_i_file, "      INTEGER*4 %s_%s\n",
		    (char *)module.arr, (char *)symbol.arr);

	fprintf(dot_i_file, "      PARAMETER (%s_%s = %s)\n",
		    (char *)module.arr, (char *)symbol.arr, (char *)id.arr);

	if ((++count % 5) == 0)
	    {
	    fprintf (dot_h_file, "\n");
	    fprintf (dot_i_file, "C\n");
	    }
	}

SQL_ERROR_ERR:
	printf("%s -- SQL ERROR ENCOUNTERED",progname);
	printf("SQL ERR# %d.... %s\n",OR_STATUS,OR_MESSAGE);
END_ERR:
	if (last_module.len)
	   {
	   fprintf(dot_h_file,"\n#endif\n");
	   printf("%d symbols written.\n", count);
	   fclose (dot_h_file);
	   fclose (dot_i_file);
	   }

   last_module.len = 0;
   last_module.arr[0] = 0;

    if (rebuild) {
	stmt.len = sprintf((char *)stmt.arr,
	"SELECT SYMBOL, ID, A.MODULE \
	 FROM   %sFINDER_MESSAGES A, %sFINDER_MODULES B \
	 WHERE  A.MODULE = B.MODULE AND \
		TYPE IN ('MESSAGE') \
	 ORDER BY A.MODULE, ABS(ID)",
	account, account);
    }
    else {
	stmt.len = sprintf((char *)stmt.arr,
	"SELECT SYMBOL, ID, A.MODULE \
	 FROM   %sFINDER_MESSAGES A, %sFINDER_MODULES B \
	 WHERE  A.MODULE = B.MODULE AND \
		UPDATED = 'Y' AND \
		TYPE IN ('MESSAGE') \
	 ORDER BY A.MODULE, ABS(ID)",
	account, account);
    }

   EXEC SQL WHENEVER SQLERROR GOTO SQL_ERROR_MSG;
   EXEC SQL PREPARE S2 FROM :stmt;
   EXEC SQL DECLARE MSG_CURS CURSOR FOR S2;

   EXEC SQL WHENEVER NOT FOUND GOTO END_MSG;

   EXEC SQL OPEN MSG_CURS;

   FOREVER
	{
	EXEC SQL FETCH MSG_CURS INTO :symbol, :id, :module;

	V_SETZERO(symbol);
	V_SETZERO(module);
	V_SETZERO(id);

	if (ARE_DIFFERENT((char *)module.arr, (char *)last_module.arr))
		{
		if (last_module.len)
			{
			fprintf(dot_h_file,"\n#endif\n");
			printf("%d symbols written.\n", count);
			fclose(dot_h_file);
			fclose(dot_i_file);
			}

		strcpy (lower_module, (char *)module.arr);
		ts_sto_lower (lower_module);

		sprintf(filename,"%sesi_%s_msg", outdir, lower_module);
		sprintf(h_filename,"%s.h",filename);
		sprintf(i_filename,"%s.i",filename);
		sprintf(sym_name, "ESI_%s_MSG_H", (char *)module.arr);

		printf ("%s -- Processing messages for module %s: ",
			progname, (char *)module.arr);

		dot_h_file = fopen(h_filename,"w");
		dot_i_file = fopen(i_filename,"w");

		last_module.len = module.len;
		strcpy ((char *)last_module.arr, (char *)module.arr);

		count = 0;
		for (tcp=heading; *tcp; tcp++)
			fprintf(dot_h_file,"%s\n", *tcp);
		fprintf(dot_h_file,"#ifndef %s\n",sym_name);
		fprintf(dot_h_file,"#define %s 1\n\n",sym_name);

		fprintf(dot_h_file,"#ifndef ESI_GL_DEFS_H\n");
		fprintf(dot_h_file,"#include \"esi_gl_defs.h\"\n");
		fprintf(dot_h_file,"#endif\n\n");
		}

	fprintf(dot_h_file,"#define %s_%s\t(INT)%s\n",
		    (char *)module.arr, (char *)symbol.arr, (char *)id.arr);

	fprintf(dot_i_file,"      INTEGER*4 %s_%s\n",
		    (char *)module.arr, (char *)symbol.arr);

	fprintf(dot_i_file,"      PARAMETER (%s_%s = %s)\n",
		    (char *)module.arr, (char *)symbol.arr, (char *)id.arr);

	if ((++count % 5) == 0)
	    {
	    fprintf (dot_h_file, "\n");
	    fprintf (dot_i_file, "\n");
	    }
	}

SQL_ERROR_MSG:
	printf("%s -- SQL ERROR ENCOUNTERED",progname);
	printf("SQL ERR# %d.... %s\n",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
END_MSG:
	if (last_module.len)
	   {
	   fprintf(dot_h_file,"\n#endif\n");
	   printf("%d symbols written.\n", count);
	   fclose(dot_h_file);
	   fclose(dot_i_file);
	   }

   EXEC SQL WHENEVER NOT FOUND CONTINUE;
   EXEC SQL WHENEVER SQLERROR CONTINUE;

   stmt.len = sprintf((char *)stmt.arr,
   "UPDATE %sFINDER_MODULES \
    SET    UPDATED = 'N' \
	   WHERE UPDATED = 'Y'",
    account);

   EXEC SQL PREPARE S3 FROM :stmt;
   EXEC SQL EXECUTE IMMEDIATE :stmt;

   EXEC SQL CLOSE ERR_CURS;
   EXEC SQL COMMIT WORK RELEASE;

	printf("%s -- Complete.\n",progname);
	exit(1);
}
