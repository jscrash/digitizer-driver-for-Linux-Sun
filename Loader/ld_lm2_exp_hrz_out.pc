/* DEC/CMS REPLACEMENT HISTORY, Element LD_LM2_EXP_HRZ_OUT.PC */
/* *3    14-AUG-1991 11:58:35 KEE "(SPR -1) Put in File Lock/Unlock logic" */
/* *2     1-MAY-1991 21:58:02 KEE "(SPR -1) Landmark Export" */
/* *1     1-MAY-1991 21:04:01 KEE "Landmark Import & Export, Zycor Export and Mimic Export" */
/* DEC/CMS REPLACEMENT HISTORY, Element LD_LM2_EXP_HRZ_OUT.PC */
/******************************************************************************     */
/*                                                                                  */
/*                Copyright Finder Graphics Systems, Inc. 1989                      */
/*           Unpublished -- All rights reserved                                     */
/*                                                                                  */
/*THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Finder Graphics Systems, Inc.  AND   */
/*MAY CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE  */
/*DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE         */
/*MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF       */
/*                                                                                  */
/*            Finder Graphics Systems, Inc.                                         */
/*            201 Tamal Vista Blvd                                                  */
/*            Corte Madera, CA  USA 94925                                           */
/*            (415) 927-0100                                                        */
/*                                                                                  */
/*(The above notice does not constitute an admission of publication or              */
/*unrestricted dissemination of the work)                                           */
/*                                                                                  */
/******************************************************************************     */

/* ************************************************************************

   NAME: LD_LM2_EXP_HRZ_OUT.PC

   AUTHOR: Rod Hanks
   DATE:   June 15th, 1990
   DESCRIPTION: Unload seismic horizon information 
		from a particular map overlay in Finder.

   ************************************************************************ */

#ifndef ESI_ORACLE_H
#include "esi_oracle.h"
#endif
#ifndef ESI_NL_H
#include "esi_nl.h"
#endif
#ifndef ESI_CT_H
#include "esi_ct.h"
#endif
#ifndef ESI_SE_INT_H
#include "esi_se_int.h"
#endif
#ifndef ESI_SE_ERR_H
#include "esi_se_err.h"
#endif
#ifndef ESI_MG_H
#include "esi_mg.h"
#endif
#ifndef ESI_TS_H
#include "esi_ts.h"
#endif
#ifndef LD_LM2_EXP_WORK_H
#include "ld_lm2_exp_work.h"
#endif

#if USE_PROTOTYPES
publicdef  VOID ld_lm2_exp_hrz_out (CHAR *selectList, CHAR *selectPhrase,
		   CHAR *horizonName, CHAR *source,
		   BOOL *firstIteration, FILE **spfile, 
		   CHAR *mapName, PROJECT_NAME projectName, 
		   DOUBLE lowerLeftX, DOUBLE lowerLeftY, 
		   DOUBLE upperRightX, DOUBLE upperRightY,
		   FILENAME fileName1, BOOL convertProj, 
		   PROJECTION_STRUCTURE *defaultProj, 
		   PROJECTION_STRUCTURE *inputProj)
#else
publicdef VOID ld_lm2_exp_hrz_out (selectList, selectPhrase, horizonName, source,
		    firstIteration, spfile, mapName, projectName, 
		    lowerLeftX, lowerLeftY, upperRightX, upperRightY,
		    fileName1, convertProj, defaultProj, inputProj)
CHAR		*selectList;
CHAR		*selectPhrase;
CHAR		*horizonName;
CHAR		*source;
BOOL		*firstIteration;
FILE		**spfile;
CHAR		*mapName;
PROJECT_NAME	projectName;
DOUBLE		lowerLeftX;
DOUBLE		lowerLeftY;
DOUBLE		upperRightX;
DOUBLE		upperRightY;
FILENAME	fileName1;
BOOL	             convertProj;
PROJECTION_STRUCTURE *defaultProj;
PROJECTION_STRUCTURE *inputProj;
#endif
    {
/****************************************************************************

	V a r i a b l e   D e c l a r a t i o n s .

******************************************************************************/

    INT 	   status;
    CHAR	   myLineName[33];
    CHAR           prev_myLineName[33];
    CDP_FLOAT	   first_cdp;
    CDP_FLOAT	   last_cdp;
    FLOAT	   lower_time;
    FLOAT	   upper_time;
    CDP		   thisCdp;
    SP		   thisShot;
    SP             prev_thisShot;
    COORD	   thisX, thisY;
    COORD	   prev_thisX, prev_thisY;
    FLOAT	   thisZ;
    FLOAT	   prev_thisZ;
    BOOL           first_write = TRUE;
    CHAR	   outputFlag;
    NLIST_HEADER   lineList = (NLIST_HEADER) 0;
    NLIST_HEADER   outputNlist = (NLIST_HEADER) 0;
    INT		   lineCount;
    INT		   lineLoop;
    UINT           ndim;
    UINT           dim_list[1];
    VOIDPTR        value_list[1];
    UINT	   colList[3];
    VOIDPTR	   varOutList[2];
    INT            select_line_id;
    FULL_LINE_NAME line_name;
/*
				General variable declarations.
*/
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR sqlstmt[400];
	int	line_id;
	VARCHAR the_name[24];
	VARCHAR	the_survey[24];
	VARCHAR surfaceCode[31];
	VARCHAR sourceName[13];
	int	version;
    EXEC SQL END DECLARE SECTION;
/*
				Oracle variable declarations.
*/
/****************************************************************************

	I n i t i a l i z a t i o n .

******************************************************************************/

    if (*firstIteration)
	{
	*spfile = ho_open(fileName1, "w", NULL);
	status = ho_lock(*spfile, ON);
        if (*spfile == (FILE *)NULL || status != SUCCESS)
	    {
	    printf("Unable to open file -- %s\n", fileName1);
	    }
	else
	    {
	    printf("Processing seismic horizon for map %s\n", mapName);
	    printf("Line, shot, x, y, z, flag file is %s\n", fileName1);
	    *firstIteration = FALSE;
	    }
	}
/*****************************************************************************

	M a i n   L o g i c .

*****************************************************************************/

    if (*spfile != (FILE *)NULL)
	{
	lineCount = 0;
	ld_lm2_seis_list(selectPhrase, selectList, 
		            lowerLeftX, lowerLeftY, 
			    upperRightX, upperRightY,
			    &lineCount, &lineList);
/*
				Get a list of seismic lines which match our
				list and phrase criteria.
*/
	if (lineCount <= 0)
	    {
	    printf("Null seismic horizon information found for map %s\n", 
						mapName);
	    }
	else
	    {
	    select_line_id = 0;
	    ndim = 1;
	    dim_list[0] = 1;
	    value_list[0] = (VOIDPTR) &select_line_id;
            nl_first_row(lineList,ndim,dim_list,value_list);
/*
				Initialize to take a trip thru the NLIST
				of lines for this map.
*/
	    sqlstmt.len = sprintf((char *)sqlstmt.arr,
"SELECT LINE_NAME, SURVEY \
FROM %s.SEIS_LINE_HDR \
WHERE LINE_ID = :line_id", projectName);

	    EXEC SQL PREPARE S2 FROM :sqlstmt;
    	    EXEC SQL DECLARE XY_CUR CURSOR FOR S2;
/*
				Setup an SQL statement to return information
				we need to read the horizon and x/y's.
*/
	    sqlstmt.len = sprintf((char *)sqlstmt.arr,
"SELECT VENDOR_LINE_NAME \
FROM %s.SEIS_LINE_XREF \
WHERE FINDER_LINE_NAME = :line_name AND FINDER_SURVEY = :survey \
AND VENDOR = 'LANDMARK'", projectName);

	    EXEC SQL PREPARE S8 FROM :sqlstmt;
    	    EXEC SQL DECLARE LAND_CUR CURSOR FOR S8;
/*
				Setup an SQL statement to return the original
				line name from landmark.
*/
	    sqlstmt.len = sprintf((char *)sqlstmt.arr,
"SELECT VERSION FROM %s.SEIS_SURFACE \
WHERE SURFACE_CODE = :surfaceCode AND SURFACE_TYPE = 1 \
AND DATA_TYPE = 1 AND LINE_ID = :line_id AND SOURCE = :sourceName", 
projectName);

	    EXEC SQL PREPARE sa1 FROM :sqlstmt;
	    if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare sa1");
	    EXEC SQL DECLARE VERS1_CURS CURSOR FOR sa1;
/*
				Setup a cursor to get the version number.
*/    
	    for (lineLoop = 1; lineLoop <= lineCount; lineLoop++)
		{
		line_id = select_line_id;
                EXEC SQL OPEN XY_CUR USING :line_id;
                EXEC SQL FETCH XY_CUR INTO :the_name, :the_survey;
		EXEC SQL CLOSE XY_CUR;
/*
					Given line id, get the name and survey.
*/
	        strncpy(line_name.line_name, (CHAR *)the_name.arr, the_name.len);
	        line_name.line_name[the_name.len]=0;
	        strncpy(line_name.survey, (CHAR *)the_survey.arr, the_survey.len);
	        line_name.survey[the_survey.len]=0;
		line_name.id = (long) line_id;
/*
					Setup the FULL_LINE_NAME structure.
*/
		EXEC SQL OPEN LAND_CUR using :the_name, :the_survey;
		if (OR_STATUS != SUCCESS) ld_show_error(OR_STATUS, 
								"OPEN LAND");
		EXEC SQL FETCH LAND_CUR INTO :the_name;
		if (OR_STATUS < SUCCESS) ld_show_error(OR_STATUS, 
								"FETCH LAND");
		EXEC SQL CLOSE LAND_CUR;
		if (OR_STATUS != SUCCESS) ld_show_error(OR_STATUS, 
								"CLOSE LAND");
/*
					If it has been changed, use the xref
					to get back to the original line name
					used in landmark.
*/
		V_V_TO_C(myLineName, the_name);
		while (strlen(myLineName) < 31)
		    {
		    strcat(myLineName, " ");
		    }
		myLineName[31-1] = ' ';
		myLineName[31] = 0;
		version = 0;
		V_FROMC(surfaceCode, horizonName);
		V_FROMC(sourceName, source);
		EXEC SQL OPEN VERS1_CURS USING :surfaceCode,
						:line_id, :sourceName;
		if (OR_STATUS != 0) ld_show_error(OR_STATUS, 
							"OPEN VERS1_CURS");
		EXEC SQL FETCH VERS1_CURS INTO :version;
		status = OR_STATUS;
		if (OR_STATUS < 0) ld_show_error(OR_STATUS, 
							"FETCH VERS1_CURS");
		EXEC SQL CLOSE VERS1_CURS;
		if (OR_STATUS != 0) ld_show_error(OR_STATUS,
							"CLOSE VERS1_CURS");
/*
				Get the version number to use with this source.
				There is a problem in the data model.  It needs
				to have a unique version number for each
				unique source, although it does not enforce
				this.
*/
		status = se_get(&outputNlist, horizonName, SE_HORIZ,
					SE_TIME, &line_name, source, 
					SE_AT_NM, SE_FINDER, &version,
					&upper_time, &lower_time, 
					&first_cdp, &last_cdp);
		if (status != SUCCESS)
		    {
		    if (status != SE_NO_DATA)
			{
			printf("SE_GET: %s\n", mg_message(status));
			}
		    }
		else
		    {
		    printf("Line: %s\n", myLineName);
		    colList[0] = 1;
		    colList[1] = 2;
		    varOutList[0] = (VOIDPTR) &thisCdp;
		    varOutList[1] = (VOIDPTR) &thisZ;
		    status = nl_first_row(outputNlist, 2, colList,
							varOutList);
		    while (status >= SUCCESS 
		      && ((status & NL_EOL) != NL_EOL))
		        {
	   	        outputFlag = ' ';
		        if (((status & NL_START_OF_TABLE) 
						== NL_START_OF_TABLE)
			&&  ((status & NL_START_OF_LIST)
						!= NL_START_OF_LIST))
			    {
	                    outputFlag = 'F';
			    }
/*
				Set a flag if we are at the beginning of a
				table.  This marks a fault.
*/
			status = se_sp_from_cdp(&line_name, thisCdp,
							&thisShot);
			status = se_xy_from_cdp(&line_name, thisCdp,
					-1.0, &thisX, &thisY);
		        if (convertProj)
			    {
		            ct_transform_point(thisX, thisY, defaultProj,
					  &thisX, &thisY, inputProj);
			    }
	                if (first_write == TRUE)
	                  {
	                    first_write = FALSE;
	                  }
	                else
	                  {
			    fprintf(*spfile, 
				    "%s %8.2lf %11.2lf %11.2lf %11.4f   %c\n", 
				    prev_myLineName, prev_thisShot,
				    prev_thisX, prev_thisY, prev_thisZ, 
	                            outputFlag);
			  }
			if (IS_EMPTY_STRING(myLineName) == FALSE)
                          {
			    strcpy(prev_myLineName, myLineName);
                          }
	                prev_thisShot = thisShot;
	                prev_thisX = thisX;
	                prev_thisY = thisY;
	                prev_thisZ = thisZ;
			status = nl_next_row(outputNlist, 2,
						colList, varOutList);
			}
		    nl_free_nlist(outputNlist);
		    }
		ndim = 1;
		dim_list[0] = 1;
		value_list[0] = (VOIDPTR) &select_line_id;
                nl_next_row(lineList,ndim,dim_list,value_list);
		}
	    nl_free_nlist(lineList);
            fprintf(*spfile, 
	           "%s %8.2lf %11.2lf %11.2lf %11.4f   %c\n", 
		   prev_myLineName, prev_thisShot,
		   prev_thisX, prev_thisY, prev_thisZ, 
	           outputFlag);
	    }
        if (lineList IS_NOT_EQUAL_TO (NLIST_HEADER)0)
	    {
	    nl_free_nlist(lineList);
	    }
	}
/*****************************************************************************

	C l e a n   U p   A n d   E x i t .

******************************************************************************/
    return;
    }
