C DEC/CMS REPLACEMENT HISTORY, Element LD_UKOTOOL.FOR
C *4    19-SEP-1989 10:11:47 GORDON "(PURNA) GULF MODS UNDER SPR 100"
C *3    10-AUG-1989 18:57:07 VINCE "(SPR -1) Fortran code after UNIX mods"
C *2    10-AUG-1989 11:42:30 ADEY "(SPR -1) INITIAL CHECKIN KPA"
C *1    10-AUG-1989 11:39:59 ADEY "UKOOA TOOLBOX FUNCTIONS"
C DEC/CMS REPLACEMENT HISTORY, Element LD_UKOTOOL.FOR
C
      SUBROUTINE FFASC (BUF, LEN, POS, OUT, MAX)
C
C PURPOSE:
C
C    SEARCHES ASCII STINGS IN A FREE FORMAT ASCII BUFFER.
C
C PARAMETERS:
C
C    BUF       ASCII     FREE FORMAT ASCII INPUT BUFFER
C    LEN       I*4       LENGTH OF THE INPUT BUFFER, IN BYTES
C    POS       I*4       POSITION OF THE FIRST BYTE TO BEGIN SEARCH
C                        (RANGE = 1 TO LEN)
C    OUT       ASCII     ASCII OUTPUT BUFFER FOR STRING
C    MAX       I*4       LENGTH OF THE STRING, IN BYTES
C
C AUTHOR:
C
C    GEORGE S. DOBEK, 10/9/86
C
C NOTES:
C
C    THE OUTPUT STRING BEGINS WITH THE FIRST NON-DELIMITER CHARACTER
C    ENCOUNTERED AND ENDS WHEN ONE OF THE FOLLOWING OCCURS:
C
C    1) A DELIMITER CHARACTER IS ENCOUNTERED,
C    2) THE END OF THE INPUT BUFFER IS REACHED,
C    3) THE MAXIMUM NUMBER OF CHARACTERS HAVE BEEN FOUND.
C
C    DELIMITER CHARACTERS INCLUDE BLANKS, COMMAS, NULL AND TAB CHARACTERS.
C
C    THE POSITION OF THE CHARACTER IMMEDIATELY FOLLOWING THE STRING IS
C    RETURNED IN POS. IF NO STRING IS FOUND OR THE END OF THE INPUT
C    BUFFER IS REACHED, POS = LEN + 1. THE OUTPUT BUFFER IS BLANK FILLED
C    TO THE MAXIMUM NUMBER OF CHARACTERS IF THE STRING LENGTH IS LESS
C    THAN THE MAXIMUM.
C
C
      CHARACTER     BLANK, COMMA, NULL, TAB
      INTEGER*4     LEN, POS, MAX
      CHARACTER     BUF*(*), OUT*(*)
C
C ... INITIALIZE VARIABLES
      BLANK = ' '
      COMMA = ','
      NULL = CHAR(128)
      TAB = CHAR(137)
      I = POS
      IF (I .LT. 1) I = 1
      J = 1
C
C ... ELIMINATE LEADING DELIMITERS
   10 IF (I .GT. LEN) GO TO 40
      IF ((BUF(I:I) .NE. BLANK) .AND.
     +    (BUF(I:I) .NE. COMMA) .AND.
     +    (BUF(I:I) .NE. NULL ) .AND.
     +    (BUF(I:I) .NE. TAB  )) GO TO 20
      I = I + 1
      GO TO 10
C
C ... SCAN STRING
   20 CONTINUE
      OUT(J:J) = BUF(I:I)
      I = I + 1
      J = J + 1
      IF ((I .GT. LEN) .OR.
     +    (J .GT. MAX)) GO TO 30
      IF ((BUF(I:I) .NE. BLANK) .AND.
     +    (BUF(I:I) .NE. COMMA) .AND.
     +    (BUF(I:I) .NE. NULL ) .AND.
     +    (BUF(I:I) .NE. TAB  )) GO TO 20
C
C ... SUCCESS
   30 CONTINUE
      POS = I
      LIMIT = MAX
      IF (MAX .GT. LEN) LIMIT = LEN
      DO 35 I = J, LIMIT
          OUT(I:I) = BLANK
   35 CONTINUE
      RETURN
C
C ... PREMATURE END OF BUF
   40 CONTINUE
      POS = LEN + 1
      RETURN
      END
C
C
      SUBROUTINE FFINT (BUF, LEN, POS, INT)
C
C PURPOSE:
C
C    FINDS INTEGER*4 NUMBERS IN A FREE FORMAT ASCII BUFFER.
C
C PARAMETERS:
C
C    BUF       ASCII     FREE FORMAT ASCII INPUT BUFFER
C    LEN       I*4       LENGTH OF THE INPUT BUFFER, IN BYTES
C    POS       I*4       POSITION OF THE FIRST BYTE TO BEGIN SEARCH
C                        (RANGE = 1 TO LEN)
C    INT       I*4       OUTPUT INTEGER*4 NUMBER
C
C AUTHOR:
C
C    GEORGE S. DOBEK, 10/9/86
C
C NOTES:
C
C    THE OUTPUT STRING BEGINS WITH THE FIRST DIGIT ENCOUNTERED AND ENDS
C    WHEN ONE OF THE FOLLOWING OCCURS:
C
C    1) A DELIMITER CHARACTER IS ENCOUNTERED,
C    2) THE END OF THE INPUT BUFFER IS REACHED,
C    3) THE ACCUMULATED NUMBER EXCEEDS 214,748,363.
C
C    DELIMITER CHARACTERS INCLUDE ANY NON-DIGIT CHARACTERS.
C
C    THE POSITION OF THE CHARACTER IMMEDIATELY FOLLOWING THE STRING IS
C    RETURNED IN POS. IF NO DIGIT IS FOUND OR THE END OF THE INPUT
C    BUFFER IS REACHED, POS = LEN + 1. THE VALUE RETURNED WILL BE ZERO
C    IN THIS CASE. THE SIGN OF THE INTEGER IS ADJUSTED IF A NEGATIVE SIGN
C    IMMEDIATELY PRECEDES THE FIRST DIGIT USED.
C
C    THE MAXIMUM AND MINIMUM NUMBERS RETURNED ARE +2,147,483,647 AND
C    -2,147,483,648 RESPECTIVELY.
C
C
      INTEGER*4     MAXINT, MININT
      INTEGER*4     LEN, POS
      CHARACTER     BUF*(*)
C
C ... INITIALIZE VARIABLES
      MAXINT =  2147483647
      MININT = -2147483648
      MULT = 1
      I = POS
      IF (I .LT. 1) I = 1
      INT = 0
C
C ... ELIMINATE LEADING DELIMITERS
   10 IF (I .GT. LEN) GO TO 40
      IF ((BUF(I:I) .GE. '0') .AND.
     +    (BUF(I:I) .LE. '9')) GO TO 20
      I = I + 1
      GO TO 10
C
C ... SCAN INTEGER STRING
   20 CONTINUE
      IF (BUF(I-1:I-1) .EQ. '-') MULT = -1
   21 CONTINUE
      INT = INT*10 + ICHAR(BUF(I:I)) - ICHAR('0')
      I = I + 1
      IF ((I .GT. LEN) .OR.
     +    ((MULT*INT) .LT. MININT) .OR.
     +    ((MULT*INT) .GT. MAXINT)) GO TO 30
      IF ((BUF(I:I) .GE. '0') .AND.
     +    (BUF(I:I) .LE. '9')) GO TO 21
C
C ... SUCCESS
   30 CONTINUE
      INT = MULT * INT
      POS = I
      RETURN
C
C ... PREMATURE END OF BUF
   40 CONTINUE
      POS = LEN + 1
      INT = 0
      RETURN
      END
C
C
      SUBROUTINE FFREAL (BUF, LEN, POS, RNUM)
C
C PURPOSE:
C
C    FINDS REAL*4 NUMBERS IN A FREE FORMAT ASCII BUFFER.
C
C PARAMETERS:
C
C    BUF       ASCII     FREE FORMAT ASCII INPUT BUFFER
C    LEN       I*4       LENGTH OF THE INPUT BUFFER, IN BYTES
C    POS       I*4       POSITION OF THE FIRST BYTE TO BEGIN SEARCH
C                        (RANGE = 1 TO LEN)
C    REAL      R*4       OUTPUT REAL*4 NUMBER
C
C AUTHOR:
C
C    GEORGE S. DOBEK, 10/9/86
C
C NOTES:
C
C    THE REAL*4 NUMBER MAY BE IN ANY FORMAT RECOGNIZABLE TO A FORTRAN
C    COMPILER. THE POSITION OF THE CHARACTER IMMEDIATELY FOLLOWING THE
C    LAST CHARACTER USED IS RETURNED IS POS. IF NO DIGIT IS FOUND OR THE
C    END OF THE BUFFER IS REACHED, POS = LEN + 1. THE VALUE RETURNED IN
C    RNUM WOULD BE 0.0 IN THIS CASE. EXPONENTIAL FORMATS ARE ALLOWED IN
C    THIS ROUTINE USING THE CHARACTER E ONLY. FOR DOUBLE PRECISION NUMBERS,
C    FFDBLE SHOULD BE USED AS THIS ALLOWS BOTH E AND D EXPONENTIAL FORMATS.
C
C    ALTHOUGH ANY NUMBER OF DIGITS CAN BE USED TO DEFINE THE REAL*4 NUMBER,
C    IT SHOULD BE NOTED THAT ONLY THE FIRST 6 WILL BE ACCURATE IN THE FINAL
C    RESULT. FOR MORE PRECISION, USE THE FFDBLE ROUTINE.
C
C
      INTEGER*4     LEN, POS, FIRST
      CHARACTER     BUF*(*)
      CHARACTER*20  FORM
      CHARACTER*512 TEMP
      LOGICAL       EXP
C
C ... INITIALIZE VARIABLES
      RNUM = 0.
      FIRST = 0
      EXP = .FALSE.
      I = POS
      IF (I .LT. 1) I = 1
      IF (I .GT. LEN) GO TO 50
C
C ... ELIMINATE LEADING DELIMITERS
   10 IF (I .GT. LEN) GO TO 20
      IF (((BUF(I:I) .GE. '0') .AND.
     +     (BUF(I:I) .LE. '9')) .OR.
     +     (BUF(I:I) .EQ. '+')  .OR.
     +     (BUF(I:I) .EQ. '-')  .OR.
     +     (BUF(I:I) .EQ. '.')) GO TO 20
      I = I + 1
      GO TO 10
C
C ... SCAN FOR MANTISSA
   20 CONTINUE
      FIRST = I
      IF ((BUF(I:I) .EQ. '+') .OR.
     +    (BUF(I:I) .EQ. '-')) I = I + 1
      IF (BUF(I:I) .NE. '.') THEN
   21     CONTINUE
          I = I + 1
          IF (I .GT. LEN) GO TO 22
          IF ((BUF(I:I) .GE. '0') .AND.
     +        (BUF(I:I) .LE. '9')) GO TO 21
      ENDIF
   22 CONTINUE
C
      IF (BUF(I:I) .EQ. '.') THEN
   23     CONTINUE
          I = I + 1
          IF (I .GT. LEN) GO TO 24
          IF ((BUF(I:I) .GE. '0') .AND.
     +        (BUF(I:I) .LE. '9')) GO TO 23
      ENDIF
   24 CONTINUE
C
      IF ((BUF(I:I) .EQ. 'E') .OR.
     +    (BUF(I:I) .EQ. 'e')) THEN
          EXP = .TRUE.
          I = I + 1
          IF ((BUF(I:I) .EQ. '+') .OR.
     +        (BUF(I:I) .EQ. '-')) I = I + 1
          IF ((BUF(I:I) .LT. '0') .OR.
     +        (BUF(I:I) .GT. '9')) GO TO 50
   30     CONTINUE
          I = I + 1
          IF (I .GT. LEN) GO TO 40
          IF ((BUF(I:I) .GE. '0') .AND.
     +        (BUF(I:I) .LE. '9')) GO TO 30
      ENDIF
C
C ... SUCCESS
   40 CONTINUE
      LENGTH = I - FIRST
      TEMP(1:LENGTH) = BUF(FIRST:I-1)
      IF (EXP) THEN
          WRITE (UNIT=FORM, FMT='(A,I2,A)') '(E', LENGTH, '.0)'
      ELSE
          WRITE (UNIT=FORM, FMT='(A,I2,A)') '(F', LENGTH, '.0)'
      ENDIF
      READ (UNIT=TEMP, FMT=FORM) RNUM
      POS = I
      RETURN
C
C ... PREMATURE END OF BUF
   50 CONTINUE
      POS = LEN + 1
      RNUM = 0.0
      RETURN
      END
C
C
      SUBROUTINE FFTITL (BUF, LEN, POS, OUT, MAX)
C
C PURPOSE:
C
C    FINDS ASCII TITLES IN A FREE FORMAT ASCII BUFFER.
C
C PARAMETERS:
C
C    BUF       ASCII     FREE FORMAT ASCII INPUT BUFFER
C    LEN       I*4       LENGTH OF THE INPUT BUFFER, IN BYTES
C    POS       I*4       POSITION OF THE FIRST BYTE TO BEGIN SEARCH
C                        (RANGE = 1 TO LEN)
C    OUT       ASCII     ASCII OUTPUT BUFFER FOR STRING
C    MAX       I*4       LENGTH OF THE STRING, IN BYTES
C
C NOTES:
C    THE OUTPUT STRING BEGINS WITH THE FIRST NON-DELIMITER CHARACTER
C    ENCOUNTERED AND ENDS WHEN ONE OF THE FOLLOWING OCCURS:
C
C    1) A DELIMITER CHARACTER IS ENCOUNTERED,
C    2) THE END OF THE INPUT BUFFER IS REACHED,
C    3) THE MAXIMUM NUMBER OF CHARACTERS HAVE BEEN FOUND.
C
C    DELIMITER CHARACTERS INCLUDE COMMAS, NULLS AND TABS.
C
C    THE POSITION OF THE CHARACTER IMMEDIATELY FOLLOWING THE STRING IS
C    RETURNED IN POS. IF NO STRING IS FOUND OR THE END OF THE INPUT
C    BUFFER IS REACHED, POS = LEN + 1. THE OUTPUT BUFFER IS BLANK FILLED
C    TO THE MAXIMUM NUMBER OF CHARACTERS IF THE STRING LENGTH IS LESS
C    THAN THE MAXIMUM.
C
C    THE FREE-FORM TITLE STRINGS FOUND BY THIS ROUTINE MAY CONTAIN IMBEDDED
C    BLANKS, BUT NOT COMMAS, NULLS OR TABS.
C
C
      CHARACTER     BLANK, COMMA, NULL, TAB
      INTEGER*4     LEN, POS, MAX
      CHARACTER     BUF*(*), OUT*(*)
C
C ... INITIALIZE VARIABLES
      BLANK = ' '
      COMMA = ','
      NULL = CHAR(128)
      TAB = CHAR(137)
      I = POS
      IF (I .LT. 1) I = 1
      J = 1
C
C ... ELIMINATE LEADING DELIMITERS
   10 IF (I .GT. LEN) GO TO 40
      IF ((BUF(I:I) .NE. COMMA) .AND.
     +    (BUF(I:I) .NE. NULL ) .AND.
     +    (BUF(I:I) .NE. TAB  )) GO TO 20
      I = I + 1
      GO TO 10
C
C ... SCAN STRING
   20 CONTINUE
      OUT(J:J) = BUF(I:I)
      I = I + 1
      J = J + 1
      IF ((I .GT. LEN) .OR.
     +    (J .GT. MAX)) GO TO 30
      IF ((BUF(I:I) .NE. COMMA) .AND.
     +    (BUF(I:I) .NE. NULL ) .AND.
     +    (BUF(I:I) .NE. TAB  )) GO TO 20
C
C ... SUCCESS
   30 CONTINUE
      POS = I
      LIMIT = MAX
      IF (MAX .GT. LEN) LIMIT = LEN
      DO 35 I = J, LIMIT
          OUT(I:I) = BLANK
   35 CONTINUE
      RETURN
C
C ... PREMATURE END OF BUF
   40 CONTINUE
      POS = LEN + 1
      RETURN
      END
C END-CODE
