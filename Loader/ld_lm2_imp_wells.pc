/* DEC/CMS REPLACEMENT HISTORY, Element LD_LM2_IMP_WELLS.PC */
/* *2     1-MAY-1991 21:54:12 KEE "(SPR -1) Landmark Import" */
/* *1     1-MAY-1991 21:25:23 KEE "Landmark Import & Export, Zycor Export and Mimic Export" */
/* DEC/CMS REPLACEMENT HISTORY, Element LD_LM2_IMP_WELLS.PC */
/******************************************************************************     */
/*                                                                                  */
/*                Copyright Finder Graphics Systems, Inc. 1989                      */
/*           Unpublished -- All rights reserved                                     */
/*                                                                                  */
/*THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Finder Graphics Systems, Inc.  AND   */
/*MAY CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE  */
/*DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE         */
/*MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF       */
/*                                                                                  */
/*            Finder Graphics Systems, Inc.                                         */
/*            201 Tamal Vista Blvd                                                  */
/*            Corte Madera, CA  USA 94925                                           */
/*            (415) 927-0100                                                        */
/*                                                                                  */
/*(The above notice does not constitute an admission of publication or              */
/*unrestricted dissemination of the work)                                           */
/*                                                                                  */
/******************************************************************************     */

/* ************************************************************************

   NAME: LD_LM2_IMP_WELLS.PC

   AUTHOR: Rod Hanks
   DATE:   May 7th, 1990
   DESCRIPTION: Load well locations into finder
		from a file output by Landmark.

   ************************************************************************ */

#ifndef ESI_ORACLE_H
#include "esi_oracle.h"
#endif
#ifndef ESI_CT_H
#include "esi_ct.h"
#endif
#ifndef ESI_HO_FILES_H
#include "esi_ho_files.h"
#endif
#ifndef LD_LM2_IMP_WORK_H
#include "ld_lm2_imp_work.h"
#endif
#ifndef ESI_TS_H
#include "esi_ts.h"
#endif

#if USE_PROTOTYPES
publicdef VOID ld_lm2_imp_wells (FILENAME fileName, PROJECT_NAME project,
			BOOL convertProj, PROJECTION_STRUCTURE *defaultProj, 
                        PROJECTION_STRUCTURE *inputProj, CHAR *source, 
			INT overwrite, DOUBLE ll_x, DOUBLE ll_y, DOUBLE ur_x, 
			DOUBLE ur_y)
#else
publicdef VOID ld_lm2_imp_wells (fileName, project,
			convertProj, defaultProj, inputProj,
			source, overwrite, ll_x,
			ll_y, ur_x, ur_y)
FILENAME	fileName;
PROJECT_NAME	project;
BOOL	              convertProj;
PROJECTION_STRUCTURE *defaultProj;
PROJECTION_STRUCTURE *inputProj;
CHAR		     *source;
INT		      overwrite;
DOUBLE		      ll_x;
DOUBLE		      ll_y;
DOUBLE		      ur_x;
DOUBLE		      ur_y;
#endif
    {
/****************************************************************************

	V a r i a b l e   D e c l a r a t i o n s .

******************************************************************************/

    FILE	  *spfile;
    CHAR	  *inputUWI= (CHAR *) 0;
    CHAR	  *inputName;
    CHAR	  *inputStatus;
    BOOL	  skipLoad;

#ifdef USE_OLDPARSING
    CHAR	  *inputX;
    CHAR	  *inputY;
    CHAR	  *pos;
    CHAR	  dummy[255];
#else
    LD_SCANNER_STRUCT ld_scan;	
#endif
/*
				General variable declarations.
*/
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR sqlstmt[400];
	int	nodeID;
	VARCHAR wellName[21];
	VARCHAR uwi[21];
	double	nodeX;
	double	nodeY;
	int	plotSymbol;
	VARCHAR sourceName[13];
    EXEC SQL END DECLARE SECTION;
/*
				Oracle variable declarations.
*/
/****************************************************************************

	I n i t i a l i z a t i o n .

******************************************************************************/

    sqlstmt.len = sprintf((char *)sqlstmt.arr,
"SELECT NODE_ID, PRIMARY_SOURCE \
FROM %s.WELL_HDR \
WHERE UWI = :uwi", project);

    EXEC SQL PREPARE S1 FROM :sqlstmt;
    if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare s1");
    EXEC SQL DECLARE LOOK_CURS CURSOR FOR S1;
    
    sqlstmt.len = sprintf((char *)sqlstmt.arr,
"INSERT INTO %s.WELL_HDR (UWI, WELL_NAME, PRIMARY_SOURCE, NODE_ID, \
PLOT_SYMBOL) VALUES (:uwi, :wellName, '%s', :nodeID, \
:plotSymbol)", project, source);

    EXEC SQL PREPARE S2 FROM :sqlstmt;
    if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare s2");

    sqlstmt.len = sprintf((char *)sqlstmt.arr,
"INSERT INTO %s.NODES (NODE_ID, NODE_X, NODE_Y, LOC_QUAL) \
VALUES (:nodeID, :nodeX, :nodeY, 'A')", project);

    EXEC SQL PREPARE S3 FROM :sqlstmt;
    if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare s3");

    sqlstmt.len = sprintf((char *)sqlstmt.arr,
"UPDATE %s.NODES SET NODE_X = :nodeX, \
NODE_Y = :nodeY \
WHERE NODE_ID = :nodeID", project);

    EXEC SQL PREPARE S4 FROM :sqlstmt;
    if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare s4");

    sqlstmt.len = sprintf((char *)sqlstmt.arr,
"SELECT FINDER_UWI FROM %s.WELL_NAME_UWI_XREF \
WHERE VENDOR_WELL_NAME = :wellName AND VENDOR = 'LANDMARK'", project);

    EXEC SQL PREPARE S8 FROM :sqlstmt;
    if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare s8");
    EXEC SQL DECLARE UWI_CURS CURSOR FOR S8;

    spfile = ho_open(fileName, "r", NULL);
    if (spfile == (FILE *)NULL)
	{
	printf("Unable to open well file named \n%s\n", fileName);
	}
    else
	{
        printf("loading wells from %s\n", fileName);
/*****************************************************************************

	M a i n   L o g i c .

*****************************************************************************/
#ifdef USE_OLDPARSING
	fgets(dummy, 255, spfile);
/*
				Skip the line, it contains column headers.
*/

        while ((pos = fgets(dummy, 255, spfile)) != (CHAR *) 0)
            {
	    if (strlen(dummy) > 38) /* Rod Hank */
		{
/*
				Sometimes TCIP (or somebody) puts extraneous
				linesfeeds at the end of the data we get from
				Landmark and this keeps us from treating it
				as a well line.
*/
	        if (*pos != ' ')  /* get UWI */
	          {
	            inputUWI = pos;
	            while (*pos != ' ' && *pos != 0)
		      {
		        pos++;
		      }
 		    if (*pos != 0)
		      {
	                *pos = 0;
	                pos++;
		      }
                  }
	        while (*pos == ' ')
		    {
		    pos++;
		    }
	        inputName = pos;
	        pos += (48-17+1);
		/* well name multiple strings handling for UNOCAL */
	        *pos = 0;
                inputName = ts_snowhite(inputName);
                pos++;
	        while (*pos == ' ')
		    {
		    pos++;
		    }
	        inputStatus = pos;
	        while (*pos != ' ' && *pos != 0)
		    {
		    pos++;
		    }
		if (*pos != 0)
		    {
	            *pos = 0;
	            pos++;
		    }
	        while (*pos == ' ')
		    {
		    pos++;
		    }
	        inputX = pos;
	        while (*pos != ' ' && *pos != 0)
		    {
		    pos++;
		    }
		if (*pos != 0)
		    {
	            *pos = 0;
	            pos++;
		    }
	        while (*pos == ' ')
		    {
		    pos++;
		    }
	        inputY = pos;
	        while (*pos != ' ' && *pos != 0)
		    {
		    pos++;
		    }
		*pos = 0;
		if (strlen(inputName) == 0
		||  strlen(inputStatus) == 0
		||  strlen(inputX) == 0
		||  strlen(inputY) == 0)
		    {
	            if (inputUWI != (CHAR *) 0)
		      {
		        printf("Incorrectly formatted line, not loaded... \
\n%s %s %s %s %s\n", inputUWI, inputName, inputStatus, inputX, inputY);
		      }
	            else
		      {
		        printf("Incorrectly formatted line, not loaded... \
\n %s %s %s %s\n", inputName, inputStatus, inputX, inputY);
		      }
		    }
		else
		    {
		    skipLoad = FALSE;
#else
        tc_zeroes(&ld_scan, sizeof(LD_SCANNER_STRUCT));	
        ld_scan.in.fix_format = TRUE;
	ld_scan.in.snowhite = TRUE;
        ld_scan.in.num_pair = 5;
        ld_scan.in.start[0] = 1;     ld_scan.in.end[0] = 15;
        ld_scan.in.start[1] = 17;    ld_scan.in.end[1] = 48;
        ld_scan.in.start[2] = 50;    ld_scan.in.end[2] = 55;
        ld_scan.in.start[3] = 57;    ld_scan.in.end[3] = 66;
        ld_scan.in.start[4] = 68;    ld_scan.in.end[4] = 80;
	ld_scan_line(spfile, &ld_scan); /* skip header */

	while (ld_scan.eof == FALSE)
	  {
	    ld_scan_line(spfile, &ld_scan);
	    /* check all items are there or empty line  */
	    if (ld_scan.out_nitems == 0)
	      {
		continue;
              }
	    else if (ld_scan.out_nitems != ld_scan.in.num_pair OR
		     ld_scan.out[1].parmtype != LD_STRING OR
		     ld_scan.out[2].parmtype != LD_STRING OR
		     ld_scan.out[3].parmtype != LD_INT OR
		     ld_scan.out[4].parmtype != LD_INT)
	      {
		printf("Invalid line format - following line will be skipped\n ");
		printf("%s",ld_scan.line);
		continue;
              }
	    else 
	      {
	        skipLoad = ld_scan.eof;
	        inputName = ld_scan.out[1].parmval.cval;
	        inputStatus = ld_scan.out[2].parmval.cval;
	        nodeX = (DOUBLE) ld_scan.out[3].parmval.ival;
	        nodeY = (DOUBLE) ld_scan.out[4].parmval.ival;
#endif
			    V_FROMC(wellName, inputName);
		            EXEC SQL OPEN UWI_CURS using :wellName;
		            if (OR_STATUS != 0) ld_show_error(OR_STATUS,
							"open UWI curs");
		            EXEC SQL FETCH UWI_CURS INTO :uwi;
		            if (OR_STATUS < 0) 
				{
				ld_show_error(OR_STATUS, "fetch UWI curs");
				}
			    else if (OR_STATUS > 0)
				{
				printf("No UWI translation available for %s. \
Well not loaded.\n", inputName);
				skipLoad = TRUE;
				}
			    else
				{
				uwi.arr[uwi.len] = 0;
				inputUWI = (CHAR *)uwi.arr;
				}
		            EXEC SQL CLOSE UWI_CURS;
		            if (OR_STATUS != 0) ld_show_error(OR_STATUS,
							"close UWI curs");
		    if (skipLoad == FALSE)
			{
		        nodeID = 0;
		        V_FROMC(wellName, inputName);
		        V_FROMC(uwi, inputUWI);
#ifdef USE_OLDPARSING
	                sscanf(inputX, "%lf", &nodeX);
	                sscanf(inputY, "%lf", &nodeY);
#endif
		        if (convertProj)
			    {
		            ct_transform_point(nodeX, nodeY, inputProj,
					  &nodeX, &nodeY, defaultProj);
			    }
/*
				Above, parse out the input line into well
				name, survey, x, and y.
*/	
		        if (nodeX >= ll_x && nodeX <= ur_x
		        &&  nodeY >= ll_y && nodeY <= ur_y)
			    {

		            if (strcmp(inputStatus, "GAS") == 0)
		                {
		                plotSymbol = 20;
		                }
		            else if (strcmp(inputStatus, "OIL") == 0)
		                {
		                plotSymbol = 19;
		                }
		            else if (strcmp(inputStatus, "DRY") == 0)
		                {
		                plotSymbol = 1;
		                }
		            else if (strcmp(inputStatus, "WELL") == 0)
		                {
		                plotSymbol = 21;
		                }
		            else
		                {
		                printf("%s - Unexpected input status %s\n", 
			    		inputUWI, inputStatus);
		                plotSymbol = 27;
		                }
		            EXEC SQL OPEN LOOK_CURS USING :uwi;
    		            if (OR_STATUS != 0) 
			        {
			        ld_show_error(OR_STATUS, "open look_curs");
			        }
		            EXEC SQL FETCH LOOK_CURS INTO :nodeID, :sourceName; 
    		            if (OR_STATUS < 0) 
			        {
			        ld_show_error(OR_STATUS, "fetch look_curs");
			        }
		            EXEC SQL CLOSE LOOK_CURS;
 		            if (OR_STATUS != 0) 
			        {
			        ld_show_error(OR_STATUS, "close look_curs");
			        }
/*
				First step, find out if this well already
				exists.
*/
		            if (nodeID == 0)
		                {
		                EXEC SQL SELECT ESI.LYNX_ID_SEQ.NEXTVAL 
			    	INTO :nodeID FROM DUAL;
    		                if (OR_STATUS != 0) 
			            {
			            ld_show_error(OR_STATUS, "Node ID nextval");
			            }
/*
				Get the next node id number.
*/
			        V_FROMC(sourceName, source);
		                EXEC SQL EXECUTE S2 USING :uwi, :wellName, 
					:nodeID,
					:plotSymbol;
    		                if (OR_STATUS != 0) 
			            {
			            ld_show_error(OR_STATUS, "execute s2");
			            }
/*
				Insert a new row into the WELL_HDR.
*/
		                EXEC SQL EXECUTE S3 USING :nodeID, :nodeX, :nodeY;
    		                if (OR_STATUS != 0) 
			            {
			            ld_show_error(OR_STATUS, "execute s3");
			            }
/*    
    				Insert a new row into NODES.
*/
		                }
		            else
		                {
		    	        sourceName.arr[sourceName.len] = 0;
			        if (strcmp((CHAR *)sourceName.arr, source) == 0)
			            {
			            if (overwrite != 0)
			    	        {
		                        EXEC SQL EXECUTE S4 USING :nodeX, 
								:nodeY, 
								:nodeID;
    		                        if (OR_STATUS != SUCCESS && 
	                                    OR_STATUS != OR_EOF) 
	                                   /* OR_EOF is necessary because user may check
	                                      overwrite but the node_id is not exist */
			                    {
			                    ld_show_error(OR_STATUS, "execute s4");
			                    }
		                        }
			            else
				        {
				        printf("%s - Well exists, \
not overwritten\n", inputUWI);
				        }
			            }
			        else
			            {
			            printf("%s - Well exists from source %s, \
not overwritten.\n", inputUWI, sourceName.arr);
			            }
			        }
/*
				Update the x,y in the nodes table, if all
				the signs and portents agree.
*/
		            EXEC SQL COMMIT WORK;
    		            if (OR_STATUS != 0) 
			        {
			        ld_show_error(OR_STATUS, "commit wells");
			        }
			    }
			else
			    {
			            printf("%s - Well outside of project area\
\n", inputUWI);
			    }
			}
		    }
#ifdef USE_OLDPARSING
		}
#endif
	    }
/*****************************************************************************

	C l e a n   U p   A n d   E x i t .

******************************************************************************/
	}
    if (spfile != (FILE *)NULL) fclose(spfile);
    return;
    }
