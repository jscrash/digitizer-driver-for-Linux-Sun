/* DEC/CMS REPLACEMENT HISTORY, Element LD_LM2_IMP_FAULT.PC */
/* *2     1-MAY-1991 21:53:26 KEE "(SPR -1) Landmark Import" */
/* *1     1-MAY-1991 21:19:08 KEE "Landmark Import & Export, Zycor Export and Mimic Export" */
/* DEC/CMS REPLACEMENT HISTORY, Element LD_LM2_IMP_FAULT.PC */
/******************************************************************************     */
/*                                                                                  */
/*                Copyright Finder Graphics Systems, Inc. 1989                      */
/*           Unpublished -- All rights reserved                                     */
/*                                                                                  */
/*THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Finder Graphics Systems, Inc.  AND   */
/*MAY CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE  */
/*DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE         */
/*MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF       */
/*                                                                                  */
/*            Finder Graphics Systems, Inc.                                         */
/*            201 Tamal Vista Blvd                                                  */
/*            Corte Madera, CA  USA 94925                                           */
/*            (415) 927-0100                                                        */
/*                                                                                  */
/*(The above notice does not constitute an admission of publication or              */
/*unrestricted dissemination of the work)                                           */
/*                                                                                  */
/******************************************************************************     */

/* ************************************************************************

   NAME: LD_LM2_IMP_FAULT.PC

   AUTHOR: Rod Hanks
   DATE:   May 10th, 1990
   DESCRIPTION: Load fault polygons from a file output by Landmark.

   ************************************************************************ */

#ifndef ESI_ORACLE_H
#include "esi_oracle.h"
#endif
#ifndef ESI_NL_H
#include "esi_nl.h"
#endif
#ifndef ESI_NL_ERR_H
#include "esi_nl_err.h"
#endif
#ifndef ESI_SE_H
#include "esi_se.h"
#endif
#ifndef ESI_TS_H
#include "esi_ts.h"
#endif
#ifndef ESI_HO_FILES_H
#include "esi_ho_files.h"
#endif
#ifndef LD_LM2_IMP_WORK_H
#include "ld_lm2_imp_work.h"
#endif

#if USE_PROTOTYPES
publicdef INT ld_lm2_imp_fault (FILENAME fileName, PROJECT_NAME project,
			BOOL convertProj, PROJECTION_STRUCTURE *defaultProj, 
                        PROJECTION_STRUCTURE *inputProj, CHAR *source, 
			INT overwrite, DOUBLE ll_x, DOUBLE ll_y, DOUBLE ur_x, 
			DOUBLE ur_y, CHAR *horizon)
#else
publicdef INT ld_lm2_imp_fault (fileName, project,
			convertProj, defaultProj, inputProj,
			source, overwrite, ll_x,
			ll_y, ur_x, ur_y, horizon)
FILENAME	fileName;
PROJECT_NAME	project;
BOOL	              convertProj;
PROJECTION_STRUCTURE *defaultProj;
PROJECTION_STRUCTURE *inputProj;
CHAR		     *source;
INT		      overwrite;
DOUBLE		      ll_x;
DOUBLE		      ll_y;
DOUBLE		      ur_x;
DOUBLE		      ur_y;
CHAR                 *horizon;
#endif
    {
/****************************************************************************

	V a r i a b l e   D e c l a r a t i o n s .

******************************************************************************/

    INT 	   status;
    FILE	   *spfile;
    FILENAME	   filename;
    FILENAME	   full_filename;
    FILENAME	   nlist_full_filename;
    CHAR           line_name[80];
    NLIST_HEADER   nlist = (NLIST_HEADER) 0;
    NLIST_ID	   nlist_id;
    UINT	   ncols = 3;
    INT		   units[3];
    INT		   data_types[3];
    size_t	   data_sizes[3];
    INT		   value_inc[3];
    UINT	   blocksize;
    INT		   tableNum;
    FLOAT          FX, FY, FZ;
    DOUBLE	   thisX;
    DOUBLE	   thisY;
    DOUBLE	   thisZ;
    UINT	   colList[3];
    VOIDPTR	   valueList[3];
    BOOL	   firstIteration;
    BOOL	   clippedFlag;
    DOUBLE	   lower_left_x;
    DOUBLE	   lower_left_y;
    DOUBLE	   upper_right_x;
    DOUBLE	   upper_right_y;
    BOOL	   skipLoad;
    BOOL	   newFault;
    SEIS_FAULT_TRACE *pftrace;
#ifdef USE_OLDPARSING
    CHAR	  *inputX;
    CHAR	  *inputY;
    CHAR	  *inputZ;
    CHAR	  *inputFlag;
    CHAR	  *pos;
    CHAR	   dummy[255];
#else
    LD_SCANNER_STRUCT ld_scan;	
#endif
/*
				General variable declarations.
*/
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR sqlstmt[600];
	int	lineID;
	int	objectID;
    EXEC SQL END DECLARE SECTION;
/*
				Oracle variable declarations.
*/
/****************************************************************************

	I n i t i a l i z a t i o n .

******************************************************************************/

    if (IS_EMPTY_STRING(horizon) == TRUE)
      {
	printf("Import Fault Polygon Fail - Please specify a horizon name\n");
        return(FAIL);
      }

    spfile = ho_open(fileName, "r", NULL);
    if (spfile == (FILE *)NULL)
	{
	printf("Unable to open fault polygon file named \n%s\n", fileName);
	}
    else
	{
        pftrace=(SEIS_FAULT_TRACE *)tc_alloc(sizeof(SEIS_FAULT_TRACE));
        strcpy(pftrace->hor_code, horizon);

        sprintf(line_name, "%s_%s", source, horizon);

        sqlstmt.len = sprintf((char *)sqlstmt.arr,
"SELECT OBJECT_ID FROM %s.GRAPHIC_OBJECTS \
WHERE OBJECT_NAME = 'FAULTS' AND SOURCE = '%s'", project, source);

        EXEC SQL PREPARE s10 FROM :sqlstmt;
        if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare s10");
        EXEC SQL DECLARE ID_LOOK CURSOR FOR S10;
	EXEC SQL OPEN ID_LOOK;
        if (OR_STATUS != 0) ld_show_error(OR_STATUS, "OPEN ID_LOOK");
	EXEC SQL FETCH ID_LOOK INTO :objectID;
	if (OR_STATUS < SUCCESS)
	    {
	    ld_show_error(OR_STATUS, "FETCH ID_LOOK");
	    }
	else if (OR_STATUS > SUCCESS)
	    {
            printf("loading fault polygons from %s\n", fileName);
	    EXEC SQL SELECT ESI.LYNX_ID_SEQ.NEXTVAL INTO :lineID FROM DUAL;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "GET LINE ID");
/*
				Get the next line id number.
*/
            sprintf(nlist_id, "%d", lineID);
	    filename[0] = 0;
	    status = se_bld_nlist_ids(0, (VOIDPTR)pftrace, SEIS_FTRACE_DATA,
	                              nlist_id, filename, nlist_full_filename);
	    sprintf(full_filename,"--FAULT-- Name: %s Marker: %s Seq: %d",
	            line_name, horizon, lineID);
            sqlstmt.len = sprintf((char *)sqlstmt.arr,
"INSERT INTO %s.LINES (LINE_ID, NLIST_ID, LINE_COLOR, LINE_STYLE, \
LINE_THICKNESS, LINE_NAME, POLYGON_FLAG, POLYGON_HATCH_STYLE, \
POLYGON_FILL_COLOR, NLIST_FILE) \
VALUES (%d, '%s', '3', '1', '1', '%s', 'NO', \
'0', '3', '%s')", project, lineID, nlist_id, line_name, full_filename);

            EXEC SQL PREPARE S3 FROM :sqlstmt;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare s3");
            EXEC SQL EXECUTE S3;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "execute s3");
            EXEC SQL COMMIT WORK;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "commit s3");
/*
				Go ahead and insert into the LINES table.
				This reserves our line id for us.  We need
				to know it before we get started since it
				is also the name of the nlist we are going
				to create.
*/
	    skipLoad = FALSE;
	    newFault = TRUE;
	    }
	else if (overwrite != 0)
	    {
            printf("overwriting fault polygons using %s\n", fileName);
            sqlstmt.len = sprintf((char *)sqlstmt.arr,
"SELECT ITEM_ID FROM %s.GRAPHIC_OBJECT_CORRELATIONS \
WHERE OBJECT_ID = :objectID", project);

            EXEC SQL PREPARE s11 FROM :sqlstmt;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare s11");
            EXEC SQL DECLARE ITEM_LOOK CURSOR FOR S11;
	    EXEC SQL OPEN ITEM_LOOK USING :objectID;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "OPEN ITEM_LOOK");
	    EXEC SQL FETCH ITEM_LOOK INTO :lineID;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "FETCH ITEM_LOOK");
	    EXEC SQL CLOSE ITEM_LOOK;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "CLOSE ITEM_LOOK");
/*
					Get the line ID of the current
					line.  This is also the nlist name.
*/
            sprintf(nlist_id, "%d", lineID);
	    filename[0] = 0;
	    status = se_bld_nlist_ids(0, (VOIDPTR)pftrace, SEIS_FTRACE_DATA,
	                              nlist_id, filename, nlist_full_filename);
	    status = nl_delete_nlist(nlist_full_filename, nlist_id);
            if (status != 0) ld_show_error(status, "nl_delete_nlist");
/*
					Delete the existing Nlist.
*/
	    skipLoad = FALSE;
	    newFault = FALSE;
	    }
	else
	    {
            printf("Fault polygons already exist from this source, \
not overwritten\n");
	    skipLoad = TRUE;
	    }
	EXEC SQL CLOSE ID_LOOK;
        if (OR_STATUS != 0) ld_show_error(OR_STATUS, "CLOSE ID_LOOK");
/*
					Above, decide if we have visited
					this fault before and what we should
					do about it.
*/
	if (skipLoad == FALSE)
	    {
	    firstIteration = TRUE;
	    clippedFlag = FALSE;
	    ncols = 3;
	    units[0] = units[1] = units[2] = 0;
	    data_types[0] = data_types[1] = data_types[2] = FLOAT_TYPE;
	    data_sizes[0] = data_sizes[1] = data_sizes[2] = sizeof(FLOAT);
	    value_inc[0] = value_inc[1] = value_inc[2] = VALUE_LIST;
	    blocksize = 500;
	    status = nl_init_nlist(&nlist, ncols, units, data_sizes,
					   data_types, value_inc, blocksize);
	    if (status != SUCCESS)
	        {
	        printf("Unable to initialize nlist, %s\n", 
					mg_message(status));
	        return FAIL;
	        }
/*****************************************************************************

	M a i n   L o g i c .

*****************************************************************************/

#ifdef USE_OLDPARSING
            while ((pos = fgets(dummy, 255, spfile)) != (CHAR *) 0)
              {
	        if (strlen(dummy) > 38)
	    	    {
/*
				Sometimes TCIP (or somebody) puts extraneous
				linesfeeds at the end of the data we get from
				Landmark and this keeps us from treating it
				as a stroke on the line.
*/
		    inputX = &dummy[0];
		    dummy[12] = 0;
		    inputY = &dummy[13];
		    dummy[24] = 0;
	            inputZ = &dummy[31];
	            dummy[36] = 0;
		    inputFlag = &dummy[38];
		    dummy[39] = 0;
/*
				There isn't always spaces between the columns
				in this input file, so instead of parsing for
				columns we are depending upon the file having
				a particular columnar format.  Since we are
				using Landmark's default format, this will
				probably be fairly consistant.
*/
	            sscanf(inputX, "%lf", &thisX);
	            sscanf(inputY, "%lf", &thisY);
	            sscanf(inputZ, "%lf", &thisZ);

/*
				The '6' flag announces a new table.  7 means
				the table continues and 8 means end of a table.
				We don't have to do anything special about an
				end.
*/
		    if (*inputFlag == '6')
#else
            tc_zeroes(&ld_scan, sizeof(LD_SCANNER_STRUCT));	
	    ld_scan.in.fix_format = TRUE;
	    ld_scan.in.snowhite = TRUE;
	    ld_scan.in.num_pair = 5;
            ld_scan.in.start[0] = 1;     ld_scan.in.end[0] = 12;
            ld_scan.in.start[1] = 14;    ld_scan.in.end[1] = 24;
            ld_scan.in.start[2] = 32;    ld_scan.in.end[2] = 36;
            ld_scan.in.start[3] = 39;    ld_scan.in.end[3] = 39;
            ld_scan.in.start[4] = 44;    ld_scan.in.end[4] = 44;
	    while (ld_scan.eof == FALSE)
	      {
	        ld_scan_line(spfile, &ld_scan);
	        /* check all items are there or empty line  */
   	       if (ld_scan.out_nitems == 0)
	         {
		   continue;
                 }
	       else if (ld_scan.out_nitems != ld_scan.in.num_pair OR
		        ld_scan.out[0].parmtype != LD_DOUBLE OR
		        ld_scan.out[1].parmtype != LD_DOUBLE OR
		        ld_scan.out[2].parmtype != LD_DOUBLE OR
		        ld_scan.out[3].parmtype != LD_INT)
	          {
		    printf("Invalid line format - following line will be skipped\n ");
		    printf("%s",ld_scan.line);
	 	    continue;
                  }
		else
		  {
		    thisX = ld_scan.out[0].parmval.dbval;
		    thisY = ld_scan.out[1].parmval.dbval;
		    thisZ = ld_scan.out[2].parmval.dbval;

/*
				The 6 flag announces a new table.  7 means
				the table continues and 8 means end of a table.
				We don't have to do anything special about an
				end.
*/
		    if (ld_scan.out[3].parmval.ival == 6)
#endif
		        {
		        status = nl_start_table(nlist, (UINT *)&tableNum);
		        if (status != SUCCESS)
			    {
			    printf("Unable to start table in nlist, %s\n", 
					mg_message(status));
			    return FAIL;
			    }
		        status = nl_set_current_row(nlist, 0, tableNum);
		        if (status != SUCCESS)
		            {
			    printf("Unable to set row in nlist, %s\n", 
					mg_message(status));
			    return FAIL;
		            }
		        }
/*
				The '6' flag announces a new table.  7 means
				the table continues and 8 means end of a table.
				We don't have to do anything special about an
				end.
*/
		    if (convertProj)
		        {
		        ct_transform_point(thisX, thisY, inputProj,
					  &thisX, &thisY, defaultProj);
		        }
		    if (thisX >= ll_x && thisX <= ur_x
		    &&  thisY >= ll_y && thisY <= ur_y)
			{
			FX = (FLOAT) thisX;
			FY = (FLOAT) thisY;
			FZ = (FLOAT) thisZ;
	                colList[0] = 1;
	                colList[1] = 2;
	                colList[2] = 3;
	                valueList[0] = (VOIDPTR)&FX;
	                valueList[1] = (VOIDPTR)&FY;
	                valueList[2] = (VOIDPTR)&FZ;
	                status = nl_add_rows(nlist, 1, 3, colList, valueList);
		        if (status != SUCCESS)
		            {
		            printf("Unable to add to nlist, %s\n", 
					mg_message(status));
		            return FAIL;
		            }
/*
				Put this row into the nlist.
*/
		        if (firstIteration)
			    {
			    lower_left_x = thisX;
			    upper_right_x = thisX;
			    lower_left_y = thisY;
			    upper_right_y = thisY;
			    firstIteration = FALSE;
			    }
		        else
			    {
	                    if (thisX < lower_left_x)
		                {
		                lower_left_x = thisX;
		                }
	                    if (thisX > upper_right_x)
		                {
		                upper_right_x = thisX;
		                }
	                    if (thisY < lower_left_y)
		                {
		                lower_left_y = thisY;
		                }
	                    if (thisY > upper_right_y)
		                {
		                upper_right_y = thisY;
		                }
/*
				Maintain the box which defines the line.
*/
			    }
			}
		    else
			{
			if (clippedFlag == FALSE)
			    {
			    printf("Clipped...\n");
			    clippedFlag = TRUE;
			    }
		        }
		    }
		}
/*****************************************************************************

	C l e a n   U p   A n d   E x i t .

******************************************************************************/
	    status = nl_write_nlist(nlist, nlist_full_filename, nlist_id);
	    if (status != SUCCESS)
	        {
	        printf("Unable to dispose nlist, %s\n",
					mg_message(status));
	        }
	    if (nlist != (NLIST_HEADER) 0)
	        {
	        nl_free_nlist(nlist);
	        nlist = (NLIST_HEADER) 0;
	        }
	    }
/*
	Above, write out the nlist.
*/
	if (newFault && skipLoad == FALSE)
	    {
	    EXEC SQL SELECT ESI.GRAPHIC_OBJECT_SEQ.NEXTVAL 
				INTO :objectID FROM DUAL;
    	    if (OR_STATUS != 0) ld_show_error(OR_STATUS, 
				"graphic_object_seq NEXTVAL");
/*
				Get the object id number.
*/
            sqlstmt.len = sprintf((char *)sqlstmt.arr,
"INSERT INTO %s.GRAPHIC_OBJECTS (OBJECT_NAME, OBJECT_ID, LOWER_LEFT_X, \
LOWER_LEFT_Y, UPPER_RIGHT_X, UPPER_RIGHT_Y, SOURCE, ATTRIBUTE_1) \
VALUES ('FAULTS', %d, %f, %f, %f, %f, '%s', '%s')", project, objectID,
lower_left_x, lower_left_y, upper_right_x, upper_right_y, source, horizon);

            EXEC SQL PREPARE s6 FROM :sqlstmt;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare s6");
            EXEC SQL EXECUTE s6;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "execute s6");
/*
				Insert the graphic object record.
*/
            sqlstmt.len = sprintf((char *)sqlstmt.arr,
"INSERT INTO %s.GRAPHIC_OBJECT_CORRELATIONS (OBJECT_ID, ITEM_ID, ITEM_CLASS) \
VALUES (%d, %d, 'LINE')", project, objectID, lineID);

            EXEC SQL PREPARE s7 FROM :sqlstmt;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare s7");
            EXEC SQL EXECUTE s7;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "execute s7");
/*
				Insert the graphic object correlation record.
*/	
            sqlstmt.len = sprintf((char *)sqlstmt.arr, 
"INSERT INTO %s.SEIS_FAULT_TRACE \
(HOR_CODE, SEQ, FAULT_CODE, SOURCE, LAST_UPDATE, \
DIGITAL_REF, DIGITAL_REF_VOLUME, \
LINE_COLOR, LINE_STYLE, LINE_THICKNESS, \
XMIN, YMIN, XMAX, YMAX) \
VALUES \
('%s', %d, '%s', '%s', SYSDATE, '%s', '%s', 'GREEN', 'SOLID', 'FINE', \
%lf, %lf, %lf, %lf)",
project,
horizon, lineID, line_name, source, nlist_id, filename, 
lower_left_x, lower_left_y, upper_right_x, upper_right_y);
       
            EXEC SQL PREPARE s8 FROM :sqlstmt;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare s8");
            EXEC SQL EXECUTE s8;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "execute s8");

            EXEC SQL COMMIT WORK;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "commit s6, s7 and s8");
	    }
	else if (overwrite != 0)
           {
            sqlstmt.len = sprintf((char *)sqlstmt.arr,
"UPDATE  %s.GRAPHIC_OBJECTS \
SET LOWER_LEFT_X = %f, LOWER_LEFT_Y = %f, \
UPPER_RIGHT_X = %f, UPPER_RIGHT_Y = %f \
WHERE OBJECT_ID = %d", project, lower_left_x, lower_left_y,
upper_right_x, upper_right_y, objectID);
            EXEC SQL PREPARE s9 FROM :sqlstmt;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare s9");
            EXEC SQL EXECUTE s9;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "execute s9");
/*
				update the graphic object record.
*/
            sqlstmt.len = sprintf((char *)sqlstmt.arr, 
"UPDATE %s.SEIS_FAULT_TRACE \
SET XMIN = %lf, YMIN = %lf, \
XMAX = %lf, YMAX = %lf, LAST_UPDATE = SYSDATE \
WHERE SEQ = %d", project, lower_left_x, lower_left_y, 
upper_right_x, upper_right_y, lineID);
            EXEC SQL PREPARE s10 FROM :sqlstmt;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare s10");
            EXEC SQL EXECUTE s10;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "execute s10");

            EXEC SQL COMMIT WORK;
            if (OR_STATUS != 0) ld_show_error(OR_STATUS, "commit s9 and s10");
	    }
        fclose(spfile);
	}
    return;
    
}

