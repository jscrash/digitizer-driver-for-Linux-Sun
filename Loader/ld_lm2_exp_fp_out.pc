/* DEC/CMS REPLACEMENT HISTORY, Element LD_LM2_EXP_FP_OUT.PC */
/* *3    14-AUG-1991 11:58:27 KEE "(SPR -1) Put in File Lock/Unlock logic" */
/* *2     1-MAY-1991 21:57:55 KEE "(SPR -1) Landmark Export" */
/* *1     1-MAY-1991 21:02:34 KEE "Landmark Import & Export, Zycor Export and Mimic Export" */
/* DEC/CMS REPLACEMENT HISTORY, Element LD_LM2_EXP_FP_OUT.PC */
/******************************************************************************     */
/*                                                                                  */
/*                Copyright Finder Graphics Systems, Inc. 1989                      */
/*           Unpublished -- All rights reserved                                     */
/*                                                                                  */
/*THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Finder Graphics Systems, Inc.  AND   */
/*MAY CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE  */
/*DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE         */
/*MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF       */
/*                                                                                  */
/*            Finder Graphics Systems, Inc.                                         */
/*            201 Tamal Vista Blvd                                                  */
/*            Corte Madera, CA  USA 94925                                           */
/*            (415) 927-0100                                                        */
/*                                                                                  */
/*(The above notice does not constitute an admission of publication or              */
/*unrestricted dissemination of the work)                                           */
/*                                                                                  */
/******************************************************************************     */

/* ************************************************************************

   NAME: LD_LM2_EXP_FP_OUT.PC

   AUTHOR: Rod Hanks
   DATE:   June 15th, 1990
   DESCRIPTION: Unload fault plane information 
		from a particular map overlay in Finder.

   ************************************************************************ */

#ifndef ESI_ORACLE_H
#include "esi_oracle.h"
#endif
#ifndef ESI_NL_H
#include "esi_nl.h"
#endif
#ifndef ESI_SE_INT_H
#include "esi_se_int.h"
#endif
#ifndef LD_LM2_EXP_WORK_H
#include "ld_lm2_exp_work.h"
#endif

/*****************************************************************************

	M a i n   L o g i c .

*****************************************************************************/

#if USE_PROTOTYPES
publicdef VOID ld_lm2_exp_fp_out(CHAR *selectPhrase, CHAR *selectList,
		   CHAR *horizonName, CHAR *sourceName,
		   BOOL *firstIteration, FILE **spfile, 
		   CHAR *mapName, PROJECT_NAME projectName, 
		   DOUBLE lowerLeftX, DOUBLE lowerLeftY, 
		   DOUBLE upperRightX, DOUBLE upperRightY,
		   FILENAME fileName1, PROJECTION_STRUCTURE *defaultProj, 
	 	   PROJECTION_STRUCTURE *inputProj)
#else
publicdef VOID ld_lm2_exp_fp_out(selectPhrase, selectList, horizonName,
				     sourceName, firstIteration, spfile,
				     mapName, projectName, 
		   		     lowerLeftX, lowerLeftY, 
				     upperRightX, upperRightY,
		   		     fileName1, defaultProj, inputProj)
CHAR		*selectPhrase;
CHAR		*selectList;
CHAR		*horizonName;
CHAR		*sourceName;
BOOL		*firstIteration;
FILE		**spfile;
CHAR		*mapName;
PROJECT_NAME	projectName;
DOUBLE		lowerLeftX;
DOUBLE		lowerLeftY;
DOUBLE		upperRightX;
DOUBLE		upperRightY;
FILENAME	fileName1;
PROJECTION_STRUCTURE *defaultProj;
PROJECTION_STRUCTURE *inputProj;
#endif
    {
/****************************************************************************

	V a r i a b l e   D e c l a r a t i o n s .

******************************************************************************/

    INT 	   status;
    INT		   faultCount;
    INT		   faultNow;
    CHAR	   faultCode[9];
    CHAR	   myLineName[31];
    CHAR	   myFaultName[39];
    CHAR	   sourceOut[51];
    CDP_FLOAT	   first_cdp;
    CDP_FLOAT	   last_cdp;
    FLOAT	   lower_time;
    FLOAT	   upper_time;
    CDP		   thisCdp;
    SP		   thisShot;
    FLOAT	   thisZ;
    CHAR	   outputFlag;
    NLIST_HEADER   lineList = (NLIST_HEADER) 0;
    NLIST_HEADER   outputNlist = (NLIST_HEADER) 0;
    INT		   lineCount;
    INT		   lineLoop;
    UINT           ndim;
    UINT           dim_list[1];
    VOIDPTR        value_list[1];
    UINT	   colList[3];
    VOIDPTR	   varOutList[2];
    INT            select_line_id;
    FULL_LINE_NAME line_name;
/*
				General variable declarations.
*/
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR sqlstmt[400]; 
	int	line_id;
	VARCHAR the_name[24];
	VARCHAR	the_survey[24];
	VARCHAR faults[100][9];
	VARCHAR sources[100][13];
	int     versions[100];
        VARCHAR horizon[31];
	VARCHAR fault_code[31];
	VARCHAR display_name[31];
    EXEC SQL END DECLARE SECTION;
/*
				Oracle variable declarations.
*/
/****************************************************************************

	I n i t i a l i z a t i o n .

******************************************************************************/

    if (*firstIteration)
	{
	printf("Processing fault plane data for map %s\n", mapName);
	printf("z, shot, line, fault name, flag file is %s\n", fileName1);
	*spfile = ho_open(fileName1, "w", NULL);
	status = ho_lock(*spfile, ON);
        if (*spfile == (FILE *)NULL || status != SUCCESS)
	    {
	    printf("Unable to open file -- %s\n", fileName1);
	    }
	else
	    {
	    *firstIteration = FALSE;
	    }
	}
    if (*spfile != (FILE*) 0)
	{
	lineCount = 0;
	ld_lm2_seis_list(selectPhrase, selectList, 
		            lowerLeftX, lowerLeftY, 
			    upperRightX, upperRightY,
			    &lineCount, &lineList);
/*
				Get a list of seismic lines which match our
				list and phrase criteria.
*/
	if (lineCount <= 0)
	    {
	    printf("Null seismic fault plane information found for map %s\n", 
						mapName);
	    }
        else
	    {
	    select_line_id = 0;
	    ndim = 1;
	    dim_list[0] = 1;
	    value_list[0] = (VOIDPTR) &select_line_id;
            nl_first_row(lineList,ndim,dim_list,value_list);
/*
				Initialize to take a trip thru the NLIST
				of lines for this map.
*/
	    sqlstmt.len = sprintf((char *)sqlstmt.arr,
"SELECT LINE_NAME, SURVEY \
FROM %s.SEIS_LINE_HDR \
WHERE LINE_ID = :line_id", projectName);

	    EXEC SQL PREPARE S2 FROM :sqlstmt;
    	    EXEC SQL DECLARE XY_CUR CURSOR FOR S2;
/*
				Setup an SQL statement to return information
				we need to read the horizon and x/y's.
*/
	    sqlstmt.len = sprintf((char *)sqlstmt.arr,
"SELECT VENDOR_LINE_NAME \
FROM %s.SEIS_LINE_XREF \
WHERE FINDER_LINE_NAME = :line_name AND FINDER_SURVEY = :survey \
AND VENDOR = 'LANDMARK'", projectName);

	    EXEC SQL PREPARE S8 FROM :sqlstmt;
    	    EXEC SQL DECLARE LAND_CUR CURSOR FOR S8;
/*
				Setup an SQL statement to return the original
				line name from landmark.
*/
	    sqlstmt.len = sprintf((char *)sqlstmt.arr,
"SELECT SURFACE_CODE, SOURCE, VERSION \
FROM %s.SEIS_SURFACE \
WHERE LINE_ID = :lineID \
AND SURFACE_TYPE = 2", projectName);

	    EXEC SQL PREPARE s3 FROM :sqlstmt;
	    if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare s3");
	    EXEC SQL DECLARE LOOK_SURF CURSOR FOR s3;

	    sqlstmt.len = sprintf((char *)sqlstmt.arr,
"SELECT DISPLAY_NAME FROM %s.SEIS_FAULT_CODES \
WHERE FAULT_CODE = :fault_code", projectName);

	    EXEC SQL PREPARE s4 FROM :sqlstmt;
	    if (OR_STATUS != 0) ld_show_error(OR_STATUS, "prepare s4");
	    EXEC SQL DECLARE C4 CURSOR FOR s4;

	    for (lineLoop = 1; lineLoop <= lineCount; lineLoop++)
	        {
		line_id = select_line_id;
                EXEC SQL OPEN XY_CUR USING :line_id;
                EXEC SQL FETCH XY_CUR INTO :the_name, :the_survey;
		EXEC SQL CLOSE XY_CUR;
/*
					Given line id, get the name and survey.
*/
	        strncpy(line_name.line_name, (CHAR *)the_name.arr, the_name.len);
	        line_name.line_name[the_name.len]=0;
	        strncpy(line_name.survey, (CHAR *)the_survey.arr, the_survey.len);
	        line_name.survey[the_survey.len]=0;
		line_name.id = (long) line_id;
/*
					Setup the FULL_LINE_NAME structure.
*/
		EXEC SQL OPEN LAND_CUR using :the_name, :the_survey;
		if (OR_STATUS != SUCCESS) ld_show_error(OR_STATUS, 
								"OPEN LAND");
		EXEC SQL FETCH LAND_CUR INTO :the_name;
		if (OR_STATUS < SUCCESS) ld_show_error(OR_STATUS, 
								"FETCH LAND");
		EXEC SQL CLOSE LAND_CUR;
		if (OR_STATUS != SUCCESS) ld_show_error(OR_STATUS, 
								"CLOSE LAND");
/*
					If it has been changed, use the xref
					to get back to the original line name
					used in landmark.
*/
		V_V_TO_C(myLineName, the_name);
		printf("Line: %s\n", myLineName);
		while (strlen(myLineName) < 19)
		    {
		    strcat(myLineName, " ");
		    }
		myLineName[19-1] = ' ';
                myLineName[19] = 0;
		V_FROMC(horizon, horizonName);
		EXEC SQL OPEN LOOK_SURF USING :line_id;
    		if (OR_STATUS != 0) ld_show_error(OR_STATUS, "open LOOK_SURF");
		EXEC SQL FETCH LOOK_SURF INTO :faults, :sources, :versions;
		status = OR_STATUS;
		faultCount = sqlca.sqlerrd[2];
    		if (OR_STATUS < 0) ld_show_error(OR_STATUS, 
							"fetch LOOK_SURF");
		EXEC SQL CLOSE LOOK_SURF;
    		if (OR_STATUS != 0) ld_show_error(OR_STATUS, 
							"close LOOK_SURF");
/*
				Get a list of faults which have this line_id
				in this horizon.
*/
		for (faultNow = 0; faultNow < faultCount; faultNow++)
	         {
		  strncpy(faultCode, (CHAR *)faults[faultNow].arr, 
			   faults[faultNow].len);
		  faultCode[faults[faultNow].len] = 0;
		  strncpy(sourceOut, (CHAR *)sources[faultNow].arr, 
			   sources[faultNow].len);
		  sourceOut[sources[faultNow].len] = 0;
		  if (strcmp(sourceOut,sourceName) == 0)	
                    {
		    V_FROMC(fault_code, faultCode);
		    EXEC SQL OPEN C4 USING :fault_code;
    		    if (OR_STATUS != 0) ld_show_error(OR_STATUS, "open C4");
		    EXEC SQL FETCH C4 INTO :display_name;
    		    if (OR_STATUS < 0) ld_show_error(OR_STATUS, 
							    "fetch C4");
		    EXEC SQL CLOSE C4;
    		    if (OR_STATUS != 0) ld_show_error(OR_STATUS, 
							    "close C4");
		    V_SETZERO(display_name);
		    strcpy(myFaultName, (CHAR *)display_name.arr);
	    	    while (strlen(myFaultName) < 24)
			{
			strcat(myFaultName, " ");
			}
		    myFaultName[24-1] = ' ';
		    myFaultName[24] = 0;
		    status = se_get(&outputNlist, faultCode, 
					SE_FAULT, SE_TIME,
					&line_name, sourceOut, 
					SE_AT_NM, SE_FINDER, 
					&versions[faultNow],
					&upper_time, &lower_time, 
					&first_cdp, &last_cdp);
		    if (status != SUCCESS)
		        {
			printf("SE_GET: %s\n", mg_message(status));
			}
		    else
			{
			colList[0] = 1;
			colList[1] = 2;
			varOutList[0] = (VOIDPTR) &thisCdp;
			varOutList[1] = (VOIDPTR) &thisZ;
			status = nl_first_row(outputNlist, 2, colList,
							varOutList);
			while (status >= SUCCESS 
			  && ((status & NL_EOL) != NL_EOL))
			    {
			    if ((status & NL_START_OF_TABLE) 
						== NL_START_OF_TABLE)
			        {
				outputFlag = '1';
				}
			    else if ((status & NL_END_OF_TABLE)
						== NL_END_OF_TABLE)
			        {
				outputFlag = '3';
				}
			    else
				{
				outputFlag = '2';
				}
/*
				Set a flag if we are at the beginning of a
				table.  This marks a fault.
*/
                            status = se_sp_from_cdp(&line_name, thisCdp,
                                                        &thisShot);
                            fprintf(*spfile, 
                                "%20.2f    %5.0lf. %s %s    %c\n", 
                                thisZ, thisShot, myLineName, myFaultName, 
                                outputFlag);
			    status = nl_next_row(outputNlist, 2,
						colList, varOutList);
			    } /* while */
			nl_free_nlist(outputNlist);
			} /* else */
                    } /* if */
		  } /* for */
		ndim = 1;
		dim_list[0] = 1;
		value_list[0] = (VOIDPTR) &select_line_id;
                nl_next_row(lineList,ndim,dim_list,value_list);
		}
	    nl_free_nlist(lineList);
	    }
        if (lineList IS_NOT_EQUAL_TO (NLIST_HEADER)0)
	    {
	    nl_free_nlist(lineList);
	    }
	}
/*****************************************************************************

	C l e a n   U p   A n d   E x i t .

******************************************************************************/
    return;
    
}
