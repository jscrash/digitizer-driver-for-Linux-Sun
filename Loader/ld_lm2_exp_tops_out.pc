/* DEC/CMS REPLACEMENT HISTORY, Element LD_LM2_EXP_TOPS_OUT.PC */
/* *3    14-AUG-1991 11:59:07 KEE "(SPR -1) Put in File Lock/Unlock logic" */
/* *2     1-MAY-1991 21:58:42 KEE "(SPR -1) Landmark Export" */
/* *1     1-MAY-1991 21:09:02 KEE "Landmark Import & Export, Zycor Export and Mimic Export" */
/* DEC/CMS REPLACEMENT HISTORY, Element LD_LM2_EXP_TOPS_OUT.PC */
/******************************************************************************     */
/*                                                                                  */
/*                Copyright Finder Graphics Systems, Inc. 1989                      */
/*           Unpublished -- All rights reserved                                     */
/*                                                                                  */
/*THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Finder Graphics Systems, Inc.  AND   */
/*MAY CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE  */
/*DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE         */
/*MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF       */
/*                                                                                  */
/*            Finder Graphics Systems, Inc.                                         */
/*            201 Tamal Vista Blvd                                                  */
/*            Corte Madera, CA  USA 94925                                           */
/*            (415) 927-0100                                                        */
/*                                                                                  */
/*(The above notice does not constitute an admission of publication or              */
/*unrestricted dissemination of the work)                                           */
/*                                                                                  */
/******************************************************************************     */

/* ************************************************************************

   NAME: LD_LM2_EXP_TOPS_OUT.PC

   AUTHOR: Rod Hanks
   DATE:   June 15th, 1990
   DESCRIPTION: Unload well log TOP information (well, top, depth)
		from a particular map overlay in Finder.

   ************************************************************************ */

#ifndef ESI_ORACLE_H
#include "esi_oracle.h"
#endif
#ifndef ESI_NL_H
#include "esi_nl.h"
#endif
#ifndef ESI_MG_H
#include "esi_mg.h"
#endif
#ifndef ESI_WE_WELLS_H
#include "esi_we_wells.h"
#endif
#ifndef ESI_WE_MSG_H
#include "esi_we_msg.h"
#endif
#ifndef ESI_TS_H
#include "esi_ts.h"
#endif
#ifndef LD_LM2_EXP_WORK_H
#include "ld_lm2_exp_work.h"
#endif

#if USE_PROTOTYPES
publicdef VOID ld_lm2_exp_tops_out(CHAR *selectPhrase, CHAR *selectList, 
		   BOOL *firstIteration, FILE **spfile, 
		   CHAR *mapName, PROJECT_NAME projectName, 
		   DOUBLE lowerLeftX, DOUBLE lowerLeftY,
		   DOUBLE upperRightX, DOUBLE upperRightY,
		   FILENAME fileName1, CHAR *source)
#else
publicdef VOID ld_lm2_exp_tops_out(selectPhrase, selectList, firstIteration,
		    spfile, mapName, projectName, 
		    lowerLeftX, lowerLeftY, upperRightX, upperRightY,
		    fileName1, source)
CHAR		*selectPhrase;
CHAR		*selectList;
BOOL		*firstIteration;
FILE		**spfile;
CHAR		*mapName;
PROJECT_NAME	projectName;
DOUBLE		lowerLeftX;
DOUBLE		lowerLeftY;
DOUBLE		upperRightX;
DOUBLE		upperRightY;
FILENAME	fileName1;
CHAR		*source;
#endif
    {
/****************************************************************************

	V a r i a b l e   D e c l a r a t i o n s .

******************************************************************************/

    INT			status;
    NLIST_HEADER	wellList = (NLIST_HEADER) 0;
    INT			wellCount;
    VOIDPTR 		v_list[4];
    UINT    		colList[4];
    CHAR		thisUWI[51];
    CHAR		lastUWI[51];
    CHAR		thisName[51];
    CHAR		curName[51];
    CHAR		top_name[51];
    DOUBLE              dx;
    DOUBLE              dy;
    DOUBLE              tvd;
/*
				General variable declarations.
*/
    static BOOL declare_section = FALSE;

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR sqlstmt[400];
	VARCHAR wellUWI[51];
	VARCHAR xref_wellname[51];
	VARCHAR top[51];
	VARCHAR sourceName[13];
	double	md;
    EXEC SQL END DECLARE SECTION;
/*
				Oracle variable declarations.
*/

    if (declare_section == FALSE)
      {
        sqlstmt.len = sprintf((char *)sqlstmt.arr,
                      "SELECT VENDOR_WELL_NAME \
                      FROM %s.WELL_NAME_UWI_XREF \
                      WHERE FINDER_UWI = :wellUWI AND VENDOR = 'LANDMARK'", projectName);
        EXEC SQL PREPARE S1 FROM :sqlstmt;
        EXEC SQL DECLARE C1 CURSOR FOR S1;
      }
    EXEC SQL WHENEVER SQLERROR GOTO err;

/****************************************************************************

	I n i t i a l i z a t i o n .

******************************************************************************/

    lastUWI[0] = 0;
    if (*firstIteration)
	{
	printf("Processing well top information for map %s\n", mapName);
	printf("well name, top, value file is %s\n", fileName1);
	*spfile = ho_open(fileName1, "w", NULL);
	status = ho_lock(*spfile, ON);
        if (*spfile == (FILE *)NULL || status != SUCCESS)
	    {
	    printf("Unable to open file -- %s\n", fileName1);
	    }
	else
	    {
	    fprintf(*spfile, 
"UWI             Key well                         Top                   Ev_TD\n");
	    *firstIteration = FALSE;
	    }
	}
/*****************************************************************************

	M a i n   L o g i c .

*****************************************************************************/

    if (*spfile != (FILE *)NULL)
	{
	ld_get_wells(selectPhrase, selectList, 
			    &wellList, &wellCount,
		            lowerLeftX, lowerLeftY, 
			    upperRightX, upperRightY,
			    projectName);
/*
				Get a list of wells which match our
				list and phrase criteria.
*/
	if (wellCount <= 0)
	    {
	    printf("Null well information found for map %s\n", mapName);
	    }
	else
	    {
	    sqlstmt.len = sprintf((char *)sqlstmt.arr,
"SELECT FORM_CODE, MD \
FROM %s.WELL_TOPS \
WHERE UWI = :uwi AND SOURCE = :sourceName", projectName);

	    EXEC SQL PREPARE S2 FROM :sqlstmt;
	    if (OR_STATUS != SUCCESS) ld_show_error(OR_STATUS, "prepare s2");
	    EXEC SQL DECLARE LOOK_CURS CURSOR FOR S2;
	    colList[0] = 1;
	    v_list[0] = (VOIDPTR)thisName;
            status = nl_first_row(wellList, 1, colList, v_list);
/*
				Initialize to take a trip thru the NLIST
				of wells for this map.
*/
	    while (status >= 0 && ((status & NL_EOL) != NL_EOL))
		{
		status = ld_lm2_get_uwi(projectName, thisName, thisUWI);


		if (status == SUCCESS)
		    {
		    V_FROMC(wellUWI, thisUWI);
         	    EXEC SQL OPEN C1 using :wellUWI;
                    EXEC SQL FETCH C1 INTO :xref_wellname;
  	           if (OR_STATUS == SUCCESS)
	             {
   	                V_SETZERO(xref_wellname);
	                strcpy(thisName,(CHAR *)xref_wellname.arr);
	             }

		    V_FROMC(sourceName, source);
		    EXEC SQL OPEN LOOK_CURS USING :wellUWI, :sourceName;
		    if (OR_STATUS != SUCCESS) ld_show_error(OR_STATUS, 
							"OPEN LOOK_CURS");
		    EXEC SQL FETCH LOOK_CURS INTO :top, :md;

		    while (strlen(thisName) < 33)
			{
			strcat(thisName, " ");
			}
		    thisName[33-1] = ' ';
		    thisName[33] = 0;
		    }
		while (OR_STATUS == SUCCESS)
		    {
		    V_V_TO_C(top_name, top);
		    printf("Top %s of well %s\n", top_name,
							thisName);
		    while (strlen(top_name) < 22)
			{
			strcat(top_name, " ");
			}
	            top_name[22-1] = ' ';
		    top_name[22] = 0;
		    status = wes_get_dir_tvd(thisUWI, md, &dx, &dy, &tvd);
		    fprintf(*spfile, "                %s%s%9.1f\n", 
						thisName, top_name, tvd);
		    if (status != SUCCESS && strcmp(lastUWI,thisUWI) != 0)
	 	      {
		        strcpy(curName,thisName);
			printf("Error get well %s tvd : %s\n", 
				ts_snowhite(curName), mg_message(status));
			strcpy(lastUWI,thisUWI);
                      }
		    EXEC SQL FETCH LOOK_CURS INTO :top, :md;
		    }
		if (OR_STATUS < SUCCESS)
		    {
		    ld_show_error(OR_STATUS, "look_curs fetch");
		    }
		EXEC SQL CLOSE LOOK_CURS;
		if (OR_STATUS < SUCCESS)
		    {
		    ld_show_error(OR_STATUS, "look_curs CLOSE");
		    }
		colList[0] = 1;
   	        v_list[0] = (VOIDPTR)thisName;
		status = nl_next_row(wellList, 1, colList, v_list);
		}
	    if (status < 0)
		{
		printf("error reading nlist %s\n", mg_message(status));
		}
	    nl_free_nlist(wellList);
	    }
	}
/*****************************************************************************

	C l e a n   U p   A n d   E x i t .

******************************************************************************/
    EXEC SQL CLOSE C1;
    return;

err:
    printf("\n %.70s\n",sqlca.sqlerrm.sqlerrmc);
    return;
    }







