/* DEC/CMS REPLACEMENT HISTORY, Element LD_LM2_EXP_LOGS_OUT.PC */
/* *3    14-AUG-1991 11:58:44 KEE "(SPR -1) Put in File Lock/Unlock logic" */
/* *2     1-MAY-1991 21:58:17 KEE "(SPR -1) Landmark Export" */
/* *1     1-MAY-1991 21:05:24 KEE "Landmark Import & Export, Zycor Export and Mimic Export" */
/* DEC/CMS REPLACEMENT HISTORY, Element LD_LM2_EXP_LOGS_OUT.PC */
/******************************************************************************     */
/*                                                                                  */
/*                Copyright Finder Graphics Systems, Inc. 1989                      */
/*           Unpublished -- All rights reserved                                     */
/*                                                                                  */
/*THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Finder Graphics Systems, Inc.  AND   */
/*MAY CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE  */
/*DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE         */
/*MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF       */
/*                                                                                  */
/*            Finder Graphics Systems, Inc.                                         */
/*            201 Tamal Vista Blvd                                                  */
/*            Corte Madera, CA  USA 94925                                           */
/*            (415) 927-0100                                                        */
/*                                                                                  */
/*(The above notice does not constitute an admission of publication or              */
/*unrestricted dissemination of the work)                                           */
/*                                                                                  */
/******************************************************************************     */

/* ************************************************************************

   NAME: LD_LM2_EXP_LOGS_OUT.PC

   AUTHOR: Rod Hanks
   DATE:   June 15th, 1990
   DESCRIPTION: Unload well log curve information (well, depth, log, z)
		from a particular map overlay in Finder.

   ************************************************************************ */

#ifndef ESI_ORACLE_H
#include "esi_oracle.h"
#endif
#ifndef ESI_NL_H
#include "esi_nl.h"
#endif
#ifndef ESI_LG_LDEFS_H
#include "esi_lg_ldefs.h"
#endif
#ifndef ESI_GL_PROJECT_H
#include "esi_gl_project.h"
#endif
#ifndef ESI_WE_WELLS_H
#include "esi_we_wells.h"
#endif
#ifndef ESI_WE_MSG_H
#include "esi_we_msg.h"
#endif
#ifndef ESI_MG_H
#include "esi_mg.h"
#endif
#ifndef ESI_TS_H
#include "esi_ts.h"
#endif
#ifndef LD_LM2_EXP_WORK_H
#include "ld_lm2_exp_work.h"
#endif

#if USE_PROTOTYPES
publicdef VOID ld_lm2_exp_logs_out(CHAR *selectPhrase, CHAR *selectList,
		   BOOL *firstIteration, FILE **spfile, 
		   CHAR *mapName, PROJECT_NAME projectName, 
		   DOUBLE lowerLeftX, DOUBLE lowerLeftY, 
		   DOUBLE upperRightX, DOUBLE upperRightY,
		   FILENAME fileName1, CHAR curveName[200][12], 
		   INT curveCount, CHAR *source)
#else
publicdef VOID ld_lm2_exp_logs_out(selectPhrase, selectList, firstIteration, spfile,
		     mapName, projectName, 
		     lowerLeftX, lowerLeftY, upperRightX, upperRightY,
		     fileName1, curveName, curveCount, source)
CHAR		*selectPhrase;
CHAR		*selectList;
BOOL		*firstIteration;
FILE		**spfile;
CHAR		*mapName;
PROJECT_NAME	projectName;
DOUBLE		lowerLeftX;
DOUBLE		lowerLeftY;
DOUBLE		upperRightX;
DOUBLE		upperRightY;
FILENAME	fileName1;
CHAR		curveName[200][12];
INT		curveCount;
CHAR	       *source;
#endif
    {
/****************************************************************************

	V a r i a b l e   D e c l a r a t i o n s .

******************************************************************************/

    INT			status;
    LOG_TRACE_STRUCT    traceStruct;
    NLIST_HEADER	wellList = (NLIST_HEADER) 0;
    INT			wellCount;
    VOIDPTR 		v_list[4];
    UINT    		colList[4];
    CHAR		thisUWI[51];
    CHAR		lastUWI[51];
    CHAR		thisName[51];
    CHAR		curName[51];
    CHAR		thisCurve[51];
    FLOAT		thisDepth;
    FLOAT		thisValue;
    DOUBLE              md;
    DOUBLE              dx;
    DOUBLE              dy;
    DOUBLE              tvd;
    CHAR		dummy[51];
    INT			loop;

    BOOL             md_data;
    BOOL             depth_equal;
    INT              depth_equal_count;
    DOUBLE           diffs;

/*
				General variable declarations.
*/
    BOOL print_header_done = FALSE;
    static BOOL declare_section = FALSE;

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR sqlstmt[1500];
	VARCHAR wellUWI[51];
	VARCHAR wellName[51];
	VARCHAR xref_wellname[51];
	VARCHAR sourceName[51];
	VARCHAR trace_type[51];
	VARCHAR service[51];
	VARCHAR version[51];
	VARCHAR depth_unit[13];
    EXEC SQL END DECLARE SECTION;
/*
				Oracle variable declarations.
*/

    if (declare_section == FALSE)
      {
        sqlstmt.len = sprintf((char *)sqlstmt.arr,
                      "SELECT VENDOR_WELL_NAME \
                      FROM %s.WEll_NAME_UWI_XREF \
                      WHERE FINDER_UWI = :wellUWI AND VENDOR = 'LANDMARK'", projectName);
        EXEC SQL PREPARE S1 FROM :sqlstmt;
        EXEC SQL DECLARE C1 CURSOR FOR S1;
      }
    EXEC SQL WHENEVER SQLERROR GOTO err;

/****************************************************************************

	I n i t i a l i z a t i o n .

******************************************************************************/

    lastUWI[0] = 0;
    if (*firstIteration)
	{
	*spfile = ho_open(fileName1, "w", NULL);
	status = ho_lock(*spfile, ON);
        if (*spfile == (FILE *)NULL || status != SUCCESS)
	    {
	    printf("Unable to open file -- %s\n", fileName1);
	    }
	else
	    {
	    printf("Processing log curve information for map %s\n", mapName);
	    printf("well name, depth, curve, z_value file is %s\n", fileName1);
	    fprintf(*spfile, "Key well                                      C_TD");
	    *firstIteration = FALSE;
	    }
	}
/*****************************************************************************

	M a i n   L o g i c .

*****************************************************************************/

    if (*spfile != (FILE *)NULL)
	{
	md_data = FALSE;
	depth_equal = TRUE;
	depth_equal_count = 0;
	ld_get_wells(selectPhrase, selectList, 
			    &wellList, &wellCount,
		            lowerLeftX, lowerLeftY, 
			    upperRightX, upperRightY,
			    projectName);
/*
				Get a list of wells which match our
				list and phrase criteria.
*/
	if (wellCount <= 0)
	    {
	    printf("Null well information found for map %s\n", mapName);
	    }
	else
	    {
	    sqlstmt.len = sprintf((char *)sqlstmt.arr,
"SELECT TRACE_TYPE, SERVICE, TO_CHAR(VERSION), DEPTH_UNIT \
FROM %s.WELL_LOG_CURVE_HDR \
WHERE UWI = :uwi AND SOURCE = :sourceName AND TRACE_TYPE IN (", projectName);
	    for (loop = 0; loop < curveCount; loop++)
		{
		strcat((CHAR *)sqlstmt.arr, "'");
		strcat((CHAR *)sqlstmt.arr, curveName[loop]);
		strcat((CHAR *)sqlstmt.arr, "'");
		if (loop == curveCount - 1)
		    {
		    strcat((CHAR *)sqlstmt.arr, ")");
		    }
		else
		    {
		    strcat((CHAR *)sqlstmt.arr, ",");
		    }
		}
	    sqlstmt.len = strlen((CHAR *)sqlstmt.arr);

	    EXEC SQL PREPARE S2 FROM :sqlstmt;
	    if (OR_STATUS != SUCCESS) ld_show_error(OR_STATUS, "prepare s2");
	    EXEC SQL DECLARE LOOK_CURS CURSOR FOR S2;
	    colList[0] = 1;
	    v_list[0] = (VOIDPTR)thisName;
            status = nl_first_row(wellList, 1, colList, v_list);
/*
				Initialize to take a trip thru the NLIST
				of wells for this map.
*/
	    while (status >= 0 && ((status & NL_EOL) != NL_EOL))
		{
		status = ld_lm2_get_uwi(projectName, thisName, thisUWI);

		if (status == SUCCESS)
		    {
		    V_FROMC(wellUWI, thisUWI);
         	    EXEC SQL OPEN C1 using :wellUWI;
                    EXEC SQL FETCH C1 INTO :xref_wellname;
  	            if (OR_STATUS == SUCCESS)
 	              {
   	                 V_SETZERO(xref_wellname);
	                 strcpy(thisName,(CHAR *)xref_wellname.arr);
	              }

		    V_FROMC(sourceName, source);
		    EXEC SQL OPEN LOOK_CURS USING :wellUWI, :sourceName;
		    if (OR_STATUS != SUCCESS) ld_show_error(OR_STATUS, 
							"OPEN LOOK_CURS");
		    EXEC SQL FETCH LOOK_CURS INTO :trace_type, :service, 
						  :version, :depth_unit;
		    while (strlen(thisName) < 46)
			{
			strcat(thisName, " ");
			}
	             thisName[46-1] = ' ';
	             thisName[46] = 0;
		    }
		while (OR_STATUS == SUCCESS)
		    {
		    tc_zeroes(&traceStruct, sizeof traceStruct);
		    strncpy(traceStruct.uwi, (CHAR *)wellUWI.arr, wellUWI.len);
		    traceStruct.uwi[wellUWI.len] = 0;
		    traceStruct.trace_name[0] = 0;
		    if (strlen(source) > 0)
			{
			strcpy(traceStruct.trace_name, source);
			strcat(traceStruct.trace_name, ":");
			}
		    if (trace_type.len > 0)
			{
			strncpy(dummy, (CHAR *)trace_type.arr, trace_type.len);
			dummy[trace_type.len] = 0;
			strcat(traceStruct.trace_name, dummy);
			}
		    if (service.len > 0)
			{
			strcat(traceStruct.trace_name, ".");
			strncpy(dummy, (CHAR *)service.arr, service.len);
			dummy[service.len] = 0;
			strcat(traceStruct.trace_name, dummy);
			}
		    if (version.len > 0)
			{
			strncpy(dummy, (CHAR *)version.arr, version.len);
			dummy[version.len] = 0;
			if (strcmp(dummy, "0") != 0)
			    {
			    strcat(traceStruct.trace_name, ";");
			    strcat(traceStruct.trace_name, dummy);
			    }
			}
		    printf("Curve %s of well %s\n", traceStruct.trace_name,
							traceStruct.uwi);
		    status = lg_ltdm_get_trace(&traceStruct);
		    if (status != SUCCESS)
			{
			printf("Unable to retrieve this curve.\n%s\n",
					mg_message(status));
			}
		    else
			{
			strcpy(thisCurve, traceStruct.trace);
		    	while (strlen(thisCurve) < 15)
			    {
			    strcat(thisCurve, " ");
			    }
			thisCurve[15-1] = ' ';
			thisCurve[15] = 0;
		        colList[0] = 1;
			colList[1] = 2;
		        v_list[0] = (VOIDPTR)&thisDepth;
			v_list[1] = (VOIDPTR)&thisValue;
                        status = nl_first_row(traceStruct.ptrace, 
							2, colList, v_list);
		        while (status >= 0 && ((status & NL_EOL) != NL_EOL))
			    {
			    if (print_header_done == FALSE)
			      {
				V_SETZERO(depth_unit);
				if (depth_unit.len != 0 &&
				    depth_unit.len < 3)
				  {
				    fprintf(*spfile, " (%s)", (CHAR *)depth_unit.arr);	
	                            for (loop = 3 + depth_unit.len; 
					 loop < 6; 
				         loop++)
				      {
				        fprintf(*spfile, " ");
				      }
				  }
				else
				  {
				    fprintf(*spfile, "      ");
				  }
				fprintf(*spfile,"C_name         C_val\n");
				print_header_done = TRUE;
	                      }
			    md = tvd = (DOUBLE) thisDepth;
			    status = SUCCESS;
		            if (md_data == FALSE)
			      {
    		                status = 
				  wes_get_dir_tvd(thisUWI, md, &dx, &dy, &tvd);
	                        diffs = (md - tvd >= 0) ? md - tvd : tvd - md;
		                if (diffs >= 0.0 AND diffs < 0.1)
		                  {
			            depth_equal_count++;
			            if (depth_equal_count == 100 AND
			                depth_equal == TRUE)
			              { /* If md = tvd for the first 100 lines,
			        	   that means we are using tvd as md at
			       		   directional survey date import.
			       		   In order to speed up logs data 
					   exporting, no more wes_get_dir_tvd 
					   calculation will be performed */
			    		md_data = TRUE;
			              }
		                  }
				else
		                  {
				    depth_equal = FALSE;
                                  }
			      }
		            fprintf(*spfile, "%s%9.1f %s%9.3f\n", 
						thisName, tvd, thisCurve, thisValue);
		            if (status != SUCCESS && strcmp(lastUWI,thisUWI) != 0)
	 	              {
			        strcpy(curName,thisName);
			        printf("Error get well %s tvd : %s\n", 
					ts_snowhite(curName), mg_message(status));
			        strcpy(lastUWI,thisUWI);
                              }
		            status = nl_next_row(traceStruct.ptrace, 
							2, colList, v_list);
			    }
			if (status < 0)
			    {
			    printf("error reading log nlist -- %s\n",
						mg_message(status));
			    }
			}
		    EXEC SQL FETCH LOOK_CURS INTO :trace_type, :service, 
						  :version, :depth_unit;
		    }
		if (OR_STATUS < SUCCESS)
		    {
		    ld_show_error(OR_STATUS, "look_curs fetch");
		    }
		EXEC SQL CLOSE LOOK_CURS;
		if (OR_STATUS < SUCCESS)
		    {
		    ld_show_error(OR_STATUS, "look_curs CLOSE");
		    }
		colList[0] = 1;
   	        v_list[0] = (VOIDPTR)thisName;
		status = nl_next_row(wellList, 1, colList, v_list);
		}
	    if (status < 0)
		{
		printf("error reading nlist %s\n", mg_message(status));
		}
	    nl_free_nlist(wellList);
	    }
	}
/*****************************************************************************

	C l e a n   U p   A n d   E x i t .

******************************************************************************/
    EXEC SQL CLOSE C1;
    return;

err:
    printf("\n %.70s\n",sqlca.sqlerrm.sqlerrmc);
    return;
    }
