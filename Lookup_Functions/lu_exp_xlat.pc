/* DEC/CMS REPLACEMENT HISTORY, Element LU_EXP_XLAT.PC */
/* *12   23-OCT-1990 13:52:08 KEE "(SPR -1) Motif and DecWindow Merge" */
/* *11   23-AUG-1990 18:03:30 PURNA "(SPR 0) compiling error" */
/* *10   23-AUG-1990 17:43:32 JESSIE "(SPR 1) fix include files" */
/* *9    27-MAR-1990 13:53:30 VINCE "(SPR 1) panic fixes" */
/* *8    26-FEB-1990 18:59:52 JULIAN "(SPR 6010) Port to Decstation 3100 (ULTRIX)" */
/* *7    20-OCT-1989 11:12:04 GORDON "(SPR 999) Redo lu_get_tcp code & node structure" */
/* *6    20-SEP-1989 07:49:12 GORDON "(SPR 100) undo last checkin" */
/* *5    19-SEP-1989 13:37:16 GILLESPIE "(SPR 100) GULF MODS" */
/* *4    19-SEP-1989 08:09:08 GORDON "(SPR 100) put space between '=' & '*' for more picky VMS5 compiler" */
/* *3    18-SEP-1989 12:43:31 PURNA "Gulf mods under SPR 100" */
/* *2    14-SEP-1989 16:18:02 GORDON "(SPR 100) Gulf/Sun/Unix mods" */
/* *1     5-SEP-1989 10:24:46 GORDON "New module to do CODES.EXPRESSION_CODES lookups." */
/* DEC/CMS REPLACEMENT HISTORY, Element LU_EXP_XLAT.PC */
/* DEC/CMS REPLACEMENT HISTORY, Element LU_EXP_XLAT.PC                              */
/* *1    13-AUG-1990 16:55:12 SYSTEM "Finder 6.1"                                   */
/* DEC/CMS REPLACEMENT HISTORY, Element LU_EXP_XLAT.PC                              */
/* DEC/CMS REPLACEMENT HISTORY, Element LU_EXP_XLAT.PC                              */
/* *1    19-JUN-1989 12:31:31 SYSTEM ""                                             */
/* DEC/CMS REPLACEMENT HISTORY, Element LU_EXP_XLAT.PC                              */
/************************************************************************************/
/******************************************************************************     */
/*                                                                                  */
/*      Copyright Exploration Systems, Inc. 1989                                    */
/*         Unpublished -- All rights reserved                                       */
/*                                                                                  */
/*THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Exploration Systems, Inc.  AND MAY   */
/*CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE      */
/*DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE         */
/*MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF       */
/*                                                                                  */
/*                            Exploration Systems                                   */
/*                            c/o Finder Graphics Systems                           */
/*                            201 Tamal Vista Blvd.                                 */
/*                            Corte Madera, CA  94925                               */
/*                            (415) 927-0100                                        */
/*                                                                                  */
/*(The above notice does not constitute an admission of publication or              */
/*unrestricted dissemination of the work)                                           */
/*                                                                                  */
/*                                                                                  */
/******************************************************************************     */

#include "esi_gl_defs.h"

#ifndef ESI_TC_H
#include "esi_tc.h"
#endif

#ifndef ESI_TS_H
#include "esi_ts.h"
#endif

#include "esi_lu_msg.h"
#include "esi_oracle.h"

/* We will keep a linked list of structures, with a new node                        */
/*   for each new KEYWORD requested by the application.                             */

typedef struct lu_node
    {
    CHAR **nameTcp;                 /* Table of strings for KEYWORD's               */
    INT *codeList;                  /* Codes corresponding to nameTcp               */
    struct lu_node *next;           /* The next node (KEYWORD) in chain             */
    CHAR keyword[28];               /* The keyword ("COLOR", "FONT", etc.)          */
    } LU_NODE;

static LU_NODE *firstNode = (LU_NODE *)
0;

#if USE_PROTOTYPES
static LU_NODE *luz_getLuNode (CHAR *keyword);
static BOOL luz_isSpecial (CHAR *keyword);
#else
static LU_NODE *luz_getLuNode ();
static BOOL luz_isSpecial ();
#endif

/* File Description ---------------------------------------------------------       */
/*Overview:                                                                         */
/*    This module will enable applications to retrieve the NAME or                  */
/*    CODE values for any KEYWORD in the EXPRESSION_CODES table.                    */
/*    The first time through for each KEYWORD (e.g. "COLOR", "FONT", etc.)          */
/*    the database is queried and a memory structure is built for all               */
/*    future lookups.                                                               */
/*                                                                                  */
/*Prototypes and one line descriptions of each function in the file.                */
/*Public_Functions:                                                                 */
/*    publicdef INT lu_index_to_text(CHAR *keyword, CHAR *text, INT index);         */
/*                                                                                  */
/*    publicdef INT lu_text_to_index(CHAR *keyword, INT *index, CHAR *text);        */
/*                                                                                  */
/*    publicdef INT lu_get_tcp(CHAR *keyword, CHAR ***ptcp, INT *numRet);           */
/*                                                                                  */
/*Private_Functions:                                                                */
/*    static LU_NODE *luz_getLuNode( CHAR *keyword );                           */
/*                                                                                  */
/*    static BOOL luz_isSpecial(CHAR *string);                                  */
/*                                                                                  */
/*-----------------------------------------------------------------------------     */

/* Function Description -----------------------------------------------------       */
/*Description:                                                                      */
/*    Retrieve the value of the NAME column in the EXPRESSION_CODES                 */
/*    table corresponding to the given CODE column,                                 */
/*    where the KEYWORD is the given keyword.                                       */
/*                                                                                  */
/*Prototype:                                                                        */
/*    publicdef INT lu_index_to_text(CHAR *keyword, CHAR *text, INT index);         */
/*                                                                                  */
/*Parameters:     (indicate (I)/(O)/(M) for input/output/input-and-modified)        */
/*    (I) keyword     -(CHAR *) The KEYWORD.                                        */
/*    (O) text        -(CHAR *) NAME column corresponding to index.                 */
/*    (I) index       -(INT) The CODE column value.                                 */
/*                                                                                  */
/*Return Value/Status:                                                              */
/*    SUCCESS - Successful completion.                                              */
/*    LU_EXP_BAD_LOOKUP                                                             */
/*                                                                                  */
/*Scope:                                                                            */
/*    PUBLIC                                                                        */
/*                                                                                  */
/*Limitations/Assumptions:                                                          */
/*                                                                                  */
/*-----------------------------------------------------------------------------     */

/* BEGIN:                                                                           */
#if USE_PROTOTYPES
publicdef INT lu_index_to_text (CHAR *keyword, CHAR *text, INT index)
#else
publicdef INT lu_index_to_text (keyword, text, index)
CHAR *keyword;
CHAR *text;
INT index;
#endif
    {
    LU_NODE *lnp;
    INT ii;
    
    *text = '\0';                   /* Assume failure                               */
    lnp = luz_getLuNode (keyword);
    if (lnp == (LU_NODE *)0)
        return LU_EXP_BAD_LOOKUP;
    
    for (ii = 0; lnp->nameTcp[ii] != NULL; ++ii)
        {
        if (lnp->codeList[ii] == index)
            {
            if (ARE_SAME (keyword, "COLOR"))    /* for "COLOR" keyword,             */
                {
                if (luz_isSpecial (lnp->nameTcp[ii]))   /* ignore the specials      */
                    continue;
                }
            strcpy (text, lnp->nameTcp[ii]);
            return SUCCESS;
            }
        }
    return LU_EXP_BAD_LOOKUP;
    }
/* END:                                                                             */

/* Function Description -----------------------------------------------------       */
/*Description:                                                                      */
/*    Retrieve the value of the CODE column in the EXPRESSION_CODES                 */
/*    table corresponding to the given NAME column, where                           */
/*    the KEYWORD is the given keyword.                                             */
/*                                                                                  */
/*Prototype:                                                                        */
/*    publicdef INT lu_text_to_index(CHAR *keyword, INT *index, CHAR *text);        */
/*                                                                                  */
/*Parameters:     (indicate (I)/(O)/(M) for input/output/input-and-modified)        */
/*    (I) keyword     -(CHAR *) The KEYWORD.                                        */
/*    (O) index       -(INT *) Code columm value for text.                          */
/*    (I) text        -(CHAR *) The NAME column value.                              */
/*                                                                                  */
/*Return Value/Status:                                                              */
/*    SUCCESS - Successful completion.                                              */
/*    LU_EXP_BAD_LOOKUP                                                             */
/*                                                                                  */
/*Scope:                                                                            */
/*    PUBLIC                                                                        */
/*                                                                                  */
/*Limitations/Assumptions:                                                          */
/*                                                                                  */
/*-----------------------------------------------------------------------------     */

/* BEGIN:                                                                           */
#if USE_PROTOTYPES
publicdef INT lu_text_to_index (CHAR *keyword, INT *index, CHAR *text)
#else
publicdef INT lu_text_to_index (keyword, index, text)
CHAR *keyword;
INT *index;
CHAR *text;
#endif
    {
    LU_NODE *lnp;
    INT ii;
    
    *index = 0;                     /* Assume failure, use default                  */
    lnp = luz_getLuNode (keyword);
    if (lnp == (LU_NODE *)0)
        return LU_EXP_BAD_LOOKUP;
    
    for (ii = 0; lnp->nameTcp[ii] != NULL; ++ii)
        {
        if (ARE_SAME (lnp->nameTcp[ii], text))
            {
            *index = lnp->codeList[ii];
            return SUCCESS;
            }
        }
    return LU_EXP_BAD_LOOKUP;
    }
/* END:                                                                             */

/* Function Description -----------------------------------------------------       */
/*Description:                                                                      */
/*    Return a table of character pointers representing                             */
/*        all the current NAME values from the EXPRESSION_CODES table               */
/*        corresponding to the given KEYWORD.  Returns SUCCESS, or FAIL             */
/*        on any error.                                                             */
/*                                                                                  */
/*Prototype:                                                                        */
/*    publicdef INT lu_get_tcp(CHAR *keyword, CHAR ***ptcp, INT *numRet);           */
/*                                                                                  */
/*Parameters:     (indicate (I)/(O)/(M) for input/output/input-and-modified)        */
/*    (I) keyword     -(CHAR *) The given keyword.                                  */
/*    (O) ptcp        -(CHAR ***) The returned TCP.                                 */
/*    (O) numRet      -(INT *) The number of items returned.                        */
/*                                                                                  */
/*Return Value/Status:                                                              */
/*    SUCCESS - Successful completion.                                              */
/*    LU_EXP_BAD_LOOKUP                                                             */
/*                                                                                  */
/*Scope:                                                                            */
/*    PUBLIC                                                                        */
/*                                                                                  */
/*Limitations/Assumptions:                                                          */
/*                                                                                  */
/*-----------------------------------------------------------------------------     */

/* BEGIN:                                                                           */
#if USE_PROTOTYPES
publicdef INT lu_get_tcp (CHAR *keyword, CHAR***ptcp, INT *numRet)
#else
publicdef INT lu_get_tcp (keyword, ptcp, numRet)
CHAR *keyword;
CHAR***ptcp;
INT *numRet;
#endif
    {
    LU_NODE *lnp;
    
    *ptcp = (CHAR **)0;
    if (numRet != (INT *)0)
        *numRet = 0;
    
    lnp = luz_getLuNode (keyword);
    if (lnp == (LU_NODE *)0)
        return LU_EXP_BAD_LOOKUP;
    
    *ptcp = lnp->nameTcp;
    if (numRet != (INT *)0)
        *numRet = ts_tcp_len (lnp->nameTcp);
    return SUCCESS;
    }
/* END:                                                                             */

/* Function Description -----------------------------------------------------       */
/*Description:                                                                      */
/*    Return the node in the linked list corresponding to                           */
/*       the given keyword.  If the node doesn't exist, create it and               */
/*       fill it with the data from the database.  Returns a 0 pointer              */
/*       if any error occurred.                                                     */
/*                                                                                  */
/*Prototype:                                                                        */
/*    static LU_NODE *luz_getLuNode(CHAR *keyword);                             */
/*                                                                                  */
/*Parameters:     (indicate (I)/(O)/(M) for input/output/input-and-modified)        */
/*    (I) keyword     -(CHAR *) The given keyword.                                  */
/*                                                                                  */
/*Return Value/Status:                                                              */
/*    Function returns the node in the linked list corresponding to                 */
/*    the given keyword.                                                            */
/*                                                                                  */
/*Scope:                                                                            */
/*    PRIVATE to <lu_exp_xlat.pc>                                                   */
/*                                                                                  */
/*Limitations/Assumptions:                                                          */
/*                                                                                  */
/*-----------------------------------------------------------------------------     */

/* BEGIN:                                                                           */
#if USE_PROTOTYPES
static LU_NODE *luz_getLuNode (CHAR *keyword)
#else
static LU_NODE *luz_getLuNode (keyword)
CHAR *keyword;
#endif
    {
    LU_NODE *lnp;
    INT i;
    INT numReturned;
    CHAR nameList[100][24];
    INT codeList[100];
    static BOOL cursors_prepared = FALSE;
    static CHAR env[8] = 
#ifdef PRIOR_GKS /* ========== BEGIN PRIOR GKS ========== */
    "PRIOR"
#else  /* ========== END PRIOR GKS = BEGIN NON-PRIOR GKS ========== */

#ifdef sun
    "SUN"
#endif

#ifdef mips
    "ULTRIXR"
#endif

#ifdef vms
    "VMS"
#endif

#ifdef primos
    "PRIMOS"
#endif
#endif  /* ========== END NON-PRIOR GKS ========== */
    ;
    
    EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR name[20][20];
    VARCHAR o_keyword[28];
    static VARCHAR environment[12];
    int code[20];
    int count;
    EXEC SQL END DECLARE SECTION;
    
    /* First, see if we've already loaded the pertinent data.                       */
    
    if (firstNode != (LU_NODE *)0)
        {
        for (lnp = firstNode; TRUE; lnp = lnp->next)
            {
            if (ARE_SAME (keyword, lnp->keyword))
                return lnp;         /* Got it!                                      */
            if (lnp->next == (LU_NODE *)0)
                {
                break;
                }
            }
        }
    /* At this point, we know the data for the                                      */
    /*   keyword hasn't been loaded yet, and, if                                    */
    /*the list isn't empty, that                                                    */
    /*   lnp is pointing to the last node in the                                    */
    /*list, ready to add a new node if we find                                      */
    /*anything in the database.                                                     */
    /* First, find out if there are any host-specific rows for this                 */
    /*   keyword.                                                                   */
    
    EXEC SQL WHENEVER SQLERROR GOTO errrpt;
    
    if (!cursors_prepared)          /* Prepare the cursors                          */
        {
        V_FROMC (environment, env);
        
        EXEC SQL DECLARE TLU_HOST_CUR CURSOR FOR
	    SELECT NAME, CODE FROM CODES.EXPRESSION_CODES
	    WHERE KEYWORD = :o_keyword AND 
	    ENVIRONMENT = :environment 
	    ORDER BY NAME;
	    
	EXEC SQL DECLARE TLU_NULL_CUR CURSOR FOR
	    SELECT NAME, CODE FROM CODES.EXPRESSION_CODES
	    WHERE KEYWORD = :o_keyword AND
	    ENVIRONMENT IS NULL
	    ORDER BY NAME;

        cursors_prepared = TRUE;
        }

 
    V_FROMC( o_keyword, keyword );
    
    EXEC SQL SELECT COUNT(*) INTO :count 
        FROM CODES.EXPRESSION_CODES
	WHERE KEYWORD = :o_keyword AND
	ENVIRONMENT = :environment;
	
    if (count > 0)
        {
        EXEC SQL OPEN TLU_HOST_CUR;

        for(numReturned=0; numReturned < 100; )	
            {
            EXEC SQL FETCH TLU_HOST_CUR INTO :name,:code;
	    for(i=0; i<OR_ROWCOUNT-numReturned; i++) 
	        {
	        V_FROMV(nameList[i+numReturned],name[i]);
	        codeList[i+numReturned] = code[i];
	        } 

	    numReturned += (OR_ROWCOUNT-numReturned);
	    if (OR_STATUS == OR_EOF)	/* no more to fetch */
	      break;
	    }

        EXEC SQL CLOSE TLU_HOST_CUR;
        }
    
    else
        {
        EXEC SQL OPEN TLU_NULL_CUR;

        for(numReturned=0; numReturned < 100; )	
            {
            EXEC SQL FETCH TLU_NULL_CUR INTO :name,:code;
	    for(i=0; i<OR_ROWCOUNT-numReturned; i++) 
	        {
	        V_FROMV(nameList[i+numReturned],name[i]);
	        codeList[i+numReturned] = code[i];
	        } 

	    numReturned += (OR_ROWCOUNT-numReturned);
	    if (OR_STATUS == OR_EOF)	/* no more to fetch */
	      break;
	    }

        EXEC SQL CLOSE TLU_NULL_CUR;
        }

    if (numReturned == 0)
        return(LU_NODE *)0;
    /* Make a new node for the keyword                                              */
    if (firstNode == (LU_NODE *)0)
        {
        lnp = firstNode = (LU_NODE *) tc_zalloc (sizeof(LU_NODE));
        }
    else
        {
        lnp->next = (LU_NODE *) tc_zalloc (sizeof(LU_NODE));
        if (lnp->next == (LU_NODE *)0)
            return(LU_NODE *)0;
        lnp = lnp->next;
        }
    /* Now fill in our data                                                         */
    strcpy (lnp->keyword, keyword);
    lnp->nameTcp = TCP_ALLOCATE (numReturned);
    lnp->codeList = (INT *) tc_alloc (numReturned * sizeof(INT));
    if (lnp->nameTcp == (CHAR **)0 || lnp->codeList == (INT *)0)
        return(LU_NODE *)0;
    for (i = 0; i < numReturned; ++i)
        {
        lnp->nameTcp[i] = tc_alloc (strlen (nameList[i]) + 1);
        strcpy (lnp->nameTcp[i], nameList[i]);
        lnp->codeList[i] = codeList[i];
        }
    return lnp;
    
errrpt:
    return(LU_NODE *)0;
    
    }
/* END:                                                                             */

/* Function Description -----------------------------------------------------       */
/*Description:                                                                      */
/*    Return TRUE if given string is one of the special                             */
/*    character strings, else FALSE.                                                */
/*                                                                                  */
/*Prototype:                                                                        */
/*    static BOOL luz_isSpecial(CHAR *string);                                  */
/*                                                                                  */
/*Parameters:     (indicate (I)/(O)/(M) for input/output/input-and-modified)        */
/*    (I) string      -(CHAR *) Input string.                                       */
/*                                                                                  */
/*Return Value/Status:                                                              */
/*    Function returns TRUE if given string is one of the special                   */
/*    character strings, else FALSE.                                                */
/*                                                                                  */
/*Scope:                                                                            */
/*    PRIVATE to <lu_exp_xlat.pc>                                                   */
/*                                                                                  */
/*Limitations/Assumptions:                                                          */
/*                                                                                  */
/*-----------------------------------------------------------------------------     */

/* BEGIN:                                                                           */
#if USE_PROTOTYPES
static BOOL luz_isSpecial (CHAR *string)
#else
static BOOL luz_isSpecial (string)
CHAR *string;
#endif
    {
    static CHAR *specials[] = 
        {
        "BACKGROUND", "HIGHLIGHT", "NORMAL", NULL
        };
    CHAR **p;
    
    for (p = specials; *p != NULL; ++p)
        {
        if (ARE_SAME (*p, string))
            return TRUE;
        }
    return FALSE;
    }
/* END:                                                                             */
