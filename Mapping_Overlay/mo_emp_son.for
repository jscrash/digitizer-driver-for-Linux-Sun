C  DEC/CMS REPLACEMENT HISTORY, Element MO_EMP_SON.FOR
C  *5     1-MAR-1990 16:02:11 GILLESPIE "(SPR 1) remove unused variables"
C  *4     6-NOV-1989 09:04:22 PURNA "(SPR 30) fix mo_ calls to mog_"
C  *3     3-NOV-1989 12:01:26 GILLESPIE "(SPR 30) Change entry points for new n-List nomenclature"
C  *2    19-SEP-1989 10:12:54 GORDON "(PURNA) GULF MODS UNDER SPR 100"
C  *1    10-AUG-1989 18:48:20 VINCE "Fortran code after UNIX mods"
C  DEC/CMS REPLACEMENT HISTORY, Element MO_EMP_SON.FOR
      SUBROUTINE MO_EMP_SONICS(PLV_PTR,PL_PTR,MO_PTR,MO_NAME2,
     X   TIE_FILE,STATUS)
C **************************************************************************
C THIS PROGRAM ALLOWS THE USER TO GENERATE A MODEL BY DIGITIZING BODIES
C AND ASSIGNING VELOCITIES AND DENSITIES TO THEM. SEUDO SONICS ARE
C CREATED AND SYNTHETIC SEISMIC SECTION IS GENERATED.
C
C 
C PLV_PTR    = N-LIST VELOCITY DENSITY POINTER
C PL_PTR     = N-LIST LAYER POINTER
C MO_PTR     = POINTER TO MO_STRUCT
C STATUS     = RETURN CODE, 0 = SUCCESS, 1 = FAIL
C
C **************************************************************************

      INTEGER*4 STATUS
      REAL*8 MO_PTR,PL_PTR,PLV_PTR
      REAL*4 MO_GETDEP,MO_GET_VD
      CHARACTER*130 MO_NAME2,TIE_FILE*128
C
      INCLUDE 'mo_modcom.i'
      INCLUDE 'mo_struct.i'
      INCLUDE 'esi_am.i'
      INCLUDE 'esi_we_wells.i'
C
C WI STUFF
C
      CHARACTER*128 STRING,HELP
      EQUIVALENCE(STRING,E_STRING),(HELP,E_HELP)

      CHARACTER*(SIZEOF_UWI)    WELLS(MAX_WELLS)
      CHARACTER*(SIZEOF_WNAME)  WELLNM
      CHARACTER*(SIZEOF_OPER)   OPER
      CHARACTER*(SIZEOF_STATE)  STATE
      CHARACTER*(SIZEOF_COUNTY) COUNTY
      CHARACTER TSHPD*2, RANGD*2

      INTEGER IEKBS(MAX_WELLS)
      INTEGER IOR(MAX_WELLS),XPOS(MAX_WELLS)
      DATA HELP/'MO_EMP_SONICS'/
C
C XBUF     - INPUT ROWS, X ARRAY
C YBUF     - INPUT ROWS, Y ARRAY
C WELLS    - CURRENT LEFT AND RIGHT WELL
C IEKBS    - EKBS OF WELLS IN WELLS
C
C

      CALL MO_READ(PL_PTR,MO_PTR,NPTS,NLAY,STATUS)
      IF(STATUS.NE.0)RETURN
      CALL MO_READ_EMP_VELS(PLV_PTR,NVELPTS,STATUS)
      IF(STATUS.NE.0)RETURN
      CALL MO_CLEANUP_STRING(MO_NAME)
      MO_NAME2=MO_NAME
C
C GET X AND Y  LIMITS
C REMEMBER TRUE ELEVATION, SO YMIN IS DEEPEST
C
      CALL MINMAX(NPTS,XBUF,XMIN,XMAX)
      CALL MINMAX(NPTS,YBUF,YMIN,YMAX)
      SHIFT = LOG_START 
      IMAX = -YMIN + SHIFT
C
      IF(-YMAX+SHIFT .LT. 10.0) THEN
         CALL WIGALERT(1,'MO_TIE_SONICS',
     X'The top layer must be at least 10 feet below the top of the logs.
     x','Change the cross section or delete top TABLE.')
         STATUS=1
         RETURN
      ENDIF
C
C ADJUST EVERYTHING TO DEPTH FROM DATUM SO WE CAN HANDLE IT
C
C INPUT Y IS NEGATIVE DEPTH FROM 
C ADJUST X SO ALL ROWS ARE REFERENCED FROM 0
C
      DO 140 JK = 1 , NPTS
       XBUF(JK)=XBUF(JK)-XMIN
140   YBUF(JK)=-YBUF(JK) + SHIFT
C
      DO 141 JK = 1 , NVELPTS
       XVEL(JK)=XVEL(JK)-XMIN
141   YVEL(JK)=-YVEL(JK) + SHIFT
C
C FIND SHORTEST LAYER IN X DIRECTION
C
      SHORTEST_LAYER = 1.0E+31
      DO 160 JK = 1 , NLAY
        IF(JK.EQ.1)THEN
            IFIRST = 1
        ELSE
            IFIRST = LAYERS(JK-1)+1
        ENDIF
        WIDTH_IN_X = (XBUF(LAYERS(JK)) - XBUF(IFIRST))
        IF(WIDTH_IN_X.LT.SHORTEST_LAYER)SHORTEST_LAYER = WIDTH_IN_X
160   CONTINUE
C
C COLLECT WELL INFORMATION
C
C
C HOW MANY LOGS
C
      NLOGS = MOG_LLCOUNT(E_LISTHEAD_UWIS)
C
C GET FIRST UWI
C
      CALL MOG_LLFIRST(E_LISTHEAD_UWIS,UWIX)
C
C PROCESS ALL WELLS
C
      DIF = 1.0E+30
      DO 190 I = 1 , NLOGS
          WELLS(I)=UWI
          STRING = 'Retreiving well information for well - '//UWI
     X             //'.'
          CALL AMG_MESSAGE(AM_DIALOG,STRING)
          CALL MO_CLEANUP_STRING(WELLS(I))
          XPOS (I)=XPOSITION-XMIN
          CALL SYN_GETWELL(WELLS(I),WELLNM,OPER,STATE,COUNTY,IEKBS(I),
     X                     ITSH,TSHPD,IRNG,RANGD,ISEC,ICANCEL)
          IF(ICANCEL.NE.0)THEN
               STRING = 'Unable to retrive well information for well '
     X         //WELLS(1)//'.'
               CALL WIGALERT(1,'MO_TIE_CALC',STRING,
     X                   'Check the data base entry for this well.')
               STATUS=1
               STRING=' '
               CALL AMG_MESSAGE(AM_DIALOG,STRING)
               RETURN
          ENDIF
C
          IF(I.GT.1)THEN
              XDIF=XPOS(I)-XPOS(I-1)
              IF(XDIF.LT.DIF)DIF=XDIF
          ENDIF
          IF(I.LT.NLOGS)CALL MOG_LLNEXT(E_LISTHEAD_UWIS,UWIX)
190   CONTINUE
C
C GET NUMBER OF TRACES
C
C
      IF(SHORTEST_LAYER.NE. 0.0)THEN
          MIN_TRACES = (XMAX - XMIN) / (SHORTEST_LAYER*0.3334) + 2.0
      ELSE
          MIN_TRACES = MAX_NODES
      ENDIF
      MAX_TRACES = MAX_NODES / NLAY
      IF(MIN_TRACES.GT.MAX_TRACES)THEN
         CALL WIGALERT(1,'HELP',
     X   'The shortest layer in the model is too short to process.',
     X   'Elongate or delete any trivial layers.')
         STATUS = 1
         RETURN
      ENDIF
C
      STRING='Enter the number of seismic traces you wish to generate.'
      IDEFAULT = (NLOGS-1)*10+1
      IF(IDEFAULT.LT.MIN_TRACES)IDEFAULT=MIN_TRACES
      CALL WIGRQINT(STRING,HELP,MIN_TRACES,MAX_TRACES,
     X             IDEFAULT,NTRCES,STATUS)
C
      IF(STATUS.NE.0)THEN
            STRING=' '
            CALL AMG_MESSAGE(AM_DIALOG,STRING)
            RETURN
      ENDIF
C
C CALCULATE TRACE INCREMENT
C
      TRINC = (XMAX-XMIN) / (NTRCES-1.0)
C
C CALCULATE TRACE ORIGINS OF ANY WELLS
C
      DO 195 JK = 1 , NLOGS
195   IOR(JK) = XPOS(JK)/TRINC + 1.5
C
C FIT ROWS TO A TRACE SPACING INTERVAL
C
      CALL MO_FIXLAY(TRINC,NTRCES,NLAY)
C
C SORT LAYER DATA
C
      CALL MO_SORT_LAYERS(NTRCES,NLAY,STATUS)
      IF(STATUS.NE.0)RETURN
C
C
      CALL MO_ASSIGN_VELS(NTRCES,NLAY,XMAX,TRINC,
     X NVELPTS,IMAX,IFDEN,STATUS)
      IF(STATUS.NE.0)RETURN
C
C WRITE OUT WELL NUMBERS, NUMBER OF LOGS, DATUM, NUMBER OF TRACES, NUMBER
C OF LAYERS, AND ORIGINS OF EACH WELL
C
C 01/03/89 GS - use new function for getting unique temp filename
      CALL HOG_GET_UNIQUE_FILENAME( TIE_FILE )
C      TIE_FILE = 'MO_EMP'
C      CALL MO_GETVERS(TIE_FILE)
      CALL HOGFNT(IUNIT)
      OPEN(IUNIT,FILE=TIE_FILE,STATUS='NEW',IOSTAT = ISTAT,
     X FORM='UNFORMATTED')
      IF(ISTAT.NE.0)THEN
            CALL WIGALERT(1,'MO_CALC_EMP','Unable to open emp file.',
     X                     TIE_FILE)
            STATUS=1
            STRING=' '
            CALL AMG_MESSAGE(AM_DIALOG,STRING)
            RETURN
      ENDIF
C
C INQUIRE FILE NAME, ON PRIME IT WILL BE THE SAME
C ON VAX VERSION NUMBER IS APPENDED
      INQUIRE(IUNIT,NAME=TIE_FILE)
C
C
      IDATUM = DABS(LOG_START)+.002
      IF(LOG_START .LT.0.0)IDATUM = -IDATUM
C
      WRITE(IUNIT)NLOGS
C
C  NO VERTICAL VEL INTERPOLATION YET, BUT WRITE IT OUT ANYWAY
C
      WRITE(IUNIT)(WELLS(I),I=1,NLOGS),IDATUM,IMAX,NTRCES,NLAY,IFDEN,
     X NVELPTS,(IOR(I),I=1,NLOGS)
C
C WRITE OUT THE FIGURED LAYERS FOR ALL TRACES
C
      NODES = NTRCES*NLAY
      WRITE(IUNIT)(YOUT(I),I=1,NODES)
      WRITE(IUNIT)(XVEL(I),I=1,NVELPTS)
      WRITE(IUNIT)(YVEL(I),I=1,NVELPTS)
      WRITE(IUNIT)(HVEL(I),I=1,NVELPTS)
      WRITE(IUNIT)(HDEN(I),I=1,NVELPTS)
      WRITE(IUNIT)(VVEL(I),I=1,NVELPTS)
      WRITE(IUNIT)(VDEN(I),I=1,NVELPTS)
C
C REMOVE FICT VALUES
C
      CALL MO_REMOVE_FICT(NTRCES,NLAY)
C
C BUILD THE SONIC LOGS
C
      DO 200 JK = 1 , NTRCES
C
C
      WRITE(STRING,4343)JK,NTRCES
4343  FORMAT('Constructing sonic ',I5,' of ',I5,'.')
      CALL STRN2B(STRING)
      CALL AMG_MESSAGE(AM_DIALOG,STRING)
      ICUR = 2
          DO 300 JJ = 1 , NLAY
C
C IPREV AND ICUR = DEPTH RANGE FOR THIS LAYER
C
          IPREV=ICUR
          ICUR = MO_GETDEP(JK,JJ,NTRCES)+.001
C
C BUILD VEL LOG
C
C JK IS TRACE NUMBER
C JJ IS LAYER NUMBER
C
          TOP_VEL = MO_GET_VD(HVEL,JK,JJ,NTRCES,TRINC)
          BOT_VEL = MO_GET_VD(VVEL,JK,JJ,NTRCES,TRINC)
          CALL MO_EMP_BUILD_LOG(VEL,TOP_VEL,BOT_VEL,IPREV,ICUR,LAST)
C
C BUILD DEN LOG
C
          IF(IFDEN.EQ.0)GOTO 300
          TOP_DEN = MO_GET_VD(HDEN,JK,JJ,NTRCES,TRINC)
          BOT_DEN = MO_GET_VD(VDEN,JK,JJ,NTRCES,TRINC)
          CALL MO_EMP_BUILD_LOG(DEN,TOP_DEN,BOT_DEN,IPREV,ICUR,LAST)
300       CONTINUE
C
C FINISH OUT TO IMAX
C
          DO 350 JJ = LAST+1,IMAX/2
          VEL(JJ)=VEL(LAST)
          IF(IFDEN.EQ.1)DEN(JJ)=DEN(LAST)
350       CONTINUE
C
C CONVERT VELOCITY LOG TO SONIC LOG
C
          DO 360 JJ = 1,IMAX/2
          IF(VEL(JJ).EQ.0.0)VEL(JJ)=40.0
          VEL(JJ)=1000000./VEL(JJ)
360       CONTINUE
C
C WRITE OUT SONIC LOG
C
      WRITE(IUNIT)(VEL(I),I=1,IMAX/2)
      IF(IFDEN.EQ.1)WRITE(IUNIT)(DEN(I),I=1,IMAX/2)
200   CONTINUE
C
      CLOSE(IUNIT)
      STRING=' '
      CALL AMG_MESSAGE(AM_DIALOG,STRING)
      RETURN
      END




      REAL*4 FUNCTION  MO_GET_VD(VEL_OR_DEN,ITRACE,LAYER,NTRCES,
     X        TRINC)
C **************************************************************************
C
C RETURNS THE VELOCITY OF DENSITY FOR TRACE NUMBER "ITRACE", FOR LAYER
C NUMBER "LAYER"
C
C NTRCES = TOTAL NUMBER OF TRACES I THE MODEL
C TRINC  = TRACE SPACING INCREMENT
C **************************************************************************

      INCLUDE 'mo_modcom.i'
C
      REAL*4 VEL_OR_DEN(1)
      NVAL = 0
C
C EXTRACT REAL DATA VALUES FROM ARRAY
C
      DO 100 JK = LAYERS_PTRS(LAYER),
     X            LAYERS_PTRS(LAYER)+LAYERS_NVELPTS(LAYER)-1
C
            IF(VEL_OR_DEN(JK).EQ.0.0)GOTO 100
            NVAL = NVAL+1
            GETVD_X(NVAL)=XVEL(JK)
            GETVD_VALUE(NVAL)=VEL_OR_DEN(JK)
100   CONTINUE
C
C IF NONE FOUND RETURN 0.0
C
      IF(NVAL.EQ.0)THEN
            MO_GET_VD=0.0
            RETURN
      ENDIF
C
C
C RETURN ONLY VALUE IF JUST 1
C
      IF(NVAL.EQ.1)THEN
            MO_GET_VD = GETVD_VALUE(1)
            RETURN
      ENDIF
C
C CALCULATE X POSITION
C
      X_POSITION = (ITRACE-1) * TRINC
C
C IF TO LEFT OF FIRST ONE RETURN FIRST ONE
C
      IF(X_POSITION .LE. GETVD_X(1))THEN
            MO_GET_VD = GETVD_VALUE(1)
            RETURN
      ENDIF
C
C IF TO RIGHT OF LAST ONE RETURN LAST ONE
C
      IF(X_POSITION .GE. GETVD_X(NVAL))THEN
            MO_GET_VD = GETVD_VALUE(NVAL)
            RETURN
      ENDIF
C
C INTERPOLATE THE VALUE
C
      DO 150 JK = 2,NVAL
          IF(X_POSITION.LT.GETVD_X(JK))GOTO 200
150   CONTINUE
C
200   SLOPE = (GETVD_VALUE(JK)-GETVD_VALUE(JK-1)) /
     X        (GETVD_X(JK) - GETVD_X(JK-1))
      CONST = GETVD_VALUE(JK) - SLOPE * GETVD_X(JK)
      MO_GET_VD = SLOPE * X_POSITION + CONST
      RETURN
      END




      SUBROUTINE MO_EMP_BUILD_LOG(LOG,TOP,BOT,ISTART,IEND,LAST)
C *********************************************************************
C FILL THE LOG WITH CORRECT VEL / DEN VALUES
C
C LOG = ARRAY OF LOG VALUES
C TOP = VALUE AT TOP OF LAYER
C BOT = VALUE AT BOTTOM OF LAYER
C ISTART = START DEPTH
C IEND   = END DEPTH
C LAST   = LAST SUBSCRIPT FILLED IN
C *********************************************************************

      INCLUDE 'mo_modcom.i'
C
      REAL*4 LOG(1)
      LAST = IEND/2
C
C CHECK FOR NULL LAYER
C
      IF(ISTART.EQ.IEND)RETURN
C
C DETERMINE SUBSCRIPTS
C
      I1 = ISTART/2
      I2 = IEND/2
C
C IF SAME, JUST SET VALUE TO TOP
C
      IF(I1.EQ.I2)THEN
           LOG(LAST)=TOP
           RETURN
      ENDIF
C
C IF BOT IS NULL, SET TO TOP
C
      IF(BOT.EQ.0.0)BOT = TOP
C
C INCREMENT OF Y PER SAMPLE
C
      YINC = (BOT - TOP) / (I2-I1)
C
C FILL UP LOG
C
      DO 300 JK = I1,I2
      LOG(JK) = TOP + (I1-JK) * YINC
300   CONTINUE
      RETURN
      END
