C  DEC/CMS REPLACEMENT HISTORY, Element MO_TIE_SON.FOR
C  *8     1-MAR-1990 17:19:30 GILLESPIE "(SPR 1) Remove unused variables"
C  *7     6-NOV-1989 16:49:26 GILLESPIE "(SPR 30) Get 'glue' entry points straightened out"
C  *6     6-NOV-1989 14:05:01 GILLESPIE "(SPR 30) Fix bad typing"
C  *5     6-NOV-1989 09:59:43 GILLESPIE "(SPR 30) Change mog*resource to amg*resource"
C  *4     6-NOV-1989 09:05:00 PURNA "(SPR 30) fix mo_ calls to mog_"
C  *3     3-NOV-1989 12:02:48 GILLESPIE "(SPR 30) Change entry points for new n-List nomenclature"
C  *2    19-SEP-1989 10:15:02 GORDON "(PURNA) GULF MODS UNDER SPR 100"
C  *1    10-AUG-1989 18:50:01 VINCE "Fortran code after UNIX mods"
C  DEC/CMS REPLACEMENT HISTORY, Element MO_TIE_SON.FOR
C******************************************************************************
C
C                Copyright Exploration Systems, Inc. 1989
C		   Unpublished -- All rights reserved
C
C THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Exploration Systems, Inc AND MAY
C CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE
C DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE
C MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF
C
C			Exploration Systems, Inc.
C			579 Market Street
C			San Francisco, CA  USA 94105
C			(415) 974-1600
C
C (The above notice does not constitute an admission of publication or
C unrestricted dissemination of the work)
C
C******************************************************************************
C
      SUBROUTINE MO_TIE_SONICS(PL_PTR,MO_PTR,MO_NAME2,
     X   TIE_FILE,STATUS)
C *****************************************************************************
C
C THIS PROGRAM ALLOWS THE USER TO GENERATE A MODEL BY TIEING TOGETHER
C THE SYNTHETIC FROM SEVERAL LOGS.  THIS IS DONE BY HANGING THE LOGS ON
C A STRUCTURAL CROSS SECTION AND HAVING THE USER CORRELATE THE LOGS.  THE
C CORRELLATION IS THEN DIGITIZED AND INPUT INTO THIS PROGRAM.  THE MODEL
C MUST BE DIGITIZED WITH TRUE ELEVATION AS THE Y SCALE.  THE CORRELATED
C LOGS ARE USED TO DETERMINE THE RATIO OF THICKENING AND THINNING OF THE ZONES
C BETWEEN LOGS AND THE SONICS ARE MODIFIED AND ADDED TOGETHER USING A WEIGHTED
C AVERAGE.
C
C
C XBUF          - INPUT ROWS, X ARRAY
C YBUF          - INPUT ROWS, Y ARRAY
C WELLS         - CURRENT LEFT AND RIGHT WELL
C IEKBS         - EKBS OF WELLS IN WELLS
C ISTV,ISTDEN   - ISTART DEPTH OF VELOCITY LOGS IN WELLS
C IENV,IENDEN   - END DEPTH OF VELOCITY LOGS IN WELLS
C IDATUM        - STARTING DEPTH OF SHALLOWEST LOG (TOP OF MODEL)
C IMAX          - TOTAL DEPTH FROM TOP TO BOTTOM OF MODEL
C IOR           - TRACE UPON WHICH WELLS IN WELLS FALL,
C                 WELL X SNAPS TO NEAREST TRACE.
C
C
C PLFILE        - N-LIST FILE NAME
C STATUS        - RETURN CODE, 0 = SUCCESS, 1 = FAIL
C
C *****************************************************************************

      INCLUDE 'mo_modcom.i'
      INCLUDE 'mo_struct.i'
      INCLUDE 'esi_am.i'
      INCLUDE 'esi_we_wells.i'

      CHARACTER*(*) TIE_FILE
      INTEGER*4     STATUS, DENS_TYPE, DENS_DEFAULT
      REAL*8        MO_PTR,PL_PTR
      REAL          SAMP_RATE
      CHARACTER*130 MO_NAME2

C
C WELL INFORMATION VARIABLES
C
      CHARACTER*128 STRING,HELP
      CHARACTER*(SIZEOF_UWI)    WELLS(MAX_WELLS)
      CHARACTER*(SIZEOF_WNAME)  WELLNM
      CHARACTER*(SIZEOF_OPER)   OPER
      CHARACTER*(SIZEOF_STATE)  STATE
      CHARACTER*(SIZEOF_COUNTY) COUNTY
      CHARACTER     TSHPD*2, RANGD*2

      INTEGER       IEKBS(MAX_WELLS),ISTV(MAX_WELLS),IENV(MAX_WELLS)
      INTEGER       ISTDEN( MAX_WELLS), IENDEN( MAX_WELLS)
      INTEGER       IOR(MAX_WELLS),XPOS(MAX_WELLS)
      CHARACTER*20  DEPTH_UOM,SON_CURVE_UOM,DEN_CURVE_UOM

      COMMON /DEPTH_ORIGIN/   IDEPTH_FIRST, IDEPTH_LAST
      COMMON /LOGINFO/   IMAX, IDATUM, SAMP_RATE, NUM_SAMPLES
      COMMON /UOMDATA/   DEPTH_UOM, SON_CURVE_UOM, DEN_CURVE_UOM

      DATA HELP/'MO_TIE_SONICS'/

      NPTS = 0
C
C NOW READ THE MODEL NLIST INTO FTN ARRAYS-ALSO THE SEDIMENTATION TYPE
C FROM THE TABLE USER STRUCT INTO BUFFER SEDIMENT
C
      CALL MO_READ(PL_PTR,MO_PTR,NPTS,NLAY,STATUS)
      IF(STATUS.NE.0)RETURN

      CALL MOG_GET_SED_TYPE(PL_PTR, LAYERS_SED)

      CALL MO_CLEANUP_STRING(MO_NAME)
      MO_NAME2=MO_NAME
C
C GET X AND Y  LIMITS OF MODEL HORIZONS
C REMEMBER TRUE ELEVATION, SO YMIN IS DEEPEST
C SHIFT = LOG START IS THE DEPTH OF THE TOP OF SHALLOWEST LOG IN SUBSEA ELEV.
C YMIN  = BOTTOM OF MODEL (BOTTOM OF GKS WINDOW) 
C

      CALL MINMAX(NPTS,XBUF,XMIN,XMAX)
      CALL MINMAX(NPTS,YBUF,YMIN,YMAX)
      SHIFT = LOG_START 
      IMAX = -YMIN + SHIFT

      IF(-YMAX+SHIFT .LT. 10.0) THEN
         CALL WIGALERT(1,'MO_TIE_SONICS',
     X'The top layer must be at least 10 feet below the top of the logs.
     X','Change the cross section or delete top TABLE.')
         STATUS=1
         RETURN
      ENDIF
C
C ADJUST EVERYTHING TO DEPTH FROM DATUM SO WE CAN HANDLE IT
C IE WE WANT DEPTH STARTING FROM 0 AND INCREASING DOWNWARDS
C INPUT Y IS TRUE ELEVATION
C ADJUST X SO ALL ROWS ARE REFERENCED FROM 0
C
      DO 140 JK = 1 , NPTS
        XBUF(JK)=XBUF(JK)-XMIN
140   YBUF(JK)=-YBUF(JK) + SHIFT

C
C SET DEPTH SAMPLE RATE = 2 (RATE CURRENTLY ALLOWED) AND COMPUTE THE 
C TOTAL NUMBER OF SAMPLES IN THE INTERVAL FROM THE TOP TO BOTTOM OF MODEL
C
      SAMP_RATE = 2.0
      NUM_SAMPLES = IMAX/ SAMP_RATE

C
C SET UOMS 
C
      CALL MO_CLEANUP_STRING( MO_UOM)
      IF (MO_UOM.EQ.'METERS'.OR.MO_UOM.EQ.'METRES') THEN

        DEPTH_UOM = 'METERS'
        SON_CURVE_UOM = 'USEC/M'
        DEN_CURVE_UOM = 'GR/CC'
      ELSE
        DEPTH_UOM = 'FEET'
        SON_CURVE_UOM = 'USEC/F'
        DEN_CURVE_UOM = 'GR/CC'
      ENDIF
C
C COLLECT WELL INFORMATION
C
C HOW MANY LOGS
C
      NLOGS = MOG_LLCOUNT(E_LISTHEAD_UWIS)
C
C GET FIRST UWI
C
      CALL MOG_LLFIRST(E_LISTHEAD_UWIS,UWIX)
C
C PROCESS ALL WELLS IE. EXAMINE HEADERS, ETC.
C
      DIF = 1.0E+30
      DO 350 I = 1 , NLOGS
          WELLS(I)=UWI
C         STRING = 'Retrieving well information for well - '//UWI
C    X             //'.'
C         CALL AMG_MESSAGE(AM_DIALOG,STRING)
          CALL MO_CLEANUP_STRING(WELLS(I))
          XPOS (I)=XPOSITION-XMIN
          CALL SYN_GETWELL(WELLS(I),WELLNM,OPER,STATE,COUNTY,IEKBS(I),
     X                     ITSH,TSHPD,IRNG,RANGD,ISEC,ICANCEL)
          IF(ICANCEL.NE.0)THEN
               STRING = 'Unable to retrieve well header info. for well '
     X         //WELLS(1)//'.'
               CALL WIGALERT(1,'MO_TIE_CALC',STRING,
     X            'Check the data base entry for this well.')
               STATUS=1
               STRING=' '
               CALL AMG_MESSAGE(AMG_DIALOG,STRING)
               RETURN
          ENDIF
          IF(I.GT.1)THEN
              XDIF=XPOS(I)-XPOS(I-1)
              IF(XDIF.LT.DIF)DIF=XDIF
          ENDIF
          IF(I.LT.NLOGS)CALL MOG_LLNEXT(E_LISTHEAD_UWIS,UWIX)
350   CONTINUE

C
C GET NUMBER OF TRACES
C
      MIN_TRACES = XMAX/DIF+1.0
      IF(MIN_TRACES.LT.NLOGS)MIN_TRACES=NLOGS
      MAX_TRACES = MAX_NODES / NLAY
      STRING='Enter the number of seismic traces you wish to generate.'
      IDEFAULT = (NLOGS-1)*10+1
      CALL WIGRQINT(STRING,HELP,MIN_TRACES,MAX_TRACES,
     X             IDEFAULT,NTRCES,STATUS)
C
      IF(STATUS.NE.0)THEN
            STATUS=1
            STRING=' '
            CALL AMG_MESSAGE(AM_DIALOG,STRING)
            RETURN
      ENDIF
C
C CALCULATE TRACE INCREMENT
C
      TRINC = (XMAX-XMIN) / (NTRCES-1.0)

C
C CALCULATE TRACE ORIGINS
C
      IOR(1)= 1
      DO 360 JK = 2 , NLOGS-1
360   IOR(JK)=XPOS(JK)/TRINC+ 2.
      IOR(NLOGS)= NTRCES

C
C FIT ROWS TO A TRACE SPACING INTERVAL
C
      CALL MO_FIXLAY(TRINC,NTRCES,NLAY)

C
C SORT LAYER DATA FROM TOP TO BOTTOM (COMES IN UNSORTED N-LIST)
C
      CALL MO_SORT_LAYERS(NTRCES,NLAY,STATUS)
      IF(STATUS.NE.0)RETURN

C
C WRITE OUT WELL NUMBERS, NUMBER OF LOGS, DATUM, NUMBER OF TRACES, NUMBER
C OF LAYERS, AND ORIGINS OF EACH WELL
C
C 01/03/89 GS - use new function for temp file name
      CALL HOG_GET_UNIQUE_FILENAME( TIE_FILE )
      CALL TFSTRCAT( TIE_FILE, '.DAT', TIE_FILE )
      CALL HOG_ADD_PATH( 'ESI$SCRATCH', TIE_FILE, LEN(TIE_FILE),
     +                   TIE_FILE )
      CALL HOG_TRANSLATE_FILENAME( TIE_FILE, TIE_FILE )
C
      CALL HOGFNT(IUNIT)
      OPEN(IUNIT,FILE=TIE_FILE,STATUS='NEW',IOSTAT = ISTAT,FORM=
     X     'UNFORMATTED')
C
      IF(ISTAT.NE.0)THEN
            CALL WIGALERT(1,'MO_CALC_TIE','Unable to open tie file.',
     X                     TIE_FILE)
            STATUS=1
            STRING=' '
            CALL AMG_MESSAGE(AM_DIALOG,STRING)
            RETURN
      ENDIF
C
C INQUIRE NAME TO GET VERSION ETC ON VAX
C NO CHANGE ON PRIME
C
C This shouldn't be necessary now that we've called hog_translate_filename 
C      INQUIRE(IUNIT,NAME=TIE_FILE)
C
      IDATUM = DABS(LOG_START) + .002
      IF(LOG_START .LT.0.0)IDATUM = -IDATUM
      IDEPTH_FIRST = IEKBS(1) - IDATUM
      IDEPTH_LAST  = IEKBS(NLOGS) - IDATUM
C
      WRITE(IUNIT)NLOGS

C
C HAVE DENSITY LOGS BUT NO EMPIRICAL MODELING VEL ROWS
C
      IFDEN = 1
      NVELPTS = 0
      WRITE(IUNIT)(WELLS(I),I=1,NLOGS),IDATUM,IMAX,NTRCES,NLAY,
     X  IFDEN,NVELPTS,
     X  (IOR(I),I=1,NLOGS)

C
C WRITE OUT THE FIGURED LAYERS FOR ALL TRACES
C
      NODES = NTRCES*NLAY
      WRITE(IUNIT)(YOUT(I),I=1,NODES)
      CALL MO_REMOVE_FICT(NTRCES,NLAY)

C
C REQUEST FROM USER HOW DENSITY IS TO BE CALCULATED/RETRIEVED
C

      CALL MO_GET_DENS( DENS_TYPE, CONS_DENS, DENS_DEFAULT, STATUS)
      IF ( STATUS.NE.0) THEN
        STATUS = 1
        STRING = ' '
        CALL AMG_MESSAGE( AM_DIALOG, STRING)
        RETURN
      ENDIF

C
C READ AND FIX SONIC AND DENSITY LOG 1
C
      CALL MO_READ_LOG(VEL_OR2, DEN_OR2, ISTV(1),IENV(1),
     X                  ISTDEN(1), IENDEN(1), WELLS(1),
     X                  IEKBS(1), CONS_DENS,
     X                  DENS_TYPE, DENS_DEFAULT,  STATUS)

      IF(STATUS.EQ.1)THEN
            STRING=' '
            CALL AMG_MESSAGE(AM_DIALOG,STRING)
            CLOSE(IUNIT,STATUS='DELETE')
            RETURN
      ENDIF


C
C
C OUTER LOOP TO BUILD THE NEW SONIC AND DENSITY LOGS
C
      NTR=0

      DO 200 JK = 1 , NLOGS-1

C
C MOVE VEL_OR2 TO VEL_OR1 AND DEN_OR2 TO DEN_OR1
C
      DO 210 I = 1,IENV(JK) / SAMP_RATE
210   VEL_OR1(I)=VEL_OR2(I)

      DO 212 I = 1, IENDEN(JK) / SAMP_RATE
212   DEN_OR1(I) = DEN_OR2(I)


C
C READ NEXT SONIC LOG AND READ OR CALCULATE CORRESPONDING DENSITY LOG
C 

      CALL MO_READ_LOG(VEL_OR2, DEN_OR2, ISTV(JK+1), IENV(JK+1),
     X            ISTDEN(JK+1), IENDEN(JK+1), WELLS(JK+1) ,IEKBS(JK+1), 
     X            CONS_DENS, DENS_TYPE, DENS_DEFAULT, STATUS)

      IF(STATUS.EQ.1)THEN
            STRING=' '
            CALL AMG_MESSAGE(AM_DIALOG,STRING)
            CLOSE(IUNIT,STATUS='DELETE')
            RETURN
      ENDIF

C
C ITR1 IS FIRST TRACE
C ITR2 IS LAST TRACE FOR THIS LOG SET
C
      ITR1=IOR(JK)
      ITR2=IOR(JK+1)-1
      IF(JK.EQ.NLOGS-1)ITR2=ITR2+1
C
C NORMP1 - NUMBER OF LOGS GENERATED FROM FIRST SONIC ONLY (ALWAYS 1)
C NRAMP  - NUMBER OF LOGS RAMPED TOGETHER FROM BOTH SONICS
C NORMP2 - NUMBER OF LOGS GENERATED FROM SECOND SONIC ONLY (1 OR 0)
C
      NORMP1=1
      NRAMP = (ITR2-ITR1)
      IF(JK.EQ.NLOGS-1)NRAMP=NRAMP-1
      NORMP2=0
      IF(JK.EQ.NLOGS-1)NORMP2=1


C
C LOOP ON NUMBER OF TRACES IN BETWEEN LOGS
C

      DO 555 II=ITR1,ITR2
      JJ=II-ITR1+1
      NTR=NTR+1


C
C FIRST CALCULATE THE SONIC TRACE
C

      WRITE(STRING,4343)NTR,NTRCES
4343  FORMAT('Constructing sonic ',I5,' of ',I5,'.')
      CALL STRN2B(STRING)
      CALL AMG_MESSAGE(AM_DIALOG,STRING)
C
C WELL 1 ONLY
C
      IF(JJ.LE.NORMP1+NRAMP) CALL MO_NEWLOG(VEL_OR1, VEL_LOG1,
     X   SAMP_RATE, NLAY, NTR, NTRCES,  JMAX1,IENV(JK),
     X   IOR(JK), LAYERS_SED)
C
C WELL 2 ONLY
C
      JMAX2 = 0
      IF(JJ.GT.NORMP1) CALL MO_NEWLOG(VEL_OR2, VEL_LOG2, SAMP_RATE,
     X       NLAY, NTR,NTRCES, JMAX2, IENV(JK+1),IOR(JK+1), LAYERS_SED)

C
C MERGE AND STUFF AS REQURED
C
      CALL MO_MERSTF(VEL_LOG1, VEL_LOG2, VEL, NORMP1, NORMP2,
     X               NRAMP, JJ, IMAX, JMAX1, JMAX2)

C
C WRITE OUT SONIC LOG
C
      WRITE(IUNIT)(VEL(I),I = 1, NUM_SAMPLES)



C
C NOW GET/CALCULATE THE DENSITY TRACE ACCORDING TO METHOD SELECTED
C

      WRITE(STRING,4344)NTR,NTRCES
4344  FORMAT('Constructing density ',I5,' of ',I5,'.')
      CALL STRN2B(STRING)
      CALL AMG_MESSAGE(AM_DIALOG,STRING)


      IF (DENS_TYPE.NE.3) THEN
C
C USING DENSITY LOG RECALLED FROM DATABASE
C

C WELL 1 ONLY

      IF(JJ.LE.NORMP1+NRAMP) CALL MO_NEWLOG(DEN_OR1, VEL_LOG1,
     X                          SAMP_RATE, NLAY, NTR, NTRCES,  JMAX1,
     X                          IENDEN(JK), IOR(JK), LAYERS_SED)

C WELL 2 ONLY

      IF(JJ.GT.NORMP1) CALL MO_NEWLOG(DEN_OR2, VEL_LOG2, SAMP_RATE,
     X                        NLAY, NTR, NTRCES, JMAX2, IENDEN(JK+1),
     X                        IOR(JK+1), LAYERS_SED)

C MERGE AND STUFF AS REQURED

      CALL MO_MERSTF(VEL_LOG1, VEL_LOG2, VEL, NORMP1, NORMP2,
     X                              NRAMP, JJ, IMAX, JMAX1, JMAX2)


      ELSE 
C
C USE A CONSTANT DENSITY VALUE AS SET BY USER
C

        DO 400  I = 1, NUM_SAMPLES
400     VEL(I) = CONS_DENS        
      ENDIF
    
C
C WRITE OUT DENSITY LOG
C
      WRITE(IUNIT) (VEL(I),I=1 , NUM_SAMPLES)


555   CONTINUE

200   CONTINUE
      CLOSE(IUNIT)
      STRING=' '
      CALL AMG_MESSAGE(AM_DIALOG,STRING)
      RETURN
      END





      SUBROUTINE MO_NEWLOG(VELIN, VELOUT, SAMP_RATE, NLAY,
     X                     ITR, NTR, JMAX, IENV, IOR, SEDIMENT)

C***********************************************************************
C
C   ROUTINE:     MO_NEWLOG
C
C   FUNCTION:    TAKE TRACE VELIN (ACTUAL SONIC LOG TRACE) AND CREATE
C                A NEW TRACE TRACE NUMBER ITR. THE METHOD IN WHICH THE
C                NEW TRACE IS CREATED DEPENDS ON THE SEDIMENTATION TYPE.
C                IF NORMAL, THE VELIN TRACE IS STRETCHED OR SQUEEZED TO 
C                FIT THE LAYER THICKNESS AT TRACE ITR.  IF ONLAP OR OFFLAP
C                VELIN IS COPIED DIRECTLY TO VELOUT EITHER FROM THE TOP 
C                SAMPLE OF THE LAYER DOWN OR THE BOTTOM SAMPLE OF THE LAYER
C                UP (IF THE LAYER THICKNESS AT ITR IS GREATER THAN THE 
C                THICKNESS AT VELIN THEN THE REMAINING SAMPLES ARE SET=0.0)
C
C VELIN           - (INPUT) SONIC LOG
C VELOUT          - (OUTPUT) MODIFIED SONIC LOG
C SAMP_RATE       - DEPTH SAMPLE RATE
C NLAY            - NUMBER OF LAYERS
C ITR             - NUMBER OF TRACE BEING GENERATED
C NTR             - TOTAL NUMBER OF TRACES
C JMAX            - MAX DEPTH FOR THIS LOG
C IENV            - MAX DEPTH IN VELOCITY LOG
C IOR             - ORIGIN TRACE OF THIS TRACE
C SEDIMENT        - BUFFER OF SEDIMENTATION TYPE ( = 1,2,OR 3)
C
C ISO             - START DEPTH OF OLD LOG FOR EACH LAYER
C IEO             - END DEPTH OF OLD LOG FOR EACH LAYER
C ISN             - START DEPTH OF NEW LOG FOR EACH LAYER
C IEN             - END DEPTH OF NEW LOG FOR EACH LAYER
C OLD             - NUM. OF SAMPLES IN THE LAYER AT THE SONIC POSITION(OLD LOG)
C NEW             - NUMBER OF SAMPLES IN THE LAYER AT TRACE ITR (NEW LOG)
C
C ***************************************************************************

      REAL    VELIN(*),VELOUT(*)
      INTEGER SEDIMENT(*)
      REAL    MO_GETDEP
      INTEGER OLD

      IEO = SAMP_RATE
      NEW = 1
      IEN = SAMP_RATE

C
C LOOP THROUGH LAYERS 
C

      DO 100 JK = 1 , NLAY
      ISO=IEO
      IF (ISO.GT.IENV) GOTO 100
      IEO=MO_GETDEP(IOR,JK,NTR)+.001
C
C ALWAYS BE EVEN TO FALL ON EVEN SUBSCRIPT(!!ONLY FOR SAMP_RATE = 2!!)
C
      IF( (-1) ** IEO. LT. 0) IEO=IEO-1
C
C END CANNOT BE GREATER THAN WHAT IS THERE
C
      IF(IEO.GT.IENV)IEO=IENV
      ISN=IEN
C
C IF ORIGIN TRACE, NEW END IS OLD END
C
      IF(ITR.NE.IOR)THEN
        IEN=MO_GETDEP(ITR,JK,NTR) +.001
      ELSE
        IEN=IEO
      ENDIF
      IF( (-1) ** IEN .LT. 0) IEN=IEN-1
C
C THIS LAYER UNDEFINED FOR  TRACE?
C
      IAA=1
      IF(ISN.EQ.IEN)GOTO 50
C
C
C GET NUMBER OF SAMPLES IN LAYER AT VELIN AND AT TRACE ITR
C
      IA = (IEO-ISO)/SAMP_RATE + 1
      IAA= (IEN-ISN)/SAMP_RATE + 1
      OLD = ISO / SAMP_RATE
C
C CALCULATE NEW TRACE ACCORDING TO SEDIMENTATION TYPE
C

      IF ( ISO.EQ.IEO) THEN
         DO 345 IP = NEW,NEW+IAA-1
345      VELOUT(IP) = 0.0

C
C  NORMAL SEDIMENTATION (TYPE 1) -STRETCH/SQUEEZE SONICS
C

      ELSEIF (SEDIMENT(JK).EQ.1) THEN
         CALL LAG(VELIN( INT(ISO / SAMP_RATE) ),IA,VELOUT(NEW),IAA)
C
C  UNCONFORMITY (TYPE 2) -BUILD NEW SONIC FROM LOWER LAYER ON UP
C
      ELSEIF (SEDIMENT(JK).EQ.2) THEN
         ICOUNT = 0
         DO 402 IP = NEW + IAA -1 , NEW, -1
          ICOUNT = ICOUNT + 1
          IF (ICOUNT. GT. IA) THEN
            VELOUT(IP) = 0.0
          ELSE
            VELOUT(IP) = VELIN( OLD + IA - ICOUNT)
          ENDIF
402      CONTINUE

C
C ONLAP (TYPE 3) BUILD NEW SONIC FROM UPPER LAYER ON DOWN
C
      ELSEIF (SEDIMENT(JK).EQ.3) THEN
         ICOUNT = 0
         DO 400 IP = NEW, NEW + IAA - 1, 1
          ICOUNT = ICOUNT + 1
          IF (ICOUNT. GT. IA) THEN
            VELOUT(IP) = 0.0
          ELSE
            VELOUT(IP) = VELIN( OLD + ICOUNT - 1)
          ENDIF
400      CONTINUE

    
      ENDIF


C
C STRAIGHT LINE VALUES ABOVE FIRST CORRELLATION LINE
C
50    CONTINUE
      IF(JK.EQ.2)THEN
           DO 23456 IP = 1 , NEW-1
23456      VELOUT(IP)=VELOUT(NEW)
      ENDIF
      NEW=NEW+IAA-1
100   CONTINUE
C
C STRAIGHT LINE VALUES BELOW LAST CORRELLATION LINE
C
      NLEFT=(IENV-IEO) / SAMP_RATE
      DO 200 JK = NEW+1,NEW+NLEFT
200   VELOUT(JK)=VELOUT(NEW)
      IF (NLEFT.GE.1) NEW = NEW + NLEFT
      JMAX = NEW * SAMP_RATE
      RETURN
      END





      SUBROUTINE MO_MERSTF(ARRAY1, ARRAY2, ARRAY3, NORMP1,NORMP2,NRAMP,
     X                     ITR,IMAX,JMAX1,JMAX2)
C **************************************************************************
C
C THIS SUBROUTINE WILL MERGE THE TWO NEWLY GENERATED SONIC LOGS INTO ONE
C BY SUMMING AND MULTIPLYING BASED ON A WEIGHTED AVERAGE.
C
C ARRAY1     - STRETCHED/SQUEEZED DATA FROM 1ST WELL
C ARRAY2     - STRETCHED/SQUEEZED DATA FROM 2ND WELL
C ARRAY3     - OUTPUT DATA FROM MERGE PROCESS
C NORMP1     - NUMBER OF TRACES USING ONLY LOG 1
C NRAMP      - NUMBER OF TRACES USING BOTH LOGS
C NORMP2     - NUMBER OF TRACES USING ONLY LOG 2
C ITR        - NUMBER OF TRACE BEING GENERATED
C IMAX       - MAX DEPTH OF ALL LOGS
C NSAMP_MAX  - SAMPLE NUMBER CORRESPONDING TO MAX DEPTH OF ALL LOGS
C SAMP_RATE  - SAMPLE RATE OF LOGS (IN DEPTH)
C JMAX1      - MAX DEPTH OF FIRST LOG
C JMAX2      - MAX DEPTH OF SECOND LOG
C
C **************************************************************************

      REAL     ARRAY1(*), ARRAY2(*), ARRAY3(*)
      REAL     SAMP_RATE
      INTEGER  NSAMP_MAX

      INCLUDE 'mo_modcom.i'

      SAMP_RATE = 2.0
      NSAMP_MAX = IMAX / SAMP_RATE

C
C STRAIGHT LINE VALUES DOWN TO MAX DEPTH
C

      DO 10 JK = JMAX1 / SAMP_RATE + 1, NSAMP_MAX
10    ARRAY1(JK) = ARRAY1( INT(JMAX1 / SAMP_RATE) )

      DO 30 JK = JMAX2 / SAMP_RATE + 1, NSAMP_MAX
30    ARRAY2(JK) = ARRAY2( INT(JMAX2 / SAMP_RATE) )

C
C IF ONLY LOG 1, STUFF AND RETURN
C
      IF(ITR.LE.NORMP1)THEN
           DO 60 JK = 1, NSAMP_MAX
60         ARRAY3(JK) = ARRAY1(JK)
           GO TO 999
      ENDIF

C
C IF ONLY LOG 2 STUFF AND RETURN
C
      IF(ITR.GT.NORMP1+NRAMP)THEN
           DO 70 JK = 1 , NSAMP_MAX
70         ARRAY3(JK) = ARRAY2(JK)
           GOTO 999
      ENDIF
C
C MERGE AND STUFF
C
C CALCULATE WEIGHTS D1 AND D2
C
C
      IRAMP= ITR-NORMP1
      D2=FLOAT(IRAMP)/FLOAT(NRAMP+1)
      D1=FLOAT(NRAMP-IRAMP+1)/FLOAT(NRAMP+1)

      DO 80 JK = 1 , NSAMP_MAX

      IF (ARRAY1(JK).EQ.0.0.AND.ARRAY2(JK).EQ.0.0)THEN
         IF(JK.GT.1)THEN
            ARRAY1(JK) = ARRAY1(JK-1)
            ARRAY2(JK) = ARRAY2(JK-1)
         ELSE
            ARRAY1(JK) = 100.0
            ARRAY2(JK) = 100.0
         ENDIF
      ENDIF

      IF (ARRAY1(JK).EQ.0.0) ARRAY1(JK) = ARRAY2(JK)
      IF (ARRAY2(JK).EQ.0.0) ARRAY2(JK) = ARRAY1(JK)
80    ARRAY3(JK) = D1 * ARRAY1(JK) + D2 * ARRAY2(JK)

999   RETURN
      END




      SUBROUTINE MO_FIXCUR(ARRAY, IST,IEN,IDATUM,IEKB,
     X                     IMAX, VNULL, SAMP_RATE)
C ***************************************************************************
C
C   ROUTINE:    MO_FIXCUR
C
C   FUNCTION:   TO SHIFT DATA SO THAT WELL ARRAY SUBSCRIPTS (CORRESPONDING
C               TO DEPTH SAMPLES) ARE IN THE CORRECT POSITION RELATIVE
C               TO DATUM. ALSO EXTEND FIRST LIVE VALUE TO BEGINNING OF ARRAY
C               AND REMOVE NULL VALUES.
C 
C   ARRAY       - INPUT/OUTPUT ARRAY OF LOG DATA
C   IST         - START DEPTH OF CURVE IN VEL_OR2
C   IEN         - END DEPTH OF CURVE IN VEL_OR2
C   SAMP_RATE   - DEPTH SAMPLE RATE OF LOG
C
C ***************************************************************************

      REAL ARRAY(*)

      INCLUDE 'mo_modcom.i'
C
C NPTS = NUMBER OF ROWS IN INPUT LOG
C
      NPTS =(IEN-IST) / SAMP_RATE + 1
C
C    COMPUTE THE TOTAL SHIFT SO THAT THE ARRAY START AT THE DATUM
C
      NSHIF = ( IST + IDATUM - IEKB ) / SAMP_RATE
C
      NMAX = IMAX / SAMP_RATE
      CALL ARRAY_SHIFT ( ARRAY, NSHIF, NPTS, NMAX, ARRAY(1),
     X		      NUM_SAMPLES, ISTAT)
C	DEFINE THE NEW FINAL DEPTH 
C
      IEN = NUM_SAMPLES * SAMP_RATE

C
C GET OUT NULL VALUES
C

      CALL MO_FIXCUR2(ARRAY, NUM_SAMPLES, VNULL)
      RETURN
      END




      SUBROUTINE MO_FIXCUR2(ARRAY,NEWSP,VNULL)
C **************************************************************************
C
C FUNCTION:   TO GET RID OF NULL VALUES BY EXTRAPOLATING FIRST OR LAST 
C             VALUES (IF NULLS OCCUR BEFORE FIRST OR AFTER LAST SUBSCRIPT), 
C             OR INTERPOLATING BETWEEN LIVE SAMPLES. 
C
C ARRAY - ARRAY CONTAINING LOG CURVE
C NEWSP - NUMBER OF ROWS IN ARRAY
C VNULL - ARRAY NULL VALUE
C
C **************************************************************************

      REAL ARRAY(*)
C
C FIND FIRST NON NULL VALUE
C
      IFOUND = 0
      DO 300 JK = 1 , NEWSP
      IF( ABS( ARRAY(JK) - VNULL ) .GT. .0001)THEN
           IFOUND = JK
           GOTO 301
      ENDIF
300   CONTINUE
C
C IF ALL NULL JUST RETURN
C
301   IF(IFOUND.EQ.0)RETURN
C
C FILL FRONT NULLS WITH FIRST REAL VALUE
C
      DO 310 JK = 1,IFOUND-1
310   ARRAY(JK) = ARRAY(IFOUND)
C
C FILL BACK END NULLS WITH LAST REAL VALUE
C
      DO 320 JK = NEWSP,1,-1
      IF( ABS( ARRAY(JK) - VNULL ) .GT. .0001)THEN
            IFOUND = JK
            GOTO 321
      ENDIF
320   CONTINUE
321   CONTINUE
      DO 330 JK = IFOUND+1,NEWSP
330   ARRAY(JK) = ARRAY(IFOUND)
C
C INTERPOLATE ALL NULL RANGES
C
      ISTART = 1
400   IFOUND = 0
C
C FIND FIRST NULL VALUE
C
      DO 420 JK = ISTART,NEWSP
      IF( ABS( ARRAY(JK) - VNULL ) .LE. .0001)THEN
           IFOUND = JK
           GOTO 421
      ENDIF
420   CONTINUE
C
C IF NONE FOUND, ALL DONE
C
421   IF(IFOUND.EQ.0)GOTO 9999   
C
C FIND NEXT NON NULL VALUE
C
      DO 450 JK = IFOUND,NEWSP
      IF( ABS( ARRAY(JK) - VNULL ) .GT. .0001)THEN
          IFOUND2 = JK
          GOTO 451
      ENDIF
450   CONTINUE
C
C INTERPOLATE IT
C
451   DX = (ARRAY(IFOUND2) - ARRAY(IFOUND-1)) / (IFOUND2-IFOUND+1)
      DO 460 JK = IFOUND,IFOUND2-1
460   ARRAY(JK)=ARRAY(JK-1) + DX
      ISTART = IFOUND2
      GOTO 400
C
9999  RETURN
      END





      SUBROUTINE MO_READ_LOG(SON_ARRAY, DENS_ARRAY, ISTV, IENV,
     X                       ISTDEN, IENDEN, WELL, IEKB, CONS_DENS,
     X                       DENS_TYPE, DENS_DEFAULT, STATUS)
C***********************************************************************
C
C  FUNCTION:   READ SONIC LOG AND READ OR CALCULATE DENSITY LOG FOR
C              TIE MODEL.  IF MORE THAN ONE SONIC OR DENSITY AVAILABLE
C              FOR THIS PARTICULAR UWI THEN BRING UP A SELECTOR BOX AND
C              GET A USER SELECTION. 
C
C***********************************************************************


      REAL    SON_ARRAY(*), DENS_ARRAY(*)
      INTEGER STATUS
      INTEGER DENS_FLAG, DENS_TYPE, DENS_DEFAULT
      CHARACTER*(*)WELL, STRING*128, SQL*255
      CHARACTER*20  DEPTH_UOM,SON_CURVE_UOM,DEN_CURVE_UOM
      CHARACTER*80 TRACE_NAMES (10) 
C
      INCLUDE 'mo_modcom.i'

      INCLUDE 'esi_am.i'

      COMMON /LOGINFO/   IMAX, IDATUM, SAMP_RATE, NUM_SAMPLES
      COMMON /UOMDATA/   DEPTH_UOM, SON_CURVE_UOM, DEN_CURVE_UOM

C
C SET THE WELL DATA RETRIEVAL LIMITS, NUM. OF SAMPLES OVER MAX. INTERVAL
C 
      TOP = IEKB - IDATUM
      BOTTOM = TOP + IMAX


      STRING = 'Processing log data for '//WELL//'.'
      CALL AMG_MESSAGE(AM_DIALOG,STRING)

C
C SET UP SQL PHRASE FOR LOG RETRIEVAL
C
        SQL = 'TRACE_TYPE LIKE ''DT'''
     X  // ' AND DEPTH_TYPE = ''D'' ORDER BY TRACE_TYPE,VERSION DESC'

C
C INQUIRE CURVE AVAILABILITY (IF MORE THAN 1 CURVE ALLOW SELECTION)
C
      IFONE = 0
      CALL LGG_LTDM_SEL_WELL(WELL,SQL,1,
     X 'Select a trace to use in tie model.', IFONE,
     X TRACE_NAMES,NCHOSE,ICANCEL)
      STATUS=0
      IF(ICANCEL.EQ.1)THEN
            STATUS=1
            RETURN
      ENDIF
C
C  GET THE SONIC CURVE CURVE 
C

      CALL LGG_LTDM_GET_TRACE_RESAMP(WELL,TRACE_NAMES(1),'D',TOP,
     X                    BOTTOM, SAMP_RATE, DEPTH_UOM, SON_CURVE_UOM,
     X                    START, NPTS, VNULL, SON_ARRAY, IGOT)

      IF(IGOT.EQ.1)THEN
C         CALL WIGALERT(1,'HELP','Unable to read sonic log for well '
C     x                  //WELL//'.','Unable to calculate sonics.')
         STATUS = 1
         RETURN
      ENDIF

      ISTV=START+.002
      IENV=ISTV + (NPTS-1) * SAMP_RATE + .002
C
C ADJUST SO SUBSCRIPT = DEPTH/2
C

       CALL MO_FIXCUR( SON_ARRAY, ISTV, IENV, IDATUM, IEKB,
     X                 IMAX, VNULL, SAMP_RATE)

C
C NOW RETRIEVE OR CALCULATE DENSITY LOG
C

      DENS_FLAG = DENS_TYPE

      IF (DENS_FLAG.EQ.1) THEN

        SQL = 'TRACE_TYPE LIKE ''RHOB%'''
     X  // ' AND DEPTH_TYPE = ''D'''
     X  // ' ORDER BY TRACE_TYPE,VERSION DESC'

C
C INQUIRE CURVE AVAILABILITY (IF MORE THAN 1 CURVE ALLOW SELECTION)
C
      IFONE = 0
      CALL LGG_LTDM_SEL_WELL(WELL,SQL,1,
     X 'Select a trace to use in tie model.', IFONE,
     X TRACE_NAMES,NCHOSE,ICANCEL)
      STATUS=0
      IF(ICANCEL.EQ.1)THEN
            STATUS=1
            RETURN
      ENDIF
C
C IF WE HAVE A CURVE GET IT
C

      IF (ICANCEL.EQ.0) THEN
        CALL LGG_LTDM_GET_TRACE_RESAMP(WELL,TRACE_NAMES(1),'D',TOP,
     X                    BOTTOM, SAMP_RATE, DEPTH_UOM, DEN_CURVE_UOM,
     X                    START, NPTS, VNULL, DENS_ARRAY, IGOT)
      ENDIF

C
C IF LOG RETRIEVED, FIX UP CURVE ELSE CALCULATE LOG USING DEFAULT METHOD
C

        IF (IGOT.EQ.1.OR.ICANCEL.NE.0) THEN
          DENS_FLAG = DENS_DEFAULT
        ELSE
          ISTDEN = START+.002
          IENDEN = ISTDEN + (NPTS-1) * SAMP_RATE + .002
          CALL MO_FIXCUR( DENS_ARRAY, ISTDEN, IENDEN,IDATUM,IEKB,IMAX,
     X                    VNULL,SAMP_RATE)
        ENDIF

      ENDIF

C
C CALCULATE DENSITY LOG FROM THE GARDNER FORMULA
C

      IF (DENS_FLAG.EQ.2) THEN
        ISTDEN = ISTV
        IENDEN = IENV
        CALL MO_GARDNER( SON_ARRAY, DENS_ARRAY, VNULL)
      ENDIF

C
C SET DENSITY LOG = USER SUPPLIED CONSTANT DENSITY VALUE
C

      IF (DENS_FLAG.EQ.0.OR.DENS_FLAG.EQ.3) THEN 
        ISTDEN = ISTV
        IENDEN = IENV

        DO 500 I = 1, NUM_SAMPLES
500     DENS_ARRAY(I) = CONS_DENS
      ENDIF


      RETURN
      END



      SUBROUTINE MO_GET_DENS(DENS_TYPE, DENS_VALUE,
     X                          DENS_DEFAULT, ISTATUS)
C*****************************************************************************
C
C   ROUTINE:    MO_GET_DENS
C
C   FUNCTION:   TO BRING UP THE DENSITY SELECTION DIALOG AND QUERY THE USER
C               FOR THE METHOD OF DENSITY RECALL/CALCULATION IN THE TIE MODEL.
C               EITHER  1) THE DENSITY LOGS MAY BE RECALLED FROM THE DATABASE
C                 OR    2) THE USER MAY COMPUTE THE DENSITY USING THE GARDNER
C                          FORMULA
C                 OR    3) THE USER CAN INPUT A CONSTANT DENSITY TO BE USED
C
C               NOTE THAT IF SELECTING DENSITY LOG RETRIEVAL THE USER MUST 
C               ALSO SPECIFY ONE OF THE COMPUTATION METHODS IN CASE A DENSITY
C               LOG DOES NOT EXIST FOR A PARTICULAR WELL. 
C
C
C*****************************************************************************


      INCLUDE 'mo_model.ri'
      INCLUDE 'mo_modcom.i'
      INCLUDE 'esi_am.i'

      CHARACTER*255 STRING
      CHARACTER*10 RES_FILE
      INTEGER CDLGID,CDITEM,CDVALUE,ID
      INTEGER DENS_TYPE, DENS_DEFAULT      
      REAL    DENS_VALUE

      DATA RES_FILE/'MO_MODEL'/

      ISTATUS = 0
C
C INITIALIZE CONSTANT DENSITY VALUE = 2.0
C
      DENS_VALUE = 2.0
      DENS_TYPE = 0
      DENS_DEFAULT = 3
C
C DEFINE DIALOG BOX
C
      CALL AMG_DEFINE_RESOURCE(AM_DIALOG, RES_FILE,MO_DENSITY,0,ID,0)

      WRITE(STRING,'(F6.2)') DENS_VALUE
      CALL STRLJ( STRING)
      CALL WIGSCDT( ID, MO_DEN_CONST_VALUE,STRING)
      CALL WIGSCDV( ID, MO_DEN_CONSTANT, 1)

      CALL WIGOPCD(ID)


100   CALL WIGRQCDI(CDLGID,CDITEM,CDVALUE,STRING)

      IF ( CDITEM.EQ.MO_DEN_LOG) THEN
          IF ( DENS_TYPE.EQ.1) THEN
            DENS_TYPE = 0
          ELSE
            DENS_TYPE = 1
          ENDIF 
  
      ELSEIF (CDITEM.EQ.MO_DEN_GARDNER) THEN

          IF ( DENS_TYPE.EQ.0) DENS_TYPE = 2
          DENS_DEFAULT = 2

      ELSEIF (CDITEM.EQ.MO_DEN_CONSTANT) THEN
    
          IF ( DENS_TYPE.EQ.0) DENS_TYPE = 3
          DENS_DEFAULT = 3
      ENDIF

C
      IF(CDITEM.EQ.MO_DEN_OK) GOTO 999
      IF(CDITEM.EQ.MO_DEN_CANCEL) THEN
          ISTATUS = 1
          GOTO 9999
      ENDIF

      GOTO 100      

C
C IF NOT USING GARDNER THEN READ AND VERIFY CONSTANT DENSITY VALUE
C

999   IF (DENS_TYPE.EQ.2) GOTO 9999

      CALL WIGQCCDI(CDLGID,MO_DEN_CONST_VALUE,IDUM,STRING)

      IF(STRING.EQ.' ') GOTO 1010

      READ(STRING,*,ERR=1010) DENS_VALUE
      IF(DENS_VALUE.LT.1.5.OR.DENS_VALUE.GT.3.5) THEN
            NERR=NERR+1
            STRING = 'Constant Density Value out of range.'
            CALL WIGALERT(1,HELP,STRING,'Valid range is 1.5 to 3.5')
            GOTO 100
      ENDIF
      GOTO 9999

1010  STRING = 'Constant Density Value not floating ROW number.'
      CALL WIGALERT(1,HELP,STRING,'Please enter a numeric value.')
      GOTO 100
    

9999  CALL WIGCLCD(ID)
      
      IF (DENS_TYPE.EQ.0) DENS_TYPE = DENS_DEFAULT
      RETURN
      END




      SUBROUTINE MO_GARDNER( VEL_ARRAY, DEN_ARRAY, VNULL )
C*****************************************************************************
C
C   ROUTINE:    MO_GARDNER
C
C   FUNCTION:   TO CALCULATE THE DENSITY LOG FROM THE GARDNER FORMULA.
C
C
C*****************************************************************************

      REAL          VEL_ARRAY(*), DEN_ARRAY(*)
      REAL*8        SCALE_FAC
      CHARACTER*20  DEPTH_UOM,SON_CURVE_UOM,DEN_CURVE_UOM

      COMMON /LOGINFO/   IMAX, IDATUM, SAMP_RATE, NUM_SAMPLES
      COMMON /UOMDATA/   DEPTH_UOM, SON_CURVE_UOM, DEN_CURVE_UOM

      SCALE_FAC = 1000000.0

      
      IF (SON_CURVE_UOM.EQ.'USEC/M') THEN SCALE_FAC = 3280000.0

      DO 300  I = 1, NUM_SAMPLES

        IF ( VEL_ARRAY(I).EQ.VNULL .OR. VEL_ARRAY(I) .LT. 10.) THEN          
          DEN_ARRAY(I) = 2.0
        ELSE
          DEN_ARRAY(I) = 0.23 * (SCALE_FAC / VEL_ARRAY(I) )** 0.25
        ENDIF

300   CONTINUE

      RETURN
      END

C END-CODE
