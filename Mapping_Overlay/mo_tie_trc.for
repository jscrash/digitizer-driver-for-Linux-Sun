C  DEC/CMS REPLACEMENT HISTORY, Element MO_TIE_TRC.FOR
C  *4     1-MAR-1990 17:19:40 GILLESPIE "(SPR 1) Remove unused variables"
C  *3     3-NOV-1989 12:03:06 GILLESPIE "(SPR 30) Change entry points for new n-List nomenclature"
C  *2    19-SEP-1989 10:15:22 GORDON "(PURNA) GULF MODS UNDER SPR 100"
C  *1    10-AUG-1989 18:50:17 VINCE "Fortran code after UNIX mods"
C  DEC/CMS REPLACEMENT HISTORY, Element MO_TIE_TRC.FOR
C******************************************************************************
C
C                Copyright Exploration Systems, Inc. 1989
C		   Unpublished -- All rights reserved
C
C THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Exploration Systems, Inc AND MAY
C CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE
C DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE
C MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF
C
C			Exploration Systems, Inc.
C			579 Market Street
C			San Francisco, CA  USA 94105
C			(415) 974-1600
C
C (The above notice does not constitute an admission of publication or
C unrestricted dissemination of the work)
C
C******************************************************************************
C
      SUBROUTINE MO_TIE_TRACES(MO_TYPE,TIE_FILE,NAME,PLOT_FILE,
     X NRMAX,STATUS)
C *********************************************************************
C
C    ROUTINE:  MO_TIE_TRACES
C
C    FUNCTION: TO COMPUTE THE SYNTHETIC TIME TRACES BY CONVERSION OF 
C              THE COMPUTED MODEL TRACES TO TIME AND THE SUBSEQUENT 
C              CONVOLUTION WITH THE USER SELECTED WAVELET(RICKER,ETC.).
C
C    VARIABLES:
C
C              IDISP     = = 1 IF DISPLAYING WAVELET SPECTRUM 
C              TIE_FILE  = TIE FILE NAME
C              TWELL()   = ARRAY OF UWI'S 
C              STATUS    = STATUS
C              PLOT_FILE = NAME OF PLOT FILE TO BE PASSED TO MODPLOT
C              NRMAX     = MAX NUMBER OF SAMPLES FOR A TRACE
C
C    ROUTINES: CORR      = PERFORMS THE CONVOLUTION
C              SIS_FILTER= COMPUTES THE COSINE WAVELET (NO LONGER USED)
C              SIS_RICKER= COMPUTES THE RICKER WAVELET (NO LONGER USED)
C              RICKER    = COMPUTES THE CGG RICKER WAVELET
C              BUTTWORTH = COMPUTES THE BUTTERWORTH WAVELET
C              ORMSBY    = COMPUTES THE BANDPASS FILTER WAVELET
C              
C              MO_FPLOT  = DISPLAYS FILTER SPECTRUM OF WAVELET
C
C *********************************************************************

      INCLUDE 'mo_modcom.i'
      INCLUDE 'esi_qs.i'
      INCLUDE 'esi_am.i'
      INCLUDE 'esi_we_wells.i'
      INCLUDE 'sf_defs.i'
C
      CHARACTER*(*) TIE_FILE,PLOT_FILE,NAME,MO_TYPE
C
C TWELL - LIST OF WELLS USED IN THIS TIE MODEL
C
      CHARACTER*(SIZEOF_UWI)  TWELL(MAX_WELLS)
      INTEGER                 STATUS
      INTEGER                 IOR(MAX_WELLS)
      INTEGER                 LCUT, LPASS, HCUT, HPASS
      INTEGER                 LROFF, HROFF
      INTEGER                 PREDF
      CHARACTER*128           STRING,AREA
      CHARACTER*128           C_LINE_NAME
      EQUIVALENCE(C_LINE_NAME,I_LINE_NAME)
      REAL		      VEL1(2500), DEN1(2500), DEP1(2500)

      COMMON /DEPTH_ORIGIN/   IDEPTH_FIRST, IDEPTH_LAST
C
C  TEMPORARILY FIX THE SAMPLE RATE AT 2 (IS ALL CURRENTLY ALLOWED)
C
      ISAMP = 2
      STATUS = 0
      NORM_FLAG = 1
C
C GET AREA NAME
C
      CALL QSG_INQC(IQS_PROJECT_NAME,AREA,L1)
C
C OPEN FILE OF SONIC LOGS
C
      CALL HOGFNT(IUNIT)
      OPEN(FILE=TIE_FILE,UNIT=IUNIT,STATUS='OLD',IOSTAT = ISTAT,
     X  FORM='UNFORMATTED')
      IF(ISTAT.NE.0)THEN
           STATUS = 1
           CALL WIGALERT(1,'MO_TIE_TRACES',
     X                      'Unable to open tie model file.',
     X   TIE_FILE)
           RETURN
      ENDIF

C
C GET FILTER PARAMETERS
C
  50  CALL MO_TRACE_DIALOG(ITYPE, XNOISE, IUSE_NOISE,
     X                        IDISP, IPHASE, ICANCEL)
      IF(ICANCEL.EQ.1)THEN
            STATUS=1
            CLOSE(IUNIT)
            RETURN
      ENDIF

C
C  ZERO THE FILTER BUFFER IN CASE HAS ALREADY BEEN USED
C
      DO 51, I = 1, MAX_FILT_ROWS
51    FA(I) = 0.0

      IF (ITYPE.EQ.RICKER_WAV) THEN
C
C  RICKER WAVELET (REPLACED WITH CGG VERSION) 
C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C   RICKER WAVELET (OLD VERSION)
C
C          CALL MO_RICKER_DIALOG(ITYPER,PREDF,IDISP,ISAMP,ICANCEL)
C          IF(ICANCEL.EQ.1)THEN
C            STATUS =1
C            CLOSE(IUNIT)
C            RETURN
C          ENDIF
C
C          IFMIN=-999
C          IFMAX=PREDF+.01
C          PHASE=ITYPER+.01
C          CALL SIS_RICKER(ITYPER,FA,PREDF,ISAMP,IERR)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

          CALL MO_RICKER_DIALOG2(PREDF, LENGTH, ISAMP, ICANCEL)
          IF(ICANCEL.EQ.1)THEN
            STATUS =1
            GOTO 50
          ENDIF


          CALL SF_RICKER( LENGTH, ISAMP, PREDF, FA, IERR)
          IF (IERR.LT.0) THEN
              CALL WIGALERT( 1, 'RICKER WAVELET',
     X             'Incorrect Ricker Wavelet Design',
     x             'Check Parameters') 
              GOTO 50
          ENDIF


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  COSINE WAVELET
C  **CURRENTLY REMOVED FROM MENU-CAN BE REINSTATED IF REQUESTED BY 
C     ENRON **
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C      ELSE IF(ITYPE.EQ.COSINE_WAV)THEN
C          CALL MO_COSINE_DIALOG(IFMIN,IFMAX,PHASE,IDISP,ISAMP,
C     X     ICANCEL)
C          IF(ICANCEL.EQ.1)THEN
C              STATUS=1
C              CLOSE(IUNIT)
C              RETURN
C          ENDIF
C          CALL SIS_FILTER(FA,IFMIN,IFMAX,ISAMP,PHASE,IF)
C          LCUT = IFMIN
C          HCUT = IFMAX
C          LPASS = 0
C          HPASS = 0
C


      ELSE IF (ITYPE.EQ.BUTTERWORTH_WAV) THEN

C
C  BUTTERWORTH WAVELET
C
          CALL MO_BUTTWRTH_DIALOG(LPASS, LROFF, HPASS, HROFF,
     X                            LENGTH, ISAMP, ICANCEL)
          IF(ICANCEL.EQ.1)THEN
            STATUS =1
            GOTO 50
          ENDIF

          CALL AMG_MESSAGE( AM_DIALOG, 'Computing Butterworth Filter')
          CALL SF_BUTTWORTH( LENGTH, ISAMP, LPASS, LROFF, HPASS, HROFF,
     X                       NORM_FLAG, FA)
          CALL AMG_MESSAGE( AM_DIALOG, ' ')
          HCUT = HROFF
          LCUT = LROFF
           
      ELSE IF (ITYPE.EQ.ORMSBY_WAV) THEN

C
C  ORMSBY BANDPASS WAVELET
C
          CALL MO_ORMSBY_DIALOG( LCUT, LPASS, HCUT, HPASS,
     X                           ISAMP, LENGTH, IBTYPE, ICANCEL)
          IF(ICANCEL.EQ.1)THEN
            STATUS =1
            GOTO 50
          ENDIF

          CALL SF_ORMSBY( LENGTH, ISAMP, LCUT, LPASS, HPASS, HCUT,
     X                    IBTYPE, FA, NORM_FLAG, IERR)

          IF (IERR.LT.0) THEN
              CALL WIGALERT( 1, 'ORMSBY BANDPASS',
     X             'Incorrect Bandpass Filter Design',
     x             'Check Filter Length Sufficient') 
              GOTO 50
          ENDIF


      ELSE

C
C  USER DEFINED WAVELET
C
          CALL MO_USER_DEF_DIALOG( FA, LENGTH, ISAMP, ICANCEL)

          IF(ICANCEL.EQ.1)THEN
            STATUS =1
            GOTO 50
          ENDIF


      ENDIF


      NUM_SAMPLES = LENGTH / ( 2 * ISAMP)
      NUM_SAMPLES = NUM_SAMPLES * 2 + 1




C
C  ROTATE THE WAVELET IF REQUIRED
C
      IF (IPHASE.NE.0) THEN
         CALL SF_ROTATE_WAVELET(FA, ISAMP, NUM_SAMPLES, FLOAT(IPHASE))
      ENDIF

C 
C  IF REQUESTED, DISPLAY THE WAVELET IN TIME AND FREQ. DOMAINS
C

      IF(IDISP.EQ.1) THEN

          CALL SF_PLOT(ITYPE, NUM_SAMPLES, FA, LCUT, LPASS,
     X                 HPASS, HCUT, IPHASE, PREDF, ITYPER, ISAMP)
C
C  CHECK WITH THE USER TO SEE IF HE WAS HAPPY WITH FILTER SPECTRUM, IF
C  NOT HE CAN DAMN WELL GO BACK AND REDESIGN IT
C
          CALL WIGYESNO( 'Do you wish to change the Filter?',
     X                    ' ', IFYES, IERR) 

          IF (IFYES.EQ.1) GOTO 50

      ENDIF


C
C  NLOGS = NUMBER OF WELLS
C  IDELEV = DATUM
C  IMAX =   MAX DEPTH OF LOGS
C  NTIMES = NUMBER OF LOGS
C  NLAY   = NUMBER OF LAYERS
C  IOR    = ORIGIN PLACEMNT OF WELLS ARRAY
C
      READ(IUNIT)NLOGS
      READ(IUNIT)(TWELL(I),I=1,NLOGS),IDELEV,IMAX,NTIMES,NLAY,IFDEN,
     X       NVELPTS,(IOR(I),I=1,NLOGS)

C
C  READ LAYERS ARRAY ( EACH LAYER HAS NTIMES VALUES)
C
      NODES=NTIMES*NLAY
      READ(IUNIT)(YOUT(I),I=1,NODES)

      IF(MO_TYPE.EQ.'EMP')THEN
            READ(IUNIT)(XVEL(I),I=1,NVELPTS)
            READ(IUNIT)(YVEL(I),I=1,NVELPTS)
            READ(IUNIT)(HVEL(I),I=1,NVELPTS)
            READ(IUNIT)(HDEN(I),I=1,NVELPTS)
            READ(IUNIT)(VVEL(I),I=1,NVELPTS)
            READ(IUNIT)(VDEN(I),I=1,NVELPTS)
      ENDIF
C
      IDSMP=2
C
C OPEN FILE OF PLOT PARAMETERS FOR OUTPUT
C

C 01/04/89 GS - Use new routine to get unique temp filename
      CALL HOG_GET_UNIQUE_FILENAME( PLOT_FILE )
      CALL TFSTRCAT( PLOT_FILE, '.DAT', PLOT_FILE )
      CALL HOG_ADD_PATH( 'ESI$SCRATCH', PLOT_FILE, LEN(PLOT_FILE),
     +                   PLOT_FILE )
      CALL HOG_TRANSLATE_FILENAME( PLOT_FILE, PLOT_FILE )
C
      CALL HOGFNT(IOUT)
      OPEN(IOUT,FILE=PLOT_FILE,STATUS='NEW',IOSTAT=ISTAT,
     X     FORM='UNFORMATTED')
      IF(ISTAT.NE.0)THEN
          STATUS=1
          CLOSE(IUNIT)
           CALL WIGALERT(1,'MO_TIE_TRACES',
     X    'UNABLE TO OPEN OUTPUT TIE MODEL FILE.',PLOT_FILE)
          RETURN
      ENDIF
C
C INQUIRE FULL FILE NAME
C
C We now have the version number since we've called hog_translate_filename
C      INQUIRE(IOUT,NAME=PLOT_FILE)
C
      CALL MO_ZERO
C
C NRMAX = MAX TIME, WRITTEN NOW TO MAKE SPACE, WRITTEN LATER
C
      NRMAX=0
C
C ICUR = NUMBER OF CURVES WRITTEN OUT 1 VEL (2 IF DEN IN OTHER MODELS)
C
      ICUR=1

C
C  SAMPLE RATE IN 2 WAY TIME
C
      TINC = ISAMP / 1000.0

C
C   WRITE OUT INFORMATION ABOUT FILTER, LAYERS, ETC.
C

      WRITE (IOUT) ITYPE, LENGTH, IPHASE, PREDF
      WRITE (IOUT) LCUT, LPASS, HPASS, HCUT
      WRITE (IOUT) ICUR
      WRITE (IOUT) TINC
      WRITE (IOUT) NTIMES
      WRITE (IOUT) NLAY
C
C SAMPLE RATE FOR INTEGRATION IN 1 WAY TIME
C
      TINC = .001
      KKNT=IMAX/2


C
C LOOP ON THE MODEL SONIC TRACES
C

      DO 1000 ITIMES=1,NTIMES
C
C READ SONIC LOG AND CONVERT IT TO VELOCITY
C
      READ(IUNIT) (VEL(I),I=1,KKNT)
      IF(IFDEN.EQ.1) THEN
          READ(IUNIT) (DEN(I),I=1,KKNT)
      ENDIF

      DO 345 JK = 1 , KKNT
          IF(IFDEN.EQ.0) DEN(JK)=1.0
      IF ( VEL(JK) .LE. 0. ) THEN
          STATUS=1
           CALL WIGALERT(1,'MO_TIE_TRACES',
     X    'ABNORMAL NEGATIVE VELOCITY FOUND',
     X	  'CHECK THE SONIC DATA')
          CLOSE(IUNIT)
          RETURN
      ENDIF
345   VEL(JK)=1000000./VEL(JK)


C
C CONVERT YOUT ARRAY (WHICH HAS LAYERS STORED IN DEPTH FROM MODEL TOP)
C TO TIME BY INTEGRATING LOGS OVER THE CORRECT DEPTH INTERVAL TO GET A
C VELOCITY, THEN COMPUTING THE TIME
C
      TOTAL_TIME = 0.0
      DEPTH1 = 0.0
      DEPTH2 = YOUT(ITIMES)

      DO 380 I = 1, NLAY

        CALL MO_INTEG_SONIC( VEL, DEPTH1, DEPTH2, 2.0, DELTA_TIME)

        TOTAL_TIME = TOTAL_TIME + DELTA_TIME

        IF (DEPTH2.NE.FICT) DEPTH1 = DEPTH2
        DEPTH2 = YOUT( I * NTIMES + ITIMES)
        YOUT( (I - 1) * NTIMES + ITIMES) = TOTAL_TIME 

380   CONTINUE


C
      WRITE(STRING,400)ITIMES,NTIMES
400   FORMAT('Integrating sonic log ',I4,' of ',I4,'.')
      CALL AMG_MESSAGE(AM_DIALOG,STRING)
C
C INITIALZE COUNTERS AND SUMS
C
      SUM=0.
      NROWS=0
      DA=0.0
      VSUM=0.0
      DSUM=0.0
      ISAMP_COUNT=0
C
      DO 38 L=1,KKNT
C
C CALCULATE INTERVAL VELOCITY
C
      IF(VEL(L+1).EQ.0.0)VEL(L+1)=VEL(L)
      V=(VEL(L+1)+VEL(L))/2
C
C  TT = TRAVEL TIME
C
      TT= IDSMP /V
      SUM=SUM+TT
      VSUM=VSUM+VEL(L)
      DSUM=DSUM+DEN(L)
      ISAMP_COUNT = ISAMP_COUNT+1
C
C DA IS CUMULATING DEPTH
C
      DA=DA+IDSMP
C
      IF(SUM.LT.TINC) GO TO 38
C
C WE HAVE REACHED A SAMPLE INTERVAL
C
C
C RES = RESIDUAL TIME ABOVE TINC
C
388   RES=SUM-TINC
      NROWS=NROWS+1
      VEL1(NROWS)=VSUM/ISAMP_COUNT
      DEN1(NROWS)=DSUM/ISAMP_COUNT
      SUM=RES
      DEP1(NROWS)=DA - RES * V
      IF(SUM.GE.TINC) GO TO 388
      ISAMP_COUNT=0
      VSUM=0.0
      DSUM=0.0
   38 CONTINUE
C
C	ADD ZEROS AT THE END OF THE DEPTH ARRAY SO THAT WE DON'T
C	GARBAGE WHEN WE'LL TRY TO READ THE ARRAY BACK
C  	VEL SHOULD BE O.K. BECAUSE IT ZEROED DURING INTEGRATION...
C
	DO 55 I = NROWS+1, NROWS+50
	DEP1(I) = 0.
	VEL1(I) = 0.
	DEN1(I) = 0.
55	CONTINUE

      NROWS=NROWS+50
      NUM_SAMPLES2 = NUM_SAMPLES / 2
C
C CALCULATE REFLECTION COEEFICIENT SERIES
C
C
      DO 60 I=1, NROWS
        IF (DEN1(I + 1).EQ.0.) DEN1(I + 1) = DEN1(I)
        IF (VEL1(I + 1).EQ.0.) VEL1(I + 1) = VEL1(I)
        VA(I + NUM_SAMPLES2)=(VEL1(I+1) * DEN1(I+1)-VEL1(I)*DEN1(I)) /        
     X   (VEL1(I + 1) * DEN1(I + 1) + DEN1(I) * VEL1(I))
60    CONTINUE

C
C  WRITE OUT NROWS AND CURVES IF FIRST TIME
C
      IF(ITIMES.EQ.1)THEN
	DO 66 I = 1, NROWS
	DEP1(I) = DEP1(I) + IDEPTH_FIRST
66      CONTINUE
          WRITE(IOUT) NROWS
          WRITE(IOUT)(DEP1(I),I=1,NROWS)
          WRITE(IOUT)(VEL1(I),I=1,NROWS)
          WRITE(IOUT)(VA(I),I= NUM_SAMPLES2 + 1,NROWS + NUM_SAMPLES2)
      ENDIF
C
C  CALCULATE SYNTHETIC TRACE
C
      NSAMPS = NROWS*2
      WRITE(STRING,410)ITIMES,NTIMES,NSAMPS
410   FORMAT('Generating seismic trace number ',I4,' of ',I4,'.',
     X       '  Time calculated = ',I4,' ms.')
      CALL AMG_MESSAGE(AM_DIALOG,STRING)
C
C CHECK IF NOISE IS REQUESTED
C
      NROWS2 = NROWS + NUM_SAMPLES2 + 1

      IF(IUSE_NOISE.EQ.1.AND.XNOISE.NE.0.0)THEN
        DO 412 INO = 1, NUM_SAMPLES2
412     VA(INO) = 0.0

        DO 413 INO = NROWS2, NROWS2 + 50
413     VA(INO) = 0.0

        CALL MO_NOISE(XNOISE, VA, NROWS2 + 50)

      ENDIF
C
C  CONVOLVE THE REFLECTION COEFFS. WITH THE FILTER WAVELET
C
      CALL SF_FLIP_BUFF(FA, NUM_SAMPLES)
      CALL CORR(FA, VA, CONN, NUM_SAMPLES, NROWS2 + 50, NSAMPS)

      IF (NROWS.GT.NRMAX) NRMAX = NROWS
      WRITE(IOUT) NROWS
      WRITE(IOUT) (CONN(I),I=1,NROWS)
1000  CONTINUE
C
C WRITE OUT TIME DEPTH FOR LAST TRACE
C
	DO 77 I = 1, NROWS
	DEP1(I) = DEP1(I) + IDEPTH_LAST
77      CONTINUE
      WRITE(IOUT)(DEP1(I),I=1,NROWS)
C      CALL MO_SEGY_DIALOG(NAME,LINE_NAME,ICREATE,ICANCEL)
      ICREATE = 0
C
C WRITE OUT BUFFER OF LAYER TIMES THEN ZERO THE YOUT ARRAY
C
      WRITE (IOUT) (YOUT(I), I = 1, NODES)
      CLOSE(IUNIT)
      DO 2000 I = 1, NODES
2000  YOUT(I) = 0.0


C
C  DO NOT MAKE A LINE
C
      IF(ICREATE.EQ.0.OR.ICANCEL.NE.0)THEN
            CLOSE(IOUT)
            STRING=' '
            CALL AMG_MESSAGE(AM_DIALOG,STRING)
            RETURN
      ENDIF

      RETURN
      END


      SUBROUTINE MO_INTEG_SONIC( VLOG, START_DEPTH, END_DEPTH,
     X                           SAMP_RATE, DELTA_TIME)
C ***************************************************************************
C
C    ROUTINE:     MO_INTEG_SONIC
C
C    FUNCTION:    THIS ROUTINE TAKES VELOCITY ARRAY VLOG AND RETURNS AN 
C                 AVERAGE VELOCITY BETWEEN DEPTHS START_DEPTH AND
C                 END_DEPTH AND A DELTA TIME VALUE.
C    
C    
C *************************************************************************** 

      INCLUDE 'mo_modcom.i'

      REAL    VLOG(*)
      REAL*8  VEL_SUM

C
C CHECK FOR NO LAYER AT THIS TRACE
C
      IF (END_DEPTH.EQ.FICT) THEN
        DELTA_TIME = 0.0
        RETURN
      ENDIF

C 
C GET INDEX POSITIONS (IN VLOG) EQUAL TO STARTING AND ENDING DEPTHS
C NOTE THAT INDEXES ARE ROUNDED UP TO NEXT SAMPLE
C

      INDEX_START = ( START_DEPTH + SAMP_RATE)
     X               / SAMP_RATE

      INDEX_END = (END_DEPTH + SAMP_RATE)
     X               / SAMP_RATE

C
C LOOP ON THE VELOCITY ARRAY, GET SUM OF VELOCITIES OVER THE INTERVAL
C

      VEL_SUM = 0.0

      DO 100 I = INDEX_START, INDEX_END
100    VEL_SUM = VEL_SUM + VLOG(I)


      AVG_VEL = VEL_SUM / (INDEX_END - INDEX_START + 1)      

C
C GET 2 WAY DELTA T VALUE
C

      DELTA_TIME = 2 * (END_DEPTH - START_DEPTH) / AVG_VEL

      RETURN
      END


