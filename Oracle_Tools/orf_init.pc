/* DEC/CMS REPLACEMENT HISTORY, Element ORF_INIT.PC*/
/*  6     8-OCT-1991 14:35:42 JANTINA "(SPR 0) Added code for seismic data type"*/
/* *5    12-OCT-1990 17:26:35 GILLESPIE "(SPR 100) Merge Ernie Deltas"*/
/* *4    25-JUL-1990 19:56:37 VINCE "(SPR 5644) Header Standardization"*/
/* *3    14-SEP-1989 18:25:54 GORDON "(SPR -1) checkin from gulf"*/
/* *2    17-AUG-1989 16:49:35 CONROY "(SPR 9999) change initial_value to start_with"*/
/* *1    19-JUN-1989 12:35:14 SYSTEM ""*/
/* DEC/CMS REPLACEMENT HISTORY, Element ORF_INIT.PC*/
/*****************************************************************************/
/******************************************************************************

                Copyright Exploration Systems, Inc. 1989
                    Unpublished -- All rights reserved

THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Exploration Systems, Inc.  AND MAY
CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE
DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE
MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF

                            Exploration Systems
                            c/o Finder Graphics Systems
                            201 Tamal Vista Blvd.
                            Corte Madera, CA  94925
                            (415) 927-0100

(The above notice does not constitute an admission of publication or
unrestricted dissemination of the work)

******************************************************************************/

#include "esi_c_lib.h"
#include "esi_oracle.h"
#include "esi_nl.h"
#include "esi_qs.h"
#include "esi_sl.h"
#include "esi_ts.h"

#define BIND_SIZE 50
EXEC SQL BEGIN DECLARE SECTION;
EXEC SQL END DECLARE SECTION;

/* Function Description -----------------------------------------------------
Description:
    Initialize an ORACLE form with data from Finder.

Prototype:
    publicdef INT orf_init(CHAR *cmd, INT *cmdlen, CHAR *msg, INT *msglen, 
        INT *query);

Parameters:     (indicate (I)/(O)/(M) for input/output/input-and-modified)
    cmd             -(CHAR *)
    cmdlen          -(INT *)
    msg             -(CHAR *)
    msglen          -(INT *)    
    query           -(INT *)

Return Value/Status:
    IAPSUCC
    
Scope:
    PUBLIC
    
Limitations/Assumptions:

-----------------------------------------------------------------------------*/

/* BEGIN:   */
#if USE_PROTOTYPES
publicdef INT orf_init (CHAR *cmd, INT *cmdlen, CHAR *msg, INT *msglen, INT *query)
#else
publicdef INT orf_init (cmd, cmdlen, msg, msglen, query)
CHAR *cmd;
INT *cmdlen;
CHAR *msg;
INT *msglen;
INT *query;
#endif
    {
    INT i;
    INT j;
    UINT count;
    INT status;
    NLIST_HEADER nlist;
    UINT ndim;
    UINT Dim_List[1];
    VOIDPTR Value_List[1];
    CHAR things[BIND_SIZE][sizeof(SELECT_KEY_STRING)];
    
    CHAR buff[255];
    CHAR command[31];
    CHAR data_type[31];
    PROJECT_NAME form_project;

    EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR project[31];
    VARCHAR stratcol[31];
    VARCHAR owner[31];
    VARCHAR list_name[64];
    VARCHAR name[50][64];
    VARCHAR object[50][64];
    VARCHAR environment[20];
    int cnt;
    EXEC SQL END DECLARE SECTION;
    
    qs_inq_c (QS_PROJECT_NAME, (CHAR *)project.arr, &i);
    project.len = i;
    
    /* the command line comes in the form COMMAND ARG1 ARG2 ... ARGn */
    /* scan past the command name; get to 1st argument */
    
    /* load the command in the local storage "buff" to that the null
       terminator can be placed at the end without disturbing cmd */
    
    strncpy (buff, cmd, *cmdlen);
    buff[*cmdlen] = 0;
    
    cmd = ts_next_word (buff, command);
    cmd = ts_next_word (cmd, data_type);
    cmd = ts_next_word (cmd, form_project);
    
    i = 0;
    ts_sto_upper (data_type);
    ts_sto_upper (form_project);
    
    if (ARE_SAME (data_type, "WELLS"))
        {
        qs_inq_c (QS_CUR_WELL_LIST, (CHAR *)list_name.arr, &i);
        list_name.len = i;
        if (i > 0)
            {
            /* clean out any existing list */
            EXEC SQL DELETE TEMP_WELL_LISTS WHERE TEMP_PROCESS_ID =
		    USERENV ('SESSIONID')
            AND TEMP_LIST_NAME =  : list_name;
            
            status = sl_read_list (WELLS_DATA_TYPE, (CHAR *)list_name.arr, &nlist);
            if (status < 0)
                {
                list_name.len = 0;
                }
            else
                {
                /* get total * of entries */
                nl_inq_nlist_int (nlist, NL_NLIST_NPOINTS, (INT *) & count);
                cnt = MIN (BIND_SIZE, count);
                /* fill up select list names array */
                for (i = 0; i < cnt; i++)
                    {
                    name[i].len = list_name.len;
                    strcpy ((char *)name[i].arr, (char *)list_name.arr);
                    }
                /* insert batches of BIND_SIZE */
                ndim = 1;
                Dim_List[0] = 1;
                Value_List[0] = (VOIDPTR)things[0];
                for (i = 0; i < count; i += BIND_SIZE)
                    {
                    nl_set_current_point (nlist, i + 1, 1);
                    nl_get_points (nlist, BIND_SIZE, 1, Dim_List, Value_List,
                                   (UINT *) & cnt);
                    
                    /* move the things into the VARCHAR array */
                    for (j = 0; j < cnt; j++)
                        {
                        V_FROMC (object[j], things[j]);
                        }
                    EXEC SQL FOR : cnt INSERT INTO TEMP_WELL_LISTS (
						TEMP_LIST_NAME,
						TEMP_PROCESS_ID,
						KEY_UWI)VALUES (
						:name,USERENV ('SESSIONID'),
						:object);
                    }
                EXEC SQL COMMIT WORK;
                nl_free_nlist (nlist);
                }
            }
        }
    else if (strcmp (data_type, "SEISMIC") EQUALS 0)
        {
        qs_inq_c (QS_CUR_SEISMIC_LIST, (CHAR *)list_name.arr, &i);
        list_name.len = i;
        }
    else
        {
        list_name.len = 0;
        }
    qs_inq_c (QS_FINDER_ACCOUNT, (CHAR *)owner.arr, &i);
    owner.len = i;                  /* remember, owner.len is a SHORT ... */
    
    qs_inq_c (QS_ENVIRONMENT, (CHAR *)environment.arr, &i);
    environment.len = i;

    V_FROMC (stratcol, "");
    
    /* fill the two global form variables PROJECT and TEMP_LIST_NAME */
    
    EXEC IAF PUT GLOBAL.PROJECT, GLOBAL.LIST_NAME, GLOBAL.OWNER,
        GLOBAL.STRATCOL,GLOBAL.ENVIRONMENT 
      VALUES ( :project,  :list_name,  :owner,  :stratcol, :environment);
    
    return IAPSUCC;
    }
/* END:     */
