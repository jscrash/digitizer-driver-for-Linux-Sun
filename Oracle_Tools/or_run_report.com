$! DEC/CMS REPLACEMENT HISTORY, Element OR_RUN_REPORT.COM
$! *7    14-OCT-1991 13:43:13 LOEBL "(SPR 4365) Delete from temp file"
$! *6     2-OCT-1990 10:15:17 ALLAWAY "(SPR 5899) Modified to use ut_display_report to display reports"
$! *5     6-APR-1990 16:05:04 WALTERS "(SPR 0) Translate report file name correctly for print command"
$! *4     5-APR-1990 19:16:49 SCD "(SPR 1) For some reason this script had set noverify disabled?"
$! *3     5-APR-1990 19:08:32 SCD "(SPR 1) Translate REPORT_FILE for print and delete."
$! *2    29-SEP-1989 12:30:59 GORDON "(SPR 5004) Create a unique temp table name"
$! *1    19-JUN-1989 14:57:48 SYSTEM ""
$! DEC/CMS REPLACEMENT HISTORY, Element OR_RUN_REPORT.COM
$ SET NOVERIFY
$ SET NOON
$ !
$ ! This command procedure is the last step in generating an Oracle Report
$ ! It is invoked from the Finder routine OR_RUN_ORACLE_REPORT
$ !
$ ! p1 = FINDER NAME/PASSWORD
$ ! p2 = PROJECT NAME
$ ! p3 = OUTPUT REPORT FILE NAME
$ ! p4 = SCRIPT NAME
$ ! p5 = ORIGINAL SELECT LIST NAME
$ ! p6 = SELECT LIST TYPE
$ ! p7 = SCRIPT TYPE
$ ! p8 = Report disposition (Keep/Delete, Print)
$ !
$ ! The following routine creates a new table and sets the symbol TABLE_NAME
$ !   (for those reports that use a select list)
$ !    and assigns the PROJECT logical names
$ ! 
$ IF F$MODE() .EQS. "BATCH" .OR. P5 .NES. "NULL" THEN GOSUB MAKE_TEMP_TABLE
$ IF P7 .EQS. "" THEN P7 := "SQLPLUS"
$ IF P3 .EQS. "" THEN P3 = "ESI_REPORT_TEMP_FILE.LIS" !ALWAYS SPOOL A REPORT
$ !
$ REPORT_COM :== "ESI_REPORT_TEMP_FILE.SQL"
$ OPEN/WRITE REPORT 'REPORT_COM'
$ REPORT_COM = F$SEARCH(REPORT_COM)	! GET THE FULL FILE SPEC
$ GOTO 'P7'
$ !
$ ! WRITE OUT THE SQLPLUS COMMANDS TO EXECUTE THE REPORT
$ !
$ SQLPLUS:
$	WRITE REPORT "''P1'"	! NAME/PASSWORD
$	FORMATS = F$SEARCH("ESI$SCRIPTS:FORMATS.SQL")
$	WRITE REPORT "START ''FORMATS'"
$	IF P3 .NES. "" THEN GOSUB INIT_SPOOL
$!	IF F$MODE() .NES. "BATCH" THEN GOSUB INIT_INTERACTIVE
$	WRITE REPORT "START ''P4' ''P2' ''TABLE_NAME' ""''P5'"""
$	IF P3 .NES. "" THEN $ WRITE REPORT "SPOOL OFF"
$	WRITE REPORT "SET TERMOUT ON"
$!
$! the following logic was added because sometimes privileges or locks
$! prevent successful dropping of the table.
$!
$	IF P5 .NES. "NULL" 
$       THEN 
$             WRITE REPORT "DELETE FROM ''TABLE_NAME';"
$             WRITE REPORT "COMMIT;"
$             WRITE REPORT "DROP TABLE ''TABLE_NAME';"
$       ENDIF
$	WRITE REPORT "EXIT
$	CLOSE REPORT
$	SQLPLUS @'REPORT_COM'
$	DISP := $ESI$BIN:UT_DISPLAY_REPORT
$	DEFINE/USER SYS$INPUT SYS$COMMAND
$	IF F$MODE() .NES. "BATCH" THEN $ DISP 'P3'
$	GOTO ENDUP
$ !
$ ! WRITE OUT THE SQLREPORT COMMANDS TO EXECUTE THE REPORT
$ !
$ SQLREPORT:
$	WRITE REPORT "$ RPT ''P4' ''P3' ''P1'"
$	WRITE REPORT "''P2'"			! PROJECT NAME
$	WRITE REPORT "''TABLE_NAME'"		! CONTROL TABLE NAME
$	WRITE REPORT "''P5'"			! ORIGINAL CONTROL LIST NAME
$	WRITE REPORT "$ RPF ''P3' ''P3' -F"   ! FORMAT THE REPORT
$	CLOSE REPORT
$	@'REPORT_COM'
$	DISP := $ESI$BIN:UT_DISPLAY_REPORT
$	DEFINE/USER SYS$INPUT SYS$COMMAND
$	IF F$MODE() .NES. "BATCH" THEN $ DISP 'P3'
$	GOTO ENDUP
$ ENDUP:
$	DELETE 'REPORT_COM'			! DELETE THE TEMPORARY PROCEDURE
$	IF P3 .EQS. "" THEN EXIT
$	LEN  = F$LENGTH(P8)			! SEE IF REPORT TO BE PRINTED
$	IF F$LOCATE("PRINT",P8) .EQ. LEN THEN GOTO NO_PRINT
$	PR := "PRINT/NOFEED"
$						! CHECK FOR DELETE
$	IF F$LOCATE("DELETE",P8) .NE. LEN THEN PR = PR + "/DELETE"
$	'PR' 'P3
$	EXIT
$ NO_PRINT:	! SEE IF FILE SHOULD BE DELETED (SHOULD NOT NORMALLY BE DONE)
$	REPORT_FILE :== "''P3'"
$	REPORT_FILE = F$SEARCH(REPORT_FILE)	! GET THE FULL FILE SPEC
$	IF F$LOCATE("DELETE",P8) .NE. LEN THEN -
$	DELETE 'REPORT_FILE'
$	EXIT
$ INIT_SPOOL:
$	WRITE REPORT "SPOOL ''P3'"
$!	P3 = F$PARSE("''P3'","ESI$REPORTS:REPORT.LIS")
$!	WRITE REPORT "HOST @ESI$BIN:SET_JOB_LOGICAL REPORT_FILE ''P3'"
$	RETURN
$! The section below is no longer called, but is left in for reference
$ INIT_INTERACTIVE:
$	WRITE REPORT "SET PAUSE 'Hit return to continue'"
$	WRITE REPORT "SET PAUSE ON;
$	WRITE REPORT "SET SQLPROMPT 'SQL> ';"
$	WRITE REPORT "SET TERMOUT ON;"
$	WRITE REPORT "SET ECHO ON;"
$	RETURN
$ MAKE_TEMP_TABLE:
$	! ASSIGN NECESSARY LOGICAL NAMES; MAKE TEMPORARY TABLE, IF NECESSARY
$	OR_MAKE_TABLE :== $ESI$BIN:OR_MAKE_TABLE
$	! CONSTRUCT A UNIQUE TEMPORARY TABLE NAME USING PROCESS ID INFORMATION
$	PROC = F$GETJPI("","PRCNAM")
$	TABLE_NAME = "TEMP_''F$EXTRACT(0,F$LOCATE(":",PROC),PROC)'"
$	OR_MAKE_TABLE 'P1' 'P2' "''P5'" 'P6' 'TABLE_NAME'
$	DEFINE/USER SYS$INPUT SYS$COMMAND
$	RETURN
