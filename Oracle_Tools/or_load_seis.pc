/* DEC/CMS REPLACEMENT HISTORY, Element OR_LOAD_SEIS.PC*/
/* *5    16-JUL-1991 11:20:33 PURNA "(SPR 1560) removed problem on duplicate entry in temp_seismic_llists"*/
/* *4    25-JUL-1990 19:57:19 VINCE "(SPR 5644) Header Standardization"*/
/* *3    30-OCT-1989 14:36:00 PURNA "(SPR 5039) Seismic Select List Mods"*/
/* *2    14-SEP-1989 18:27:01 GORDON "(SPR -1) checkin from gulf"*/
/* *1    19-JUN-1989 12:35:29 SYSTEM ""*/
/* DEC/CMS REPLACEMENT HISTORY, Element OR_LOAD_SEIS.PC*/
/*****************************************************************************/
/******************************************************************************

                Copyright Exploration Systems, Inc. 1989
                    Unpublished -- All rights reserved

THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Exploration Systems, Inc.  AND MAY
CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE
DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE
MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF

                            Exploration Systems
                            c/o Finder Graphics Systems
                            201 Tamal Vista Blvd.
                            Corte Madera, CA  94925
                            (415) 927-0100

(The above notice does not constitute an admission of publication or
unrestricted dissemination of the work)

******************************************************************************/

#include "esi_nl.h"
#include "esi_oracle.h"

#ifndef ESI_C_LIB_H

#include "esi_c_lib.h"

#endif
EXEC ORACLE OPTION (SELECT_ERROR = NO);

/* Function Description -----------------------------------------------------
Description:
    Load the TEMP_WELL_LISTS table with the specified
    select list of seismic lines.

Prototype:
    publicdef INT or_load_seismic(CHAR *unique_name, NLIST_HEADER nlist);

Parameters:     (indicate (I)/(O)/(M) for input/output/input-and-modified)
    unique_name     -(CHAR *)
    nlist           -(NLIST_HEADER)

Return Value/Status:
    SUCCESS - Successful completion.
    FAIL    - Unsuccessful completion.
    OR_STATUS
    
Scope:
    PUBLIC
    
Limitations/Assumptions:

-----------------------------------------------------------------------------*/

/* BEGIN:   */
#if USE_PROTOTYPES
publicdef INT or_load_seismic (CHAR *unique_name, NLIST_HEADER nlist)
#else
publicdef INT or_load_seismic (unique_name, nlist)
CHAR *unique_name;
NLIST_HEADER nlist;
#endif
    {
    INT status;
    INT ndim;
    UINT Dim_List[3];
    VOIDPTR Value_List[3];
    CHAR *pdollar;
    
    EXEC SQL BEGIN DECLARE SECTION;
    int count;
    VARCHAR stmt[255];
    int line_id[100];
    int initial_cdp[100];
    int final_cdp[100];
    char *id;
    EXEC SQL END DECLARE SECTION;
    
    /* I assume that if the  list name exists in
    the TEMP_SEISMIC_LISTS table, then this list
    has already been inserted, and that the select
    list has NOT changed its contents since the list
    was entered.  This implies that any select list editing
    function should make sure that the TEMP_SEISMIC_LISTS
    table entry is brought up to date before allowing other
    interactions... */
    id = unique_name;
    EXEC SQL WHENEVER NOT FOUND GOTO not_yet_loaded;
    EXEC SQL WHENEVER SQLERROR GOTO sql_err;
    EXEC SQL SELECT NULL FROM TEMP_SEISMIC_LISTS WHERE TEMP_PROCESS_ID =
                                                                         USERENV (
                                                                           'SESSIONID')
    AND TEMP_LIST_NAME =  : id;
    return SUCCESS;
    
not_yet_loaded:
    stmt.len = sprintf ((char *)stmt.arr, 
"INSERT INTO TEMP_SEISMIC_LISTS \
(TEMP_LIST_NAME, LINE_ID,\
INITIAL_SHOT, FINAL_SHOT,  TEMP_PROCESS_ID) VALUES \
('%s', :line_id, :initial_shot, :final_shot, USERENV('SESSIONID'))"
            , unique_name);
    EXEC SQL PREPARE S1 FROM : stmt;
    
    /* retrieve the select list data into a buffer */
    
    ndim = 3;
    Dim_List[0] = 1, Value_List[0] = (VOIDPTR)line_id;
    Dim_List[1] = 2, Value_List[1] = (VOIDPTR)initial_cdp;
    Dim_List[2] = 3, Value_List[2] = (VOIDPTR)final_cdp;
    status = nl_first_point (nlist, ndim, Dim_List, Value_List);
    
    /* NOTE: the initialization of COUNT is as it
       is because we want a smooth data flow using
       nl_next_point.  It's the easiest way to
       keep from using nl_set_current_point I
       could think of.  JGG
    */
    
    for (count = 1; status >= 0 AND NOT (status & NL_EOL); count = 0)
        {
        /* load up 100 rows at a time          */
        for (; count < 100; count++)
            {
            Value_List[0] = (VOIDPTR) & line_id[count];
            Value_List[1] = (VOIDPTR) & initial_cdp[count];
            Value_List[2] = (VOIDPTR) & final_cdp[count];
            status = nl_next_point (nlist, ndim, Dim_List, Value_List);
	    if(status < 0 OR (status & NL_EOL))
		break;
            }
        EXEC SQL FOR : count EXECUTE S1 USING : line_id,  : initial_cdp,  : final_cdp;
        }
    EXEC SQL COMMIT WORK;
    
    return SUCCESS;
    
sql_err:
    EXEC SQL ROLLBACK WORK;
    return OR_STATUS;
    }
/* END:     */
