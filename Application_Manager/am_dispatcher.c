/* DEC/CMS REPLACEMENT HISTORY, Element AM_DISPATCHER.C*/
/* *2    14-AUG-1990 11:39:52 VINCE "(SPR 5644) Header Standardization"*/
/* *1    19-JUN-1989 11:59:53 SYSTEM ""*/
/* DEC/CMS REPLACEMENT HISTORY, Element AM_DISPATCHER.C*/
/*****************************************************************************/
/******************************************************************************

                Copyright Exploration Systems, Inc. 1989
                    Unpublished -- All rights reserved

THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Exploration Systems, Inc.  AND MAY
CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE
DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE
MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF

                            Exploration Systems
                            c/o Finder Graphics Systems
                            201 Tamal Vista Blvd.
                            Corte Madera, CA  94925
                            (415) 927-0100

(The above notice does not constitute an admission of publication or
unrestricted dissemination of the work)

******************************************************************************/

#include "esi_am_int.h"
#include "esi_am_err.h"

#ifndef ESI_HO_H

#include "esi_ho.h"

#endif

/* Function Description -----------------------------------------------------
Description:
    AM_DISPATCHER is called each time an event is received from the MAC.
    AM_DISPATCHER calls the event server for the resource (menu or custom
    dialog box) from which the event was generated with the following
    parameters:

         -    id: menu or custom dialog id
         -    item: specific button or menu command
         -    pointer: passed pointer defined to AM_DEFINE_RESOURCE

    After calling the appropriate event server, AM_DISPATCHER returns to it's
    caller. The status returned by AM_DISPATCHER is the status which was
    returned by the called event server.

    AM_DISPATCHER processes a single event. AM_DISPATCHER does not, itself,
    request any events. Therefore, it should be called repeatedly while
    events are being requested and therefore generated by the operator.

Prototype:
    publicdef INT am_dispatcher(INT event_type, INT id, INT item);
    
Parameters:     (indicate (I)/(O)/(M) for input/output/input-and-modified)
    (I) event_type  -(INT) event type.
    (I) id          -(INT) menu or custom dialog id.
    (I) item        -(INT) item on menu or custom dialog.

Return Value/Status:
    SUCCESS - Successfull completion of event;
    AM_ERR_ACCESS_VIOLATION - Pointer parameter is out of program boundary;
    AM_ERR_UNRECOGNIZED_EVENT - If AM_DISPATCHER is called with an event 
        specification which cannot be recognized.
Scope:
    PUBLIC
    
Limitations/Assumptions:
    
-----------------------------------------------------------------------------*/

/* BEGIN:   */
#if USE_PROTOTYPES
publicdef INT am_dispatcher (INT event_type, INT id, INT item) 
#else
publicdef INT am_dispatcher (event_type, id, item)
INT event_type;                     /* event type */
INT id;                             /* menu or custom dialog id */
INT item;                           /* item on menu or custom dialog */
#endif
    {
    INT status;                     /* service completion status */
    RESOURCE_LIST rsrc;             /* resource node storage */
    APPLICATION_LIST app;           /* application node storage */
    APPLICATION_STATIC *application_static = am_static ();
    
    /* *********************************************************************** */
    
    /*   Find RESOURCE_LIST node for menu
         or custom dialog from which event
         was generated. */
    
    status = btfind (&application_static->resource_list, (VOIDPTR) & id,
                     (VOIDPTR) & rsrc);
    
    /*   If RESOURCE_LIST node was found ... */
    
    if (status)
        {
        
        /*   If server is not NULL ... */
        
        if (rsrc.server != NULL_FUNCTION_PTR)
            {
            
            /*   Set current application id to the one
                 which owns the menu or custom dialog. */
            
            application_static->application_id = rsrc.application_id;
            
            /*   If server is accessable ... */
            
            if (am_check_pointer ((VOIDPTR)rsrc.server, "r"))
                {
                status = AM_ERR_ACCESS_VIOLATION;
                }
            /*   Call application event server. */
            
            else
                {
                btfind (&application_static->application_list,
                        (VOIDPTR) & rsrc.application_id, (VOIDPTR) & app);
                if (app.accounting)
                    {
                    app.start_cpu_time = ho_cpu_time ();
                    app.start_io_time = ho_io_time ();
                    btrepcur (&application_static->application_list,
                              (VOIDPTR) & rsrc.application_id, (VOIDPTR) & app);
                    }
                switch (rsrc.language)
                    {
                case 0:             /* C - call by value */
                default:
                    status = (*rsrc.server)(id, item, rsrc.pointer);
                    break;
                case 1:             /* FORTRAN - call by reference */
                    status = (*rsrc.server)(&id, &item, rsrc.pointer);
                    break;
                    }
                if (app.accounting &&
                    btfind (&application_static->application_list,
                            (VOIDPTR) & rsrc.application_id, (VOIDPTR) & app))
                    {
                    app.cpu_time += ho_cpu_time () - app.start_cpu_time;
                    app.io_time += ho_io_time () - app.start_io_time;
                    btrepcur (&application_static->application_list,
                              (VOIDPTR) & rsrc.application_id, (VOIDPTR) & app);
                    }
                }
            }
        }
    /*   If RESOURCE_LIST node was not found,
         indicate that the event is
         unrecognizable. */
    
    else
        {
        status = AM_ERR_UNRECOGNIZED_EVENT;
        }
    return status;
    }
/* END:     */
