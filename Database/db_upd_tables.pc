/* DEC/CMS REPLACEMENT HISTORY, Element DB_UPD_TABLES.PC*/
/* *7    14-AUG-1990 13:11:23 VINCE "(SPR 5644) Header Standardization"*/
/* *6    28-FEB-1990 06:15:26 GILLESPIE "(SPR 1) Add cast to call to dba_update_1_table"*/
/* *5    14-OCT-1989 15:57:33 VINCE "(SPR -1) mods for new update schem"*/
/* *4    19-SEP-1989 13:36:18 GILLESPIE "(SPR 100) GULF MODS"*/
/* *3    13-AUG-1989 00:05:39 GILLESPIE "(SPR 5) Convert COL to USER_TAB_COLUMNS for Oracle Version 6"*/
/* *2    11-AUG-1989 13:55:04 CONROY "(SPR 9999) Mods for ORACLE V6"*/
/* *1    19-JUN-1989 12:30:33 SYSTEM ""*/
/* DEC/CMS REPLACEMENT HISTORY, Element DB_UPD_TABLES.PC*/
/*****************************************************************************/
/******************************************************************************

                Copyright Finder Graphics Systems, Inc. 1990
                    Unpublished -- All rights reserved

THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Exploration Systems, Inc.  AND MAY
CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE
DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE
MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF

                            Finder Graphics Systems
                            201 Tamal Vista Blvd.
                            Corte Madera, CA  94925
                            (415) 927-0100

(The above notice does not constitute an admission of publication or
unrestricted dissemination of the work)

******************************************************************************/

#include "esi_db.h"
#include "esi_am.h"
#include "esi_db_msg.h"
#include "esi_mg.h"
#include "esi_oracle.h"
/* EXEC ORACLE OPTION (REBIND = NO); */
EXEC ORACLE OPTION (RELEASE_CURSOR = YES);

/* Function Description -----------------------------------------------------
Description:
    Routine to update existing tables in ORACLE.

    Methodology:
    The Finder data dictionary is assembled, sorted by table and column.
    Each column in the Finder dictionary is then fetched and compared
    with the table and column currently active in the current account.
    If the column parameters (type, width, scale, nulls permitted) do not
    match, then an ALTER TABLE SQL command is generated and executed.
    If the column is not found, then an ALTER TABLE ADD SQL command is
    generated.  If the defined column is wider than the dictionary
    definition, then an operator alert is generated.

Prototype:
    publicdef INT dba_update_tables(DB_ACCOUNT_STRUCT *db_account);
    
Parameters:     (indicate (I)/(O)/(M) for input/output/input-and-modified)
    (I) db_account  -(DB_ACCOUNT_STRUCT *) Account structure.
    
Return Value/Status:
    SUCCESS - Successful completion
    
Scope:
    PUBLIC
    
Limitations/Assumptions:

-----------------------------------------------------------------------------*/

/* BEGIN:   */
#if USE_PROTOTYPES
publicdef INT dba_update_tables (DB_ACCOUNT_STRUCT *db_account) 
#else
publicdef INT dba_update_tables (db_account)
DB_ACCOUNT_STRUCT *db_account;
#endif
    {
    INT status;
    INT i;
    CHAR table_validate_format[128];
    CHAR info[200];
    
    EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR account[31];
    VARCHAR scope[11];
    VARCHAR table[31];
    int count;
    EXEC SQL END DECLARE SECTION;
    
    /* retrieve string format       */
    strcpy (table_validate_format, mg_message (DB_VALIDATING_TABLE));
    
    sprintf (info, mg_message (DB_TABLE_UPDATE_INIT), db_account->scope,
             db_account->name);
    am_message (AM_DIALOG, info);
    am_message (AM_STATUS, info);
    
    V_FROMC (scope, db_account->scope);
    V_FROMC (account, db_account->name);
    
    EXEC SQL WHENEVER SQLERROR GOTO wayout;
    
    EXEC SQL SELECT COUNT (*)INTO : count FROM ESI.FINDER_TABLES T,
        ACCOUNT_TB_DEFS D WHERE T.TNAME = D.TABLE_NAME AND T.SCOPE =  : scope;
    
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    
    EXEC SQL DECLARE NEXT_TABLE CURSOR FOR SELECT T.TNAME FROM ESI.FINDER_TABLES T,
        ACCOUNT_TB_DEFS D WHERE T.TNAME = D.TABLE_NAME AND T.SCOPE =  :
                                          scope ORDER BY T.TNAME;
    
    EXEC SQL OPEN NEXT_TABLE;
    
    i = 1;
    EXEC SQL FETCH NEXT_TABLE INTO : table;
    while (OR_STATUS != OR_EOF)
        {
        V_SETZERO (table);
        
        sprintf (info, table_validate_format, table.arr, i++, count);
        am_message (AM_DIALOG, info);
        am_message (AM_STATUS, info);
        
        status = dba_update_1_table (db_account, (CHAR *)table.arr);
        
        EXEC SQL FETCH NEXT_TABLE INTO : table;
        }
wayout:
    EXEC SQL CLOSE NEXT_TABLE;
    
    status = SUCCESS;
    return status;
    }
/* END:     */
