/* DEC/CMS REPLACEMENT HISTORY, Element UT_DISPLAY_REPORT.C */
/* *3     2-JAN-1991 17:03:13 VINCE "(SPR 1) Fixed complation on Unix" */
/* *2    19-SEP-1990 11:35:53 VINCE "(SPR 1) initial checkin" */
/* *1    19-SEP-1990 11:34:40 VINCE "display a sql report on a VT100 screen and allow a user to scroll up and down." */
/* DEC/CMS REPLACEMENT HISTORY, Element UT_DISPLAY_REPORT.C */
/******************************************************************************

                Copyright Finder Graphics Systems, Inc. 1990
		   Unpublished -- All rights reserved

THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Finder Graphics Systems, Inc.  AND
MAY CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE
DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE
MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF

			Finder Graphics Systems, Inc.
			201 Tamal Vista Blvd
			Corte Madera, CA  USA 94925
			(415) 927-0100

(The above notice does not constitute an admission of publication or
unrestricted dissemination of the work)

******************************************************************************/

/*****************************************************************************
    This is a simple utility program to display a SQLPLUS report in a nice
    format on a VT100 screen.  It will maintain the column headings on the
    top of the screen and allow the user to page and scroll through the 
    data on the remainder of the screen.

    The report must be no wider than 80 characters.

    This was developed to display the report generated by Bill A.'s scout
    ticket report.
******************************************************************************/

#include "esi_gl_defs.h"
#include "esi_c_lib.h"

#define CLEARSCREEN	printf ("\033[H\033[J");
#define CLEAREOL	printf ("\033[K");
#define POS(line,col)	printf ("\033[%d;%dH", line+1, col+1);
#define PRINTINVERSE(a)	printf ("\033[7m%s\033[0m\033(B", a);

#define DISPLAY \
    POS(nheader, 0); \
    for (ii=0, tcp=body+top; ii<displaysize && *tcp; tcp++,ii++) { \
	CLEAREOL; printf ("%s\n", *tcp); \
    } \
    while (ii<displaysize) { POS(ii+nheader, 0); CLEAREOL; ii++; }


int main (argc, argv)
int  argc;
char *argv[];
{
    INT  ii, nheader, nbody, linesize, pagesize, displaysize, top;
    TCP  header, body, tcp;
    CHAR line[400];  /* big enough to handle a 132 char BOLD heading */
    CHAR com[10], err[82], *cp;
    BOOL inheader, needheader;
    FILE *in;

    linesize = 132;
    pagesize = 23;

    if (argc < 2) {

        /* parse argv[0] for the name of the executable */
	strcpy (line, argv[0]);
	while ( (cp=strpbrk(line, "]:/>")) ) strcpy (line, ++cp);
	if ( (cp=strrchr(line, '.')) ) *cp = NUL;
	ts_sto_upper (line);

        printf ("\nUsage: %s filename\n\n", line);
	printf ("Where filename is a SQL output created with ");
	printf ("SQL's SPOOL command.\n\n");
	exit (EXIT_SUCCESS);
    }

    if ( (in=fopen(argv[1],"r")) == (FILE *)0) {
	printf ("Can't open %s for reading.\n", argv[1]);
	exit (EXIT_SUCCESS);
    }

    /*  read lines into our buffer TCPs. Header lines will be the first set */
    /*  starting with a form feed and ending with a line having a dash or   */
    /*  equal sign as the first non-white character.  The rest will be BODY */
    /*  lines.  Headers after the first one  will be discarded.             */

    header = (TCP)NULL; nheader = 0;
    body   = (TCP)NULL; nbody   = 0;

    needheader = TRUE;
    inheader   = FALSE;

    while (fgets(line, sizeof line, in) != NULL) {
	line[strlen(line)-1] = NUL;	               /* remove NEWLINE */
	if (strlen(line) > linesize) line[linesize] = NUL;

	if (line[0] == '\f') { ts_shift (line, -1); inheader = TRUE; }

	if (! inheader) {
	    if (line[0] != NUL) {
		ts_tcp_append (&body, line);
		nbody++;
	    }
	}
	else {
	    if (needheader) {
	        ts_tcp_append (&header, line);
		nheader++;
	    }

	    /* the last header line will have '-' or '=' as the		*/
	    /* first non-white character.				*/

	    cp = line;   /* skip over white space (tabs and spaces) */
	    while ( *cp && (*cp == ' ' || *cp == '\t') ) cp++;

	    /* check if this is the last header line */
	    if (*cp == '-' || *cp == '=') {
		needheader = FALSE;
		inheader = FALSE;
	    }
	}
    }

    if (nbody == 0) {
        CLEARSCREEN;
        POS (10,0);
        printf ("------------------------------------\n");
        printf ("No records found in the report file:\n");
        PRINTINVERSE (argv[1]);
        printf ("\n------------------------------------\n");
        POS (23,0);
        printf ("Press <RETURN> to continue --");
        gets (com);
        exit (EXIT_SUCCESS);
    }

    displaysize = pagesize - nheader - 1;

    top = 0;
    com[0] = 'R';				/* start with a Refresh */
    err[0] = NUL;

    while (com[0] != 'Q' && com[0] != 'E') {
	switch (com[0]) {
	    case 'T':
		if (top == 0) strcpy (err, "AT FIRST RECORD");
		else { top = 0; DISPLAY; }
		break;

	    case 'N': case NUL:
		if (top+displaysize < nbody) { top += displaysize; DISPLAY; }
		else strcpy (err, "AT LAST RECORD");
		break;

	    case 'P':
		if (top == 0) strcpy (err, "AT FIRST RECORD");
		else {
		    top -= displaysize;
		    if (top < 0) top = 0;
		    DISPLAY;
		}
		break;

	    case 'R':
		CLEARSCREEN;
		if (header) for (tcp=header; *tcp; tcp++) printf ("%s\n", *tcp);
		DISPLAY;
		break;

	    case 'U':
		if (top == 0) strcpy (err, "AT FIRST RECORD");
		else { top -= 1; DISPLAY; }
		break;

	    case 'D':
		if (top+1 < nbody) { top += 1; DISPLAY; }
		else strcpy (err, "AT LAST RECORD");
		break;		    
	}

	POS(pagesize-1, 0);
	CLEAREOL;
	if (err[0] != NUL) PRINTINVERSE(err);
	printf (" RTN/(N)ext, (P)rev, (T)op, (U)p, (D)wn, (R)efresh, (Q/E)xit: ");
	err[0] = NUL;
	gets (com);
	ts_sto_upper (com);
    }

    CLEARSCREEN;
    ts_tcp_free (header);
    ts_tcp_free (body);

    exit (EXIT_SUCCESS);
}
