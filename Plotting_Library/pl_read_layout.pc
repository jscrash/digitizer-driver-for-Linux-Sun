/* DEC/CMS REPLACEMENT HISTORY, Element PL_READ_LAYOUT.PC */
/*  5     3-MAR-1992 13:19:53 JILL "(SPR 0) Read new GPD layouts" */
/* *4     6-JUN-1991 16:58:17 MING "(SPR 0) new plot file managment" */
/* *3    17-OCT-1990 18:03:48 GILLESPIE "(SPR 1001) Add nwins to zone[i] test" */
/* *2    17-OCT-1990 16:11:13 GILLESPIE "(SPR 1000) Merge Ernie deltas" */
/* *1    12-OCT-1990 17:47:43 GILLESPIE "Merge Ernie Deltas" */
/* DEC/CMS REPLACEMENT HISTORY, Element PL_READ_LAYOUT.PC */
/******************************************************************************

                Copyright Finder Graphics Systems, Inc. 1990
		   Unpublished -- All rights reserved

THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Finder Graphics Systems, Inc.  AND
MAY CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE
DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE
MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF

			Finder Graphics Systems, Inc.
			201 Tamal Vista Blvd
			Corte Madera, CA  USA 94925
			(415) 927-0100

(The above notice does not constitute an admission of publication or
unrestricted dissemination of the work)

******************************************************************************/



/* Function Description -----------------------------------------------------
Description:

Prototype:
    publicdef INT func (arg);

Parameters:	    (indicate (I)/(O)/(M) for input/output/input-and-modified)
    (I) arg	- description

Return Value/Status:
    SUCCESS	- Successfull completion
    FAIL	- Unsuccessfull completion

Scope:
    PUBLIC
    PRIVATE to <module_description>

Limitations/Assumptions:

-----------------------------------------------------------------------------*/


#ifndef ESI_PL_H
#include "esi_pl.h"
#endif

#ifndef ESI_ORCALE_H
#include "esi_oracle.h"
#endif

#ifndef ESI_AM_H
#include "esi_am.h"
#endif

#ifndef ESI_QS_H
#include "esi_qs.h"
#endif

static CHAR *window_type_codes[] = 
  {
  "MAP",
  "CROSS SECTION",
  "TITLE BLOCK",
  "INDEX MAP",
  "NORTH ARROW",
  "SCALE BAR",
  "WELL LEGEND",
  "METAFILE",
  "EMPTY WINDOW",
  0 };

static CHAR *border_codes[] =
  {
  "NONE",
  "FINE",
  "BOLD",
  "FINE FINE",
  "BOLD FINE",
  "FINE BOLD",
  "BOLD BOLD",
  "TRIPLE FINE",
  0 };

static CHAR *halignment_codes[] =
  {
  "TOP",
  "BELOW",
  "CENTER",
  0 };

static CHAR *valignment_codes[] =
  {
  "LEFT",
  "RIGHT",
  "CENTER",
  0};

static CHAR *zone_codes[] =
  {
  "BELOW",
  "RIGHT",
  "ABOVE",
  "LEFT",
  0 };

#if USE_PROTOTYPES
publicdef INT pl_read_layout(PLOT_LAYOUT *pl, CHAR *name,INT bw_type)
#else
publicdef INT pl_read_layout(pl,name,bw_type)
PLOT_LAYOUT *pl;
CHAR *name;
INT bw_type;
#endif
{
  EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR window_type[24];
    VARCHAR border[24];
    VARCHAR orientation[1];
    VARCHAR zone_vchr[24];
    int sequence;
    VARCHAR alignment[24];
    double margin;
    double max_width;
    double max_height;
    double mini_width;
    double mini_height;
    VARCHAR stmt[1000];
    VARCHAR lyt_name_v[44];
    VARCHAR lyt_type[44];
    VARCHAR window_name[44];
    VARCHAR plot_layout_unit[24];
    double text_factor;
    short uniti;
    short text_factori;
    short max_widthi;
    short max_heighti;
    short mini_widthi;
    short mini_heighti;
  EXEC SQL END DECLARE SECTION;
  
  INT status = SUCCESS;
  INT i;
  INT zone;
  INT border_style;
  INT align;
  INT win_type;
  DOUBLE user_unit_to_inches;
  PROJECT_NAME project;
  PLOT_LAYOUT_WIN pl_win;

/* ------------ */
/* empty layout */
/* ------------ */
  tc_zeroes (pl,sizeof (PLOT_LAYOUT));
  if (strcmp (name,"") == 0)
      {
      pl->layout_name[0] = '\0';
      pl->margin = 0.0;
      pl->border = 0;
      pl->orientation = 0;
      pl->text_factor = 1;
      strcpy (pl->layout_unit,"INCHES");
      for (i = 0; i < 4; ++i)
	   {
	   pl->zone[i].nwins = 0;
	   }
      return SUCCESS;
      }


  qs_inq_c (QS_PROJECT_NAME,project,(INT *) 0);

  V_FROMC (lyt_name_v,name);
  stmt.len = sprintf((CHAR *) stmt.arr,
"SELECT OUTER_MARGIN, BORDER, ORIENTATION, PLOT_LAYOUT_UNIT, TEXT_FACTOR \
 FROM %s.PLOT_LAYOUT WHERE LAYOUT_NAME = :lyt_name_v \
 AND LAYOUT_TYPE = :type",project);

  if (bw_type == PL_MAP)
    {
    V_FROMC (lyt_type,"MAP");
    }
  else
    {
    V_FROMC (lyt_type,"XSECT");
    }

  EXEC SQL WHENEVER SQLERROR GOTO err;

  EXEC SQL PREPARE S1 FROM :stmt;
  EXEC SQL DECLARE C1 CURSOR FOR S1;
  EXEC SQL OPEN C1 USING :lyt_name_v,:lyt_type;

  EXEC SQL FETCH C1 INTO :margin, :border, :orientation, 
			 :plot_layout_unit:uniti, :text_factor:text_factori;

  if (OR_STATUS == OR_EOF)
    {
    am_message (AM_STATUS,"No such layout defined");
    return FAIL;
    }

 /* --------------------------------- */
 /* plot_layout_unit default = INCHES */
 /* --------------------------------- */
 if (uniti == -1)
   {
   V_FROMC (plot_layout_unit,"INCHES");
   }

 /* ------------------------- */
 /* text factor default = 1.0 */
 /* ------------------------- */
 if (text_factori == -1)
   {
   text_factor == 1.0;
   }

/* -------------------------------------------------------------------- */
/* init layout structure and the max_width and max_height of every zone */
/* -------------------------------------------------------------------- */
  for (i = 0; i < 4; ++i)
    {
    if (i == 0 || i == 2)
      {
      pl->zone[i].max_width = 0.0;
      pl->zone[i].max_height = -99999.0;
      }
    else
      {
      pl->zone[i].max_width = -99999.0;
      pl->zone[i].max_height = 0.0;
      }
    }

  V_FROMV (pl->layout_unit, plot_layout_unit);
  user_unit_to_inches = 1.0;
  tu_unit_conversion (user_unit_to_inches, pl->layout_unit, 
			&user_unit_to_inches, "INCHES");

  pl->margin = margin * user_unit_to_inches;

  V_SETZERO (border);
  border_style = ts_switch ((CHAR *) border.arr, border_codes);
  if (border_style == -1)
    {
    border_style = ts_switch ("FINE",border_codes);
    }

  pl->border = border_style;
  pl->orientation = (orientation.arr[0] == 'H' ?  0 : 1);
  pl->text_factor = text_factor;


  EXEC SQL CLOSE C1;

  stmt.len = sprintf((CHAR *) stmt.arr,
"SELECT WINDOW_TYPE, WINDOW_NAME, BORDER, MARGIN, ZONE, \
SEQUENCE, MAX_WIDTH, MAX_HEIGHT, MINI_WIDTH, MINI_HEIGHT, ALIGNMENT \
FROM %s.PLOT_LAYOUT_WIN WHERE LAYOUT_NAME = :lyt_name_v AND \
LAYOUT_TYPE = :type ORDER BY ZONE,SEQUENCE ",project);

  EXEC SQL PREPARE S2 FROM :stmt;
  EXEC SQL DECLARE C2 CURSOR FOR S2;
  EXEC SQL OPEN C2 USING :lyt_name_v, :lyt_type;

  EXEC SQL FETCH C2 INTO :window_type,:window_name,:border, 
		   :margin,:zone_vchr,:sequence,
		   :max_width:max_widthi,:max_height:max_heighti,
		   :mini_width:mini_widthi, :mini_height:mini_heighti,
		   :alignment;

  while (OR_STATUS == SUCCESS)
    {
    V_SETZERO (window_type);
    V_SETZERO (border);
    V_SETZERO (zone_vchr);
    V_SETZERO (alignment);
    zone = ts_switch ((CHAR *) zone_vchr.arr, zone_codes);
    win_type = ts_switch ((CHAR *) window_type.arr, window_type_codes);

/* -------------------------------------------- */
/* if zone and window type are correct          */
/* then store in the plot layout data sturcture */
/* else skip it                                 */
/* -------------------------------------------- */
    if (zone >= 0 && win_type >= 0)
      {
      border_style = ts_switch ((CHAR *) border.arr, border_codes);
      if (border_style == -1)
	{
	border_style = ts_switch ("FINE",border_codes);
	}

/* ----------------------------------------------------------------- */
/* check alignment code with repect to corresponding zone            */
/* if alignment is not valid in the zone e.g BELOW for vertical zone */
/* CENTER alignment will be assigned                                 */
/* ----------------------------------------------------------------- */
      if (zone == PL_ZBELOW | zone == PL_ZABOVE)
	{
        align = ts_switch ((CHAR *) alignment.arr, halignment_codes);
	}
      else
	{
        align = ts_switch ((CHAR *) alignment.arr, valignment_codes);
	}

      if (align == -1)
	{
	align = ts_switch ("CENTER",halignment_codes);
	}


/* ------------------------------------------------- */
/* default max width = default max height = 5 inches */
/* default min width = default min height = 0 inches */
/* ------------------------------------------------- */
      if (max_widthi == -1)
	{
	max_width = 5.0;
	}

      if (max_heighti == -1)
	{
	max_height = 5.0;
	}

      if (mini_widthi == -1)
	{
	mini_width = 0.0;
	}

      if (mini_heighti == -1)
	{
	mini_height = 0.0;
	}

      pl->zone[zone].win[pl->zone[zone].nwins].window_type  = win_type;
      V_FROMV (pl->zone[zone].win[pl->zone[zone].nwins].window_name, window_name);
      pl->zone[zone].win[pl->zone[zone].nwins].border = border_style;
      margin *= user_unit_to_inches;
      max_width *= user_unit_to_inches;
      max_height *= user_unit_to_inches;
      mini_width *= user_unit_to_inches;
      mini_height *= user_unit_to_inches;
      pl->zone[zone].win[pl->zone[zone].nwins].margin = margin;
      pl->zone[zone].win[pl->zone[zone].nwins].sequence = sequence;
      pl->zone[zone].win[pl->zone[zone].nwins].max_width = max_width;
      pl->zone[zone].win[pl->zone[zone].nwins].max_height = max_height;
      pl->zone[zone].win[pl->zone[zone].nwins].mini_width = mini_width;
      pl->zone[zone].win[pl->zone[zone].nwins].mini_height = mini_height;
      pl->zone[zone].win[pl->zone[zone].nwins].alignment = align; 

/* ------------------------------------------- */
/* calculate the width and height of each zone */
/* ------------------------------------------- */
      if (zone == PL_ZBELOW || zone == PL_ZABOVE)    /* below and above zone */
        {
        pl->zone[zone].max_width += max_width + 2*margin;

        if (pl->zone[zone].max_height < max_height + 2*margin)
  	  {
	  pl->zone[zone].max_height = max_height + 2*margin;
	  }
        }
      else    /* right and left zone */
        {
        pl->zone[zone].max_height += max_height + 2*margin;

        if (pl->zone[zone].max_width < max_width + 2*margin)
	  {
	  pl->zone[zone].max_width = max_width + 2*margin;
	  }
        }

      pl->zone[zone].nwins++;
    }

    EXEC SQL FETCH C2 INTO :window_type,:window_name,:border, 
			   :margin,:zone_vchr,:sequence,
			   :max_width:max_widthi,:max_height:max_heighti,
			   :mini_width:mini_widthi, :mini_height:mini_heighti,
			   :alignment;
    }
  EXEC SQL CLOSE C2;

  for (i = 0; i < 4; ++i)
    {
    if (pl->zone[i].nwins == 0)
      {
      pl->zone[i].max_height = 0.0;
      pl->zone[i].max_width = 0.0;
      }
    }

  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL COMMIT WORK;
  return status ;

err:
  printf ("%s\n",OR_MESSAGE);
  EXEC SQL ROLLBACK WORK;
  return FAIL;
} 

