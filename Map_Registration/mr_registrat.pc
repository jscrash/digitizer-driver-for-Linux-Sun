/* DEC/CMS REPLACEMENT HISTORY, Element MR_REGISTRAT.PC */
/* *10   12-AUG-1991 17:16:07 MING "(SPR 0) beep when getting the checkpoints" */
/* *9     9-AUG-1991 15:09:01 MING "(SPR 3529) Xflush after open dialog box in check points " */
/* *8     6-AUG-1991 14:52:23 KEE "(SPR 8778) Fix dim backup button for the first prompt (case 3489)" */
/* *7    23-AUG-1990 17:36:02 JESSIE "(SPR 1) fix include files" */
/* *6    18-APR-1990 16:50:50 WALTERS "(SPR 5187) Convert all character input to uppercase..." */
/* *5    22-MAR-1990 01:26:15 GILLESPIE "(SPR 1) Change %f to %lf in sscanf (since we are translating doubles...)" */
/* *4     7-MAR-1990 17:25:10 WALTERS "(SPR 0) Remove FLOAT types from system" */
/* *3    21-FEB-1990 13:12:54 WALTERS "(SPR 0) Section-Township-Range-Meridian addition to map setup dialog" */
/* *2    16-FEB-1990 13:40:29 WALTERS "(SPR 0) Change mr_get_section_corners to topologic format" */
/* *1    16-FEB-1990 13:37:25 WALTERS "map registration" */
/* DEC/CMS REPLACEMENT HISTORY, Element MR_REGISTRAT.PC */
/* DEC/CMS REPLACEMENT HISTORY, Element MR_REGISTRAT.C*/
/* *5    15-FEB-1990 10:45:44 WALTERS "(SPR 0) Changes in map setup dialog"*/
/* *4    13-NOV-1989 13:28:55 JULIAN "(SPR 1) Integrate external tablet functions into finder."*/
/* *3    10-OCT-1989 09:59:08 PURNA "(SPR 5020) mods for CT parameter change"*/
/* *2    13-JUL-1989 14:07:08 GORDON "(SPR 0) add call to wm_set_mouse_menu"*/
/* *1    19-JUN-1989 13:15:32 SYSTEM ""*/
/* DEC/CMS REPLACEMENT HISTORY, Element MR_REGISTRAT.C*/

/******************************************************************************

                Copyright Exploration Systems, Inc. 1989
		   Unpublished -- All rights reserved

THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Exploration Systems, Inc.  AND MAY
CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE
DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE
MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF

			Exploration Systems, Inc.
			579 Market Street
			San Francisco, CA  USA 94105
			(415) 974-1600

(The above notice does not constitute an admission of publication or
unrestricted dissemination of the work)

******************************************************************************/


/******************************************************************************

    Service routines for the map registration program

******************************************************************************/

#include "esi_math.h"
#ifndef CTYPE_H
#include "ctype.h"
#endif
#ifndef ESI_C_LIB_H
#include "esi_c_lib.h"
#endif
#ifndef ESI_MR_H
#include "esi_mr.h"
#endif
#ifndef ESI_MR_ERR_H
#include "esi_mr_err.h"
#endif
#ifndef ESI_MR_MSG_H
#include "esi_mr_msg.h"
#endif
#ifndef ESI_AM_H
#include "esi_am.h"
#endif
#ifndef ESI_WI_H
#include "esi_wi.h"
#endif
#ifndef ESI_WM_H
#include "esi_wm.h"
#endif
#ifndef ESI_TS_H
#include "esi_ts.h"
#endif
#ifndef ESI_NL_H
#include "esi_nl.h"
#endif
#ifndef ESI_CT_H
#include "esi_ct.h"
#endif
#ifndef ESI_QS_H
#include "esi_qs.h"
#endif
#ifndef ESI_MP_H
#include "esi_mp.h"
#endif
#ifndef ESI_MG_H
#include "esi_mg.h"
#endif
#ifndef ESI_ORACLE_H
#include "esi_oracle.h"
#endif

#include "esi_wi_int.x"

#include "mr_reg_map.rh"

#define ResourceFile            "MR_REG_MAP"
#define null_string              ""

static INT  CPOpened = FALSE;
static INT  CPID = 0;
static INT  RPOpened = FALSE;
static INT  RPID = 0;
static INT  STROpened = FALSE;
static INT  STRID = 0;
static INT  CKID = 0;
static FLOAT Dummy = 0.;


/* **************************************************************************** */

publicdef INT mr_get_xy_control_point(message, instructions, projection, x, y)
CHAR *message, *instructions;
PROJECTION_STRUCTURE *projection;
DOUBLE *x, *y;
{
    CHAR Text[128], xstr[128], ystr[128];
    INT Item, Value, done = FALSE;
    INT status;
    DOUBLE temp;

    if (CPID == 0)
        am_define_resource(AM_DIALOG, ResourceFile,
                  DIGITIZE_CONTROL_POINT, NULL_FUNCTION_PTR, &CPID, NULL);

    wi_set_dialog_text(CPID, DIG_PNT_STAT_MESSAGE, message);
    wi_set_dialog_text(CPID, DIG_PNT_STAT_ENTER, instructions);
    sprintf(xstr, "%.4lf", *x);
    wi_set_dialog_text(CPID, DIG_PNT_EDIT_X, xstr);
    sprintf(ystr, "%.4lf", *y);
    wi_set_dialog_text(CPID, DIG_PNT_EDIT_Y, ystr);
    
    if (ts_like(instructions,"*Upper Left*",'*') EQUALS TRUE)
    {
        wi_enable_dialog_item(CPID, DIG_PNT_BTN_BACKUP, OFF);
    }
    else
    {
        wi_enable_dialog_item(CPID, DIG_PNT_BTN_BACKUP, ON);
    }

    if (CPOpened == FALSE)
    {
        CPOpened = TRUE;
        wipush();
        wi_open_dialog(CPID);
    }

    while (done == FALSE)
    {
        wi_request_dialog_item(&CPID, &Item, &Value, Text);

        switch(Item)
        {
            case DIG_PNT_BTN_OK:
                 wi_query_dialog_item(CPID, DIG_PNT_EDIT_X, &Value, xstr);
                 wi_query_dialog_item(CPID, DIG_PNT_EDIT_Y, &Value, ystr);
                 if ((ts_isfloat(xstr) <= 0) && (ts_isfloat(ystr) <= 0))
                 {
                     wi_set_dialog_text(CPID,DIG_PNT_STAT_MESSAGE,
                                        mg_message(MR_XY_ERROR));
                     wibeep(1);
                 }
                 else if ((ts_isfloat(xstr) <= 0) && (ts_isfloat(ystr) > 0))
                 {
                     wi_set_dialog_text(CPID, DIG_PNT_STAT_MESSAGE,
                                        mg_message(MR_X_ERROR));
                     wibeep(1);
                 }
                 else if ((ts_isfloat(xstr) > 0) && (ts_isfloat(ystr) <= 0))
                 {
                     wi_set_dialog_text(CPID, DIG_PNT_STAT_MESSAGE,
                                        mg_message(MR_Y_ERROR));
                     wibeep(1);
                 }
                 else
                 {
                     wi_set_dialog_text(CPID, DIG_PNT_STAT_MESSAGE, 
                                        null_string);
                     status = SUCCESS;
                     sscanf(xstr, "%lf", x);
                     sscanf(ystr, "%lf", y);

/*  Reverse coordinates, if GEODETIC, so that they can be input as lat,lon  */

                     if(projection != (PROJECTION_STRUCTURE *)NULL)
                         if(projection->projection_type == 0)
                         {
                             temp = *x;
                             *x = *y;
                             *y = temp;
                         }
                         
                     done = TRUE;
                 }
                 break;

            case DIG_PNT_BTN_BACKUP:
                 wi_set_dialog_text(CPID, DIG_PNT_STAT_MESSAGE, null_string);
                 status = 2;
                 done = TRUE;
                 break;

            case DIG_PNT_BTN_CANCEL:
                 wi_set_dialog_text(CPID, DIG_PNT_STAT_MESSAGE, null_string);
                 status = 3;
                 done = TRUE;
                 break;

            default:
                 break;
        }
    }
    return status;
}


/* **************************************************************************** */

publicdef INT mr_get_xy_control_point_term()
{
    am_release_resource(CPID);
    wipop();

    CPOpened = FALSE;
    CPID = 0;

    return SUCCESS;

}


/* **************************************************************************** */

publicdef INT mr_get_projection (map_name, message, projection_id,
                                 numpoints, coord_system)
CHAR *map_name;
CHAR *message;
PROJECTION_ID projection_id;
INT *numpoints;
CHAR coord_system[];
{
    CHAR Text[128], numpoints_string[128],**projection_list;
    INT Item, Value, done = FALSE, nselected, no_projections;
    INT selected;
    MAP_STRUCTURE *mapdef;
    CHAR **tcp;
    INT status;
    BOOL ctype;



/*  Retrieve the map definition   */

    status = mp_get_current_map(&mapdef);
    if(status != SUCCESS)
    {
       am_message(AM_ALERT,mg_message(MR_NO_MAP));
       return FAIL;
    }
    if ((strcmp(mapdef->map_coordinate_system,"ATS") == 0) OR
	(strcmp(mapdef->map_coordinate_system,"USPLS") == 0))
        ctype = FALSE;
    else
        ctype = TRUE;

    if (RPID == 0)
        am_define_resource(AM_DIALOG, ResourceFile, REG_GET_PROJECTION, 
	NULL_FUNCTION_PTR, &RPID, NULL);

    wi_set_dialog_text(RPID, REG_GET_STAT_MESSAGE, message);

    ct_projection_list(&projection_list, &no_projections, FALSE);
    wi_set_selections(RPID, REG_GET_SEL_BOX, REG_GET_SCR_BAR, no_projections,
            1, projection_list);

    for (selected = 0, tcp = projection_list;
	 selected < no_projections;
	 tcp++, selected++)
       {
       if (strcmp(*tcp, mapdef -> map_projection) EQUALS 0)
	   {
           break;
           }
       }
       strcpy(projection_id,mapdef->map_projection);
       wi_set_default_sel(RPID, REG_GET_SEL_BOX, selected + 1);
       wi_set_dialog_value(RPID, REG_GET_SCR_BAR, 0);

/*  Set default coordinate type  */

    if(ctype)
    {
        wi_set_dialog_value(RPID,REG_XY_COORD,ON);
        wi_set_dialog_value(RPID,REG_USPLS_COORD,OFF);
        wi_set_dialog_value(RPID,REG_ATS_COORD,OFF);
        sprintf(numpoints_string, "%d", *numpoints);
        wi_enable_dialog_item(RPID,REG_GET_STAT_POINTS,ON);
        wi_enable_dialog_item(RPID,REG_GET_EDIT_POINTS,ON);
        wi_set_dialog_text(RPID, REG_GET_EDIT_POINTS, numpoints_string);
        strcpy(coord_system, mapdef->map_coordinate_system);
    }
    else if(strcmp(mapdef->map_coordinate_system,"USPLS") == 0)
    {
        wi_set_dialog_value(RPID,REG_XY_COORD,OFF);
        wi_set_dialog_value(RPID,REG_USPLS_COORD,ON);
        wi_set_dialog_value(RPID,REG_ATS_COORD,OFF);
        wi_enable_dialog_item(RPID,REG_GET_SEL_BOX,OFF);
        wi_enable_dialog_item(RPID,REG_GET_STAT_POINTS,OFF);
        wi_enable_dialog_item(RPID,REG_GET_EDIT_POINTS,OFF);
        strcpy(coord_system,"USPLS");
    }
    else if(strcmp(mapdef->map_coordinate_system,"ATS") == 0)
    {
        wi_set_dialog_value(RPID,REG_XY_COORD,OFF);
        wi_set_dialog_value(RPID,REG_USPLS_COORD,OFF);
        wi_set_dialog_value(RPID,REG_ATS_COORD,ON);
        wi_enable_dialog_item(RPID,REG_GET_SEL_BOX,OFF);
        wi_enable_dialog_item(RPID,REG_GET_STAT_POINTS,OFF);
        wi_enable_dialog_item(RPID,REG_GET_EDIT_POINTS,OFF);
        strcpy(coord_system,"ATS");
    }

    if (RPOpened == FALSE)
    {
        RPOpened = TRUE;
        wipush();
        wi_open_dialog(RPID);

        while (done == FALSE)
        {
            wi_request_dialog_item(&RPID, &Item, &Value, Text);

            switch(Item)
            {

                case REG_XY_COORD:

                wi_set_dialog_value(RPID,REG_XY_COORD,ON);
                wi_set_dialog_value(RPID,REG_USPLS_COORD,OFF);
                wi_set_dialog_value(RPID,REG_ATS_COORD,OFF);
                sprintf(numpoints_string, "%d", *numpoints);
                wi_enable_dialog_item(RPID,REG_GET_SEL_BOX,ON);
                wi_enable_dialog_item(RPID,REG_GET_STAT_POINTS,ON);
                wi_enable_dialog_item(RPID,REG_GET_EDIT_POINTS,ON);
                wi_set_dialog_text(RPID, REG_GET_EDIT_POINTS, numpoints_string);
                strcpy(coord_system,mapdef->map_coordinate_system);
                break;

                case REG_USPLS_COORD:

                wi_set_dialog_value(RPID,REG_XY_COORD,OFF);
                wi_set_dialog_value(RPID,REG_USPLS_COORD,ON);
                wi_set_dialog_value(RPID,REG_ATS_COORD,OFF);
                wi_enable_dialog_item(RPID,REG_GET_SEL_BOX,OFF);
                wi_enable_dialog_item(RPID,REG_GET_STAT_POINTS,OFF);
                wi_enable_dialog_item(RPID,REG_GET_EDIT_POINTS,OFF);
                strcpy(coord_system,"USPLS");
                break;

                case REG_ATS_COORD:

                wi_set_dialog_value(RPID,REG_XY_COORD,OFF);
                wi_set_dialog_value(RPID,REG_USPLS_COORD,OFF);
                wi_set_dialog_value(RPID,REG_ATS_COORD,ON);
                wi_enable_dialog_item(RPID,REG_GET_SEL_BOX,OFF);
                wi_enable_dialog_item(RPID,REG_GET_STAT_POINTS,OFF);
                wi_enable_dialog_item(RPID,REG_GET_EDIT_POINTS,OFF);
                strcpy(coord_system,"ATS");
                break;

                case REG_GET_BTN_OK:

                 if(ctype)
                 {
                     wi_query_dialog_item(RPID, REG_GET_EDIT_POINTS, 
                                          &Value, numpoints_string);
                     if ((ts_isfloat(numpoints_string) <= 0))
                     {
                         wi_set_dialog_text(RPID,REG_GET_STAT_MESSAGE,
                                          mg_message(MR_NPTS_ERROR));
                         wibeep(1);
                         break;
                     }
                     else
                     {
                         sscanf(numpoints_string, "%d", numpoints);
                         if (*numpoints < 2)
                         {
                            wi_set_dialog_text(RPID,REG_GET_STAT_MESSAGE,
                                       mg_message(MR_MORE_CONTROL));
                            wibeep(1);
                            break;
                         }
                     }
                     wi_query_selections(RPID, REG_GET_SEL_BOX, 
                                         &nselected, &selected);
                     if (nselected <= 0)
                     {
                         wi_set_dialog_text(RPID, REG_GET_STAT_MESSAGE,
                              mg_message(MR_NO_PROJECTION));
                         wibeep(1);
                         break;
                     }
                     else
                     {
                         wi_set_dialog_text(RPID, REG_GET_STAT_MESSAGE, 
                                            null_string);
                         status = 1;
                         done = TRUE;
                         strcpy(projection_id, projection_list[selected-1]);
                     }
                 }
                 status = SUCCESS;
                 done = TRUE;
                 break;

                 case REG_GET_BTN_CANCEL:
                 wi_set_dialog_text(RPID, REG_GET_STAT_MESSAGE, null_string);
                 status = 2;
                 done = TRUE;
                 break;

                default:
                 break;
            }
        }
    }

    ts_tcp_free(projection_list);
    return status;
}

/* **************************************************************************** */
publicdef INT mr_get_projection_term()
{
    am_release_resource(RPID);
    wipop();

    RPOpened = FALSE;
    RPID = 0;

    return SUCCESS;
}

/* **************************************************************************** */
publicdef INT mr_calc_xform( xy_cntl, xy_tablet, n_points, tr_mat )

/* Compute tablet registration transform  */

DOUBLE xy_cntl[][2];                    /* Control values (feet, meters, etc.) */
DOUBLE xy_tablet[][2];                  /* Tablet values (NDC) */
INT n_points;                          /* Number of control points  */
DOUBLE tr_mat[2][2];                   /* Pointer to returned transform matrix*/

{
    INT i, j, k;
    DOUBLE det;
    DOUBLE dxc, dyc, dxt, dyt;
    DOUBLE wcs_mat[2][2], inv_mat[2][2], tab_mat[2][2];
    DOUBLE angle, scale;


/*----------------------------------------------------------------------------*/
/*	    check n_points first					      */
/*		we cannot compute the transformation with less than 2 points  */
/*----------------------------------------------------------------------------*/

    if ( n_points < 2 )
	return FAIL;

/*----------------------------------------------------------------------------*/
/*	    compute for the 2 points case   				      */
/*----------------------------------------------------------------------------*/

    if ( n_points EQUALS 2 )
    {
/*								    */
/*		the scale is supposed to be the same on x and y	    */
/*		the 2 points need to be on a diagonal		    */
/*  the transformation is just	a isotropic scaling and a rotation  */
/*								    */

        dxc = xy_cntl[1][0] - xy_cntl[0][0];
        dyc = xy_cntl[1][1] - xy_cntl[0][1];

        dxt = xy_tablet[1][0] - xy_tablet[0][0];
        dyt = xy_tablet[1][1] - xy_tablet[0][1];

	if ( dxc EQUALS 0.0  OR  dyc EQUALS 0.0 )
	    return FAIL;

	angle = atan2(dyt,dxt) - atan2(dyc,dxc) ;

	dxc = sqrt ( dxc*dxc + dyc*dyc );
	dxt = sqrt ( dxt*dxt + dyt*dyt );

	scale = dxc / dxt ;

	tr_mat[0][0] = cos( angle ) / scale;
	tr_mat[1][0] = sin(angle) / scale;
	tr_mat[0][1] = -tr_mat[1][0];
	tr_mat[1][1] = tr_mat[0][0];

	return SUCCESS;
    }

/*----------------------------------------------------------------------------*/
/*		the general case is for 3 points or more		    */
/*----------------------------------------------------------------------------*/
/*		the n points can be located anywhere		    */
/*								    */
/*		the transformation from world to tab		    */
/*		    is computed as a whole			    */
/*		through a least square estimation		    */
/*								    */
/*								    */
/*----------------------------------------------------------------------------*/
/*								    */
/*								    */
/*  The transformation can be described as			    */
/*	[ tab(2,n) ]  =  [ TR(2,2) ]  *  [ W(2,n) ]		    */
/*								    */
/*	    [tab ] is the matrix of the n tablet vectors	    */
/*	    [ W ] is the matrix of the n world vectors		    */
/*	    [ TR ] is the one we want				    */
/*								    */
/*  least squares estimation....				    */
/*	    the new 2*2 problem to solve is given by		    */
/*								    */
/*		     if W(n,2) is the transposed of W(2,n)	    */
/*								    */
/*	( TAB(2,n) * W(n,2) ) = TR(2,2)  * (  W(2,n) * W(n,2) )	    */
/*								    */
/*	if tab = TAB(2,n) * W(n,2)				    */
/*	and wcs = W(2,n) * W(n,2)				    */
/*								    */
/*	then :							    */
/*	    tab = TR * wcs					    */
/*								    */
/*	and :							    */
/*								    */
/*	TR = tab * ( 1/ wcs )					    */
/*								    */
/*----------------------------------------------------------------------------*/


/*			    fill   tab_mat  and  wcs_mat		*/

    for ( i = 0  ; i < 2 ; i++ )    /*  loop on lines		*/
	for ( j = 0; j < 2 ; j++ )  /*	loop on columns		*/
	{
	    tab_mat[i][j] = 0.0;
	    wcs_mat[i][j] = 0.0;
	}

    for ( i = 1  ; i < n_points; i++ )    /*  loop on the vectors	*/
    {
	dxt = xy_tablet[i][0] - xy_tablet[0][0];
	dyt = xy_tablet[i][1] - xy_tablet[0][1];
	dxc = xy_cntl[i][0] - xy_cntl[0][0];
	dyc = xy_cntl[i][1] - xy_cntl[0][1];

	tab_mat[0][0] += dxt * dxc ;
	tab_mat[0][1] += dxt * dyc ;
	tab_mat[1][0] += dyt * dxc ;
	tab_mat[1][1] += dyt * dyc ;

	wcs_mat[0][0] += dxc * dxc;
	wcs_mat[1][1] += dyc * dyc;
	wcs_mat[0][1] += dxc * dyc ;
	wcs_mat[1][0] = wcs_mat[0][1];	/*  wcs is symetrical	*/
    }

/*		    compute determinant of wcs_mat		*/

    det = wcs_mat[0][0] * wcs_mat[1][1] - wcs_mat[0][1] * wcs_mat[1][0] ;

    if ( det EQUALS 0.0)   return FAIL;

/*		    compute inv_mat inverse of wcs_mat		*/

    inv_mat[0][0] =   wcs_mat[1][1]  / det ;
    inv_mat[1][1] =   wcs_mat[0][0]  / det ;
    inv_mat[0][1] = - wcs_mat[0][1]  / det ;
    inv_mat[1][0] = - wcs_mat[1][0]  / det ;

/*		    compute tr_mat the transformation matrix	    */

    for ( i = 0  ; i < 2 ; i++ )    /*  loop on lines	    */
	for ( j = 0; j < 2 ; j++ )  /*	loop on columns	    */
	{
	    tr_mat[i][j] = 0.0 ;
	    for ( k = 0 ; k < 2 ; k++ )
	    {
		tr_mat[i][j] += tab_mat[i][k] * inv_mat[k][j] ;
	    }
	}
    return SUCCESS;
}

/* **************************************************************************** */
publicdef INT mr_calc_3p( xy_cntl, xy_tab, llx, lly, urx, ury, xpoints, ypoints, tr)

/*  Compute a FINDER type 3 point array for pseudo-map-registration  */

DOUBLE xy_cntl[][2];            /* Map control points  */
DOUBLE xy_tab[][2];             /* Tablet control points */
DOUBLE llx,lly,urx,ury;         /* Corners of the registration area  */
FLOAT xpoints[3],ypoints[3];    /* Points to be generated  */
DOUBLE tr[2][2];		/* WCS to NDC transform	    */

{
/*  Create the points (llx,lly),(urx,lly),(urx,ury) and transform to   */
/*  tablet space using xform.  This is required because the window manager */
/*  insists on this configuration in order to support the Raster-Tec 1/10   */

    DOUBLE x_temp,y_temp;
    DOUBLE wcos,wsin;
    INT i;

    for (i=0;i<3;i++)
    {
         switch (i)
         {
         case 0: x_temp=(llx-xy_cntl[0][0]); y_temp=(lly-xy_cntl[0][1]);break;
         case 1: x_temp=(urx-xy_cntl[0][0]); y_temp=(lly-xy_cntl[0][1]); break;
         case 2: x_temp=(urx-xy_cntl[0][0]); y_temp=(ury-xy_cntl[0][1]); break;
         default:  break;
         }
         xpoints[i] = tr[0][0] * x_temp + tr[0][1] * y_temp + xy_tab[0][0];
         ypoints[i] = tr[1][0] * x_temp + tr[1][1] * y_temp + xy_tab[0][1];
    }
    return SUCCESS;
}
/* **************************************************************************** */
publicdef INT mr_calc_4p( xy_cntl, xy_tab, llx, lly, urx, ury, xpoints, ypoints, tr)

/*  Compute a FINDER type 4 point array for pseudo-map-registration  */

DOUBLE xy_cntl[][2];            /* Map control points  */
DOUBLE xy_tab[][2];             /* Tablet control points */
DOUBLE llx,lly,urx,ury;         /* Corners of the registration area  */
FLOAT xpoints[3],ypoints[3];    /* Points to be generated  */
DOUBLE tr[2][2];		/* WCS to NDC transform	    */

{
/*  Create the points (llx,lly),(urx,lly),(urx,ury),(llx,ury) and transform */
/*  to tablet space using xform.  This is required because the window manager */
/*  insists on this configuration in order to support the Raster-Tec 1/10   */

    DOUBLE x_temp,y_temp;
    DOUBLE wcos,wsin;
    INT i;

    for (i=0;i<4;i++)
    {
         switch (i)
         {
         case 0: x_temp=(llx-xy_cntl[0][0]); y_temp=(lly-xy_cntl[0][1]);break;
         case 1: x_temp=(urx-xy_cntl[0][0]); y_temp=(lly-xy_cntl[0][1]); break;
         case 2: x_temp=(urx-xy_cntl[0][0]); y_temp=(ury-xy_cntl[0][1]); break;
         case 3: x_temp=(llx-xy_cntl[0][0]); y_temp=(ury-xy_cntl[0][1]); break;
         default:  break;
         }
         xpoints[i] = tr[0][0] * x_temp + tr[0][1] * y_temp + xy_tab[0][0];
         ypoints[i] = tr[1][0] * x_temp + tr[1][1] * y_temp + xy_tab[0][1];
    }
    return SUCCESS;
}


/* **************************************************************************** */
publicdef INT mr_get_section_corners(str_id,llx,lly,urx,ury)

CHAR str_id[];                     /* S-T-R (Input)               */
DOUBLE *llx,*lly;                   /* Lower left corner (Output)  */
DOUBLE *urx,*ury;                   /* Upper right corner (Output) */
{
    INT len;
    INT section, meridian;
    CHAR text[60], town_dir, range_dir;
    CHAR project[60], twn[16], rng[16];

    EXEC SQL BEGIN DECLARE SECTION;
        double maxx, maxy, minx, miny;
	VARCHAR default_meridian[240];
        VARCHAR sqlstmt[512];
    EXEC SQL END DECLARE SECTION;

    if ((str_id EQUALS NULL) OR (strlen (str_id) EQUALS 0))
	return MR_BAD_STRING;

    qs_inq_c (QS_PROJECT_NAME, project, &len);

    strcpy (text, str_id);
    ts_snowhite (text);
    len = strlen (text);
    ts_str_convert(text, len, '-', ' ');
    if (isalpha (text[len-1])) {
	sscanf(text,"%d %s %s", &section, twn, rng);
	sqlstmt.len = sprintf ((CHAR *)sqlstmt.arr,
			"SELECT DEFAULT_VALUE FROM %s.PROJECT_DEFAULTS \
			 WHERE DEFAULT_NAME = 'PRINCIPLE_MERIDIAN'", project);
	EXEC SQL PREPARE S2 FROM :sqlstmt;
	EXEC SQL DECLARE C2 CURSOR FOR S2;
	EXEC SQL OPEN C2;
	EXEC SQL FETCH C2 INTO :default_meridian;
	meridian = atoi ((CHAR *)default_meridian.arr);
    }
    else
	sscanf(text,"%d %s %s %d", &section, twn, rng, &meridian);

    ts_snowhite (twn);
    len = strlen(twn);
    town_dir = twn[len - 1];
    twn[len - 1] = '\0';

    ts_snowhite (rng);
    len = strlen(rng);
    range_dir = rng[len - 1];
    rng[len - 1] = '\0';
    
    sqlstmt.len = sprintf ((CHAR *)sqlstmt.arr,
			"SELECT B.MINX, B.MAXX, B.MINY, B.MAXY \
			 FROM %s.SECTIONS A, %s.LYNX_CULTURE B \
			 WHERE A.SECTION = %d AND \
			       A.TOWNSHIP = %d AND \
			       A.TOWNSHIP_DIR = '%c' AND \
			       A.RANGE = %d AND \
			       A.RANGE_DIR = '%c' AND \
			       A.MERIDIAN = %d AND \
			       A.LYNX_ID = B.LYNX_ID",
			 project, project, section, atoi (twn),
			 toupper(town_dir), atoi (rng), toupper(range_dir), 
			 meridian);

    EXEC SQL PREPARE S1 FROM :sqlstmt;
    EXEC SQL DECLARE C1 CURSOR FOR S1;
    EXEC SQL OPEN C1;
    EXEC SQL FETCH C1 INTO :minx, :maxx, :miny, :maxy;

    if (OR_STATUS != 0)
	return MR_BAD_STRING;
    else {
	*llx = minx;
	*lly = miny;
	*urx = maxx;
	*ury = maxy;
	return SUCCESS;
    }
err:
    return OR_STATUS;
}

/* **************************************************************************** */
publicdef INT mr_get_str_control_points(xy_cntl, ll_str, ur_str)

/*  Get Section-Township-Range control points  */

CHAR ll_str[];                           /*  Lower left S-T-R       */
CHAR ur_str[];                           /*  Upper right S-T-R      */
DOUBLE xy_cntl[][2];                      /*  X-Y Equivalents        */
{
    CHAR Text[128], xstr[128], ystr[128];
    INT Item, Value, done = FALSE;
    DOUBLE x,y;
    INT status;

    if (STRID == 0)
        am_define_resource(AM_DIALOG, ResourceFile,
                   DIGITIZE_STR_CONTROL_POINT, NULL_FUNCTION_PTR, &STRID, NULL);

    wi_set_dialog_text(STRID, DIG_PNT_EDIT_LL, ll_str);
    wi_set_dialog_text(STRID, DIG_PNT_EDIT_UR, ur_str);

    if (STROpened == FALSE)
    {
        STROpened = TRUE;
        wipush();
        wi_open_dialog(STRID);
    }

    while (done == FALSE)
    {
        wi_request_dialog_item(&STRID, &Item, &Value, Text);

        switch(Item)
        {
            case DIG_STR_BTN_OK:
                 wi_query_dialog_item(STRID, DIG_PNT_EDIT_LL, &Value, ll_str);
                 status = mr_get_section_corners(ll_str,&x,&y,&Dummy,&Dummy);
                 if (x == 0.e0 || status != 0)
                 {
                   am_message(AM_ALERT, mg_message(MR_LOWER_LEFT_ERROR));
                   break;
                 }
                 xy_cntl[0][0] = x;
                 xy_cntl[0][1] = y;
                 wiqccdi(STRID, DIG_PNT_EDIT_UR, &Value, ur_str);
                 status = mr_get_section_corners(ur_str,&Dummy,&Dummy,&x,&y);
                 if (x ==0.e0 || status != 0)
                 {
                   am_message(AM_ALERT,mg_message(MR_UPPER_RIGHT_ERROR));
                   break;
                 }
                 xy_cntl[1][0] = x;
                 xy_cntl[1][1] = y;
                 status = 0;
                 done = TRUE;
                 break;

            case DIG_STR_BTN_CANCEL:
                 status = 2;
                 done = TRUE;
                 break;

            default:
                 break;
        }
    }
    return status;
}


/* **************************************************************************** */
publicdef INT mr_get_str_control_points_term()
{
    am_release_resource(STRID);
    wipop();

    STROpened = FALSE;
    STRID = 0;

    return SUCCESS;

}


/* **************************************************************************** */

publicdef INT mr_get_checkpoints(tflag,map_projection,point_projection)
BOOL tflag;
PROJECTION_STRUCTURE *map_projection,*point_projection;
{
    INT status;
    INT button;
    FLOAT  x_cntl,y_cntl;	/* 12/09/88 SC - wmtlocate expects float args */
    DOUBLE cp_in[2],cp_out[2];
    CHAR text[60];
    BOOL done;
    INT item,value;

    if (CKID == 0)
        am_define_resource(AM_DIALOG, ResourceFile,
                  CHECKPOINT_CDLG, NULL_FUNCTION_PTR, &CKID, NULL);

    if (ug_if_gpx())
	{
	wm_set_mouse_menu( (CHAR**)0, (INT*)0 );  /* use default menu */      
	}

    wipush();
    done = FALSE;
    wi_open_dialog(CKID);

    /* ming:8/9/91 */
    /* flush the event loop buffer since the tablet is holding the buffer */
    /* ------------------------------------------------------------------ */
#ifdef USE_X
    wiz_XFlush (wiv.current_Display);
#endif


    while (done == FALSE)
    {
        wmtlocate(&status,&x_cntl,&y_cntl,&button);

	/* ------------------------------------------------ */
	/* ming:8/12/91 - beep whenever a button is pressed */
	/* ------------------------------------------------ */
	wibeep (1);
					/* When user click C or D to exit. */
	if( button == WM_BUTTON_CANCEL || button == WM_BUTTON_DONE )
	{
	    done = TRUE;
	    break;
	}
        am_message(AM_DIALOG,"");
        if(tflag)
        {
            cp_in[0] = x_cntl;
            cp_in[1] = y_cntl;
            ct_transform_point(cp_in[0],cp_in[1],map_projection,&cp_out[0],
				&cp_out[1],point_projection);
            if(point_projection->projection_type == 0)
            {
                x_cntl = cp_out[1];
                y_cntl = cp_out[0];
            }
            else
            {
                x_cntl = cp_out[0];
                y_cntl = cp_out[1];
            }
        }

        sprintf(text,"%.4f",x_cntl);		/* JSC:11/9/89  changed precision from %.6f to %.4f */
        wi_set_dialog_text(CKID,CHK_PNT_X,text);
        sprintf(text,"%.4f",y_cntl);
        wi_set_dialog_text(CKID,CHK_PNT_Y,text);
    }
    am_release_resource(CKID);
    wipop();
    CKID = 0;

    return SUCCESS;
}

/* END-CODE */
