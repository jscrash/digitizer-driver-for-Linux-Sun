/* DEC/CMS REPLACEMENT HISTORY, Element CT_PRJN_LIST.PC*/
/* *2    14-AUG-1990 13:07:00 VINCE "(SPR 5644) Header Standardization"*/
/* *1    19-JUN-1989 12:29:27 SYSTEM ""*/
/* DEC/CMS REPLACEMENT HISTORY, Element CT_PRJN_LIST.PC*/
/*****************************************************************************/
/******************************************************************************

                Copyright Exploration Systems, Inc. 1989
                    Unpublished -- All rights reserved

THIS SOFTWARE IS THE PROPRIETARY PROPERTY OF Exploration Systems, Inc.  AND MAY
CONTAIN CONFIDENTIAL TRADE SECRET INFORMATION. IT IS LICENSED FOR USE ON THE
DESIGNATED EQUIPMENT ON WHICH IT WAS ORIGINALLY INSTALLED AND  MAY NOT BE
MODIFIED, DUPLICATED OR COPIED IN ANY FORM WITHOUT PRIOR WRITTEN CONSENT OF

                            Exploration Systems
                            c/o Finder Graphics Systems
                            201 Tamal Vista Blvd.
                            Corte Madera, CA  94925
                            (415) 927-0100

(The above notice does not constitute an admission of publication or
unrestricted dissemination of the work)

******************************************************************************/

#include "esi_gl_defs.h"
#include "esi_ct.h"
#include "esi_oracle.h"
#include "esi_ts.h"
#include "esi_qs.h"

/* Function Description -----------------------------------------------------
Description:
    Initialize and manipulate cartographic transformation routines.  Build a 
    list of all projections for the current project.

Prototype:
    publicdef INT ct_projection_list(CHAR ***projection_list, INT *number_of_items, 
                                 BOOL for_mapping);
                                 
Parameters:     (indicate (I)/(O)/(M) for input/output/input-and-modified)
    (O) projection_list -(CHAR ***) Array of pointers to the returned data.
    (O) number_of_items -(INT *) Pointer to the number of items returned.
    (O) for_mapping     -(BOOL) Flag to restrict selection to map drawing
                            projections.

Return Value/Status:
    SUCCESS - Successful completion
    
Scope:
    PUBLIC
    
Limitations/Assumptions:

-----------------------------------------------------------------------------*/

/* BEGIN:   */
#if USE_PROTOTYPES
publicdef INT ct_projection_list (CHAR ***projection_list, INT *number_of_items,
                                  BOOL for_mapping) 
#else
publicdef INT ct_projection_list (projection_list, number_of_items, for_mapping)
CHAR ***projection_list;
INT *number_of_items;
BOOL for_mapping;
#endif
/* EXEC ORACLE OPTION (REBIND = NO); */

    {
    INT status;
    INT i, newitems;
    PROJECT_NAME project;
    
    /*  SQL Definition of the PROJECTIONS Table                  */
    
    EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR projection_id[20][16];
    VARCHAR sqlstmt[500];
    EXEC SQL END DECLARE SECTION;
    
    /************************************************************************/
    
    *number_of_items = 0;
    
    /* * DECLARE THE CURSOR * */
    /* ---------------------- */
    
    qs_inq_c (QS_PROJECT_NAME, project, (INT *)0);
    
    if (for_mapping)
        {
        sqlstmt.len = sprintf ((char *)sqlstmt.arr, 
"SELECT PROJECTION_ID FROM %s.PROJECTIONS\
        WHERE PROJECTION_TYPE != 0 ORDER BY PROJECTION_ID"
                , project);
        }
    else
        {
        sqlstmt.len = sprintf ((char *)sqlstmt.arr, "SELECT PROJECTION_ID FROM %s.PROJECTIONS\
        ORDER BY PROJECTION_ID"
                               , project);
        }
    EXEC SQL PREPARE S1 FROM : sqlstmt;
    EXEC SQL DECLARE PROJ_CUR CURSOR FOR S1;
    EXEC SQL OPEN PROJ_CUR;
    if (OR_STATUS != SUCCESS)
        {
        *projection_list = (CHAR **)NULL;
        return FAIL;
        }
    /* * BUILD THE LIST * */
    /* ------------------ */
    
    *projection_list = ts_tcp_alloc (10);
    FOREVER
        {
        EXEC SQL FETCH PROJ_CUR INTO : projection_id;
        newitems = OR_ROWCOUNT - *number_of_items;
        *number_of_items = OR_ROWCOUNT;
        
        for (i = 0; i < newitems; i++)
            {
            V_SETZERO (projection_id[i]);
            ts_tcp_append (projection_list, (CHAR *)projection_id[i].arr);
            }
        if (OR_STATUS == OR_EOF)
            {
            break;
            }
        }
    /* * CLOSE THE CURSOR * */
    /* -------------------- */
    
    EXEC SQL CLOSE PROJ_CUR;
    return SUCCESS;
    }
/* END:     */
